<?xml version="1.0" encoding="UTF-8"?>
<!--
  ================
  FILE          : kiwi.rnc
  ****************
  PROJECT       : KIWI - Appliance Builder
  COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH, Germany
                :
  AUTHOR        : Thomas Schraitle <toms@suse.de>
  AUTHOR        : Marcus Schaefer <ms@suse.de>
                :
  BELONGS TO    : Operating System images
                :
  DESCRIPTION   : This is the RELAX NG Schema for KIWI
                : configuration files. The schema is maintained
                : in the relax compact syntax. Any changes should
                : made in !! *** kiwi.rnc *** !!
                :
                :
  STATUS        : Development
  ****************
-->
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns:sch="http://purl.oclc.org/dsdl/schematron" xmlns:rng="http://relaxng.org/ns/structure/1.0" xmlns:db="http://docbook.org/ns/docbook" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <define name="safe-posix-name">
    <data type="token">
      <param name="pattern">[a-zA-Z0-9_\-\.]+</param>
    </data>
  </define>
  <define name="safe-posix-short-name">
    <data type="token">
      <param name="pattern">[a-zA-Z0-9_\-\.]{1,32}</param>
    </data>
  </define>
  <define name="safe-posix-long-name">
    <data type="token">
      <param name="pattern">[a-zA-Z0-9_\-\.]{1,128}</param>
    </data>
  </define>
  <define name="locale-name">
    <data type="token">
      <param name="pattern">(POSIX|[a-z]{2,3}_[A-Z]{2})(,[a-z]{2,3}_[A-Z]{2})*</param>
    </data>
  </define>
  <define name="mac-address-type">
    <data type="token">
      <param name="pattern">([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}</param>
    </data>
  </define>
  <define name="size-type">
    <data type="token">
      <param name="pattern">(\d*|image)</param>
    </data>
  </define>
  <define name="number-type">
    <data type="token">
      <param name="pattern">\d+</param>
    </data>
  </define>
  <define name="blocks-type">
    <data type="token">
      <param name="pattern">(\d*|all)</param>
    </data>
  </define>
  <define name="volume-size-type">
    <data type="token">
      <param name="pattern">(\d+|\d+M|\d+G|all)</param>
    </data>
  </define>
  <define name="partition-size-type">
    <data type="token">
      <param name="pattern">(\d+|\d+M|\d+G)</param>
    </data>
  </define>
  <define name="vhd-tag-type">
    <data type="token">
      <param name="pattern">[0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12}</param>
    </data>
  </define>
  <define name="groups-list">
    <data type="token">
      <param name="pattern">[a-zA-Z0-9_\-\.:]+(,[a-zA-Z0-9_\-\.:]+)*</param>
    </data>
  </define>
  <define name="arch-name">
    <data type="token">
      <param name="pattern">(x86_64|i586|i686|ix86|aarch64|arm64|amd64|armv5el|armv5tel|armv6hl|armv6l|armv7hl|armv7l|ppc|ppc64|ppc64le|s390|s390x|riscv64)(,(x86_64|i586|i686|ix86|aarch64|arm64|amd64|armv5el|armv5tel|armv6hl|armv6l|armv7hl|armv7l|ppc|ppc64|ppc64le|s390|s390x|riscv64))*</param>
    </data>
  </define>
  <define name="portnum-type">
    <data type="token">
      <param name="pattern">(\d+|\d+/(udp|tcp))</param>
    </data>
  </define>
  <define name="grub_console">
    <data type="token">
      <param name="pattern">(none|console|gfxterm|serial|vga_text|mda_text|morse|spkmodem)( (none|console|serial|at_keyboard|usb_keyboard))*</param>
    </data>
  </define>
  <define name="fs_attributes">
    <data type="token">
      <param name="pattern">(no-copy-on-write|synchronous-updates)(,(no-copy-on-write|synchronous-updates))*</param>
    </data>
  </define>
  <define name="package-version-type">
    <data type="token">
      <param name="pattern">(0|[1-9][0-9]{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])(\.(0|[1-9][0-9]{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])){3}</param>
    </data>
  </define>
  <define name="simple-uri-type">
    <data type="token">
      <param name="pattern">(file:|https:|http:|ftp:).*</param>
    </data>
  </define>
  <!--
    ==========================================
    start with image description
    
  -->
  <start>
    <ref name="k.image">
      <a:documentation>The start pattern of an image</a:documentation>
    </ref>
  </start>
  <!--
    ==========================================
    main block: <image>
    
  -->
  <div>
    <define name="k.image.name.attribute">
      <ref name="k.imagename.attribute"/>
    </define>
    <define name="k.image.displayname.attribute">
      <ref name="k.displayname.attribute"/>
    </define>
    <define name="k.image.noNamespaceSchemaLocation.attribute">
      <attribute name="xsi:noNamespaceSchemaLocation">
        <a:documentation>The location of the XSD Schema (not relevant for RELAX NG or DTD)</a:documentation>
        <data type="anyURI"/>
      </attribute>
    </define>
    <define name="k.image.schemaLocation.attribute">
      <attribute name="xsi:schemaLocation">
        <a:documentation>A pair of URI references: First is a namespace name,
second the location of the XSD Schema
(not relevant for RELAX NG or DTD)</a:documentation>
        <data type="anyURI"/>
      </attribute>
    </define>
    <define name="k.image.schemaversion.attribute">
      <attribute name="schemaversion">
        <a:documentation>The allowed Schema version (fixed value)</a:documentation>
        <value>8.2</value>
      </attribute>
    </define>
    <define name="k.image.id">
      <attribute name="id">
        <a:documentation>An identification number which is represented in a file
named /etc/ImageID</a:documentation>
      </attribute>
    </define>
    <define name="k.image.attlist">
      <interleave>
        <ref name="k.image.name.attribute"/>
        <optional>
          <ref name="k.image.displayname.attribute"/>
        </optional>
        <optional>
          <ref name="k.image.id"/>
        </optional>
        <ref name="k.image.schemaversion.attribute"/>
        <optional>
          <choice>
            <optional>
              <ref name="k.image.noNamespaceSchemaLocation.attribute"/>
            </optional>
            <optional>
              <ref name="k.image.schemaLocation.attribute"/>
            </optional>
          </choice>
        </optional>
      </interleave>
    </define>
    <define name="k.image">
      <element name="image">
        <a:documentation>The root element of the configuration file</a:documentation>
        <interleave>
          <ref name="k.image.attlist"/>
          <zeroOrMore>
            <ref name="k.include"/>
          </zeroOrMore>
          <ref name="k.description"/>
          <oneOrMore>
            <ref name="k.preferences"/>
          </oneOrMore>
          <zeroOrMore>
            <ref name="k.profiles"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="k.users"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="k.drivers"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="k.strip"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="k.repository"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="k.packages"/>
          </zeroOrMore>
          <optional>
            <ref name="k.extension"/>
          </optional>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common attributes
    
  -->
  <define name="k.id.attribute">
    <attribute name="id">
      <a:documentation>An ID</a:documentation>
      <data type="ID"/>
    </attribute>
  </define>
  <define name="k.name.attribute">
    <attribute name="name">
      <a:documentation>A name</a:documentation>
    </attribute>
  </define>
  <define name="k.bootinclude.attribute">
    <attribute name="bootinclude">
      <a:documentation>Indicates that this package should be part of
the boot image (initrd) too. This attribute
can be used to include for example branding packages
specified in the system image description to become
part of the boot image also</a:documentation>
      <data type="boolean"/>
    </attribute>
  </define>
  <define name="k.bootdelete.attribute">
    <attribute name="bootdelete">
      <a:documentation>Indicates that this package should be removed from
the boot image (initrd). the attribute is only
evaluated if the bootinclude attribute is specified
along with it too</a:documentation>
      <data type="boolean"/>
    </attribute>
  </define>
  <define name="k.displayname.attribute">
    <attribute name="displayname">
      <a:documentation>A friendly display name. Used in the boot menu</a:documentation>
    </attribute>
  </define>
  <define name="k.arch.attribute">
    <attribute name="arch">
      <a:documentation>A system architecture name, matching the 'uname -m' information
Multiple architectures can be combined as comma separated list
e.g arch="x86_64,ix86"</a:documentation>
      <ref name="arch-name"/>
    </attribute>
  </define>
  <define name="k.description.attribute">
    <attribute name="description">
      <a:documentation>A short description</a:documentation>
    </attribute>
  </define>
  <define name="k.path.attribute">
    <attribute name="path">
      <a:documentation>A path</a:documentation>
    </attribute>
  </define>
  <define name="k.profiles.attribute">
    <attribute name="profiles">
      <a:documentation>A profile name which binds the section to this name</a:documentation>
    </attribute>
  </define>
  <define name="k.password.attribute">
    <attribute name="password">
      <a:documentation>The password</a:documentation>
    </attribute>
  </define>
  <define name="k.script.attribute">
    <attribute name="script">
      <a:documentation>A script hook for meta files to be called after the
file was fetched</a:documentation>
    </attribute>
  </define>
  <define name="k.source.attribute">
    <attribute name="source">
      <a:documentation>A source location where a package or configuration file can be found</a:documentation>
    </attribute>
  </define>
  <define name="k.size.attribute">
    <attribute name="size">
      <a:documentation>A partition size or optional image size</a:documentation>
      <ref name="size-type"/>
    </attribute>
  </define>
  <define name="k.dest.attribute">
    <attribute name="dest">
      <a:documentation>Destination of a resource</a:documentation>
    </attribute>
  </define>
  <define name="k.username.attribute">
    <attribute name="username">
      <a:documentation>A name of a user</a:documentation>
    </attribute>
  </define>
  <define name="k.imagename.attribute">
    <attribute name="name">
      <a:documentation>An image name without / and spaces</a:documentation>
      <ref name="safe-posix-name"/>
    </attribute>
  </define>
  <define name="k.clear.attribute">
    <attribute name="clear">
      <a:documentation>Specifies to clear or not some data or configurations</a:documentation>
      <data type="boolean"/>
    </attribute>
  </define>
  <div>
    <define name="k._any.attribute">
      <attribute>
        <a:documentation>Any attribute including in any attribute in any namespace.</a:documentation>
        <anyName/>
      </attribute>
    </define>
    <define name="k._any">
      <element>
        <a:documentation>Any element from almost any namespace except empty ones</a:documentation>
        <anyName>
          <except>
            <nsName ns=""/>
          </except>
        </anyName>
        <zeroOrMore>
          <choice>
            <ref name="k._any.attribute"/>
            <text/>
            <ref name="k._any"/>
          </choice>
        </zeroOrMore>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <extension>
    
  -->
  <div>
    <define name="k.extension.attlist">
      <empty/>
    </define>
    <define name="k.extension">
      <element name="extension">
        <a:documentation>Define custom XML extensions</a:documentation>
        <ref name="k.extension.attlist"/>
        <oneOrMore>
          <ref name="k._any"/>
        </oneOrMore>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <archive>
    
  -->
  <div>
    <define name="k.archive.name.attribute">
      <ref name="k.name.attribute"/>
    </define>
    <define name="k.archive.bootinclude.attribute">
      <ref name="k.bootinclude.attribute"/>
    </define>
    <define name="k.archive.target_dir.attribute">
      <!--
        Extract tarball to the specified target directory.
        By default the target directory is the root(/) of
        the image.
      -->
      <attribute name="target_dir"/>
    </define>
    <define name="k.archive.attlist">
      <interleave>
        <ref name="k.archive.name.attribute"/>
        <optional>
          <ref name="k.archive.bootinclude.attribute"/>
        </optional>
        <optional>
          <ref name="k.archive.target_dir.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.archive">
      <element name="archive">
        <a:documentation>Name of an image archive file (tarball)</a:documentation>
        <ref name="k.archive.attlist"/>
        <empty/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <author>
    
  -->
  <div>
    <define name="k.author.attlist">
      <empty/>
    </define>
    <define name="k.author">
      <element name="author">
        <a:documentation>Author of the image</a:documentation>
        <ref name="k.author.attlist"/>
        <text/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <license>
    
  -->
  <div>
    <define name="k.license.attlist">
      <empty/>
    </define>
    <define name="k.license">
      <element name="license">
        <a:documentation>License of the image</a:documentation>
        <ref name="k.license.attlist"/>
        <text/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <bootloader-theme>
    
  -->
  <div>
    <define name="k.bootloader-theme.attlist">
      <empty/>
    </define>
    <define name="k.bootloader-theme">
      <element name="bootloader-theme">
        <a:documentation>Image bootloader theme setup.</a:documentation>
        <ref name="k.bootloader-theme.attlist"/>
        <text/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <bootsplash-theme>
    
  -->
  <div>
    <define name="k.bootsplash-theme.attlist">
      <empty/>
    </define>
    <define name="k.bootsplash-theme">
      <element name="bootsplash-theme">
        <a:documentation>Image bootsplash theme setup.</a:documentation>
        <ref name="k.bootsplash-theme.attlist"/>
        <text/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <contact>
    
  -->
  <div>
    <define name="k.contact.attlist">
      <empty/>
    </define>
    <define name="k.contact">
      <element name="contact">
        <a:documentation>Contact Information from the Author, like Email etc.</a:documentation>
        <ref name="k.contact.attlist"/>
        <text/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <file>
    
  -->
  <div>
    <define name="k.file.name.attribute">
      <ref name="k.name.attribute"/>
    </define>
    <define name="k.file.arch.attribute">
      <ref name="k.arch.attribute"/>
    </define>
    <define name="k.file.target.attribute">
      <!-- include file as target to the root(/) of the image. -->
      <attribute name="target"/>
    </define>
    <define name="k.file.owner.attribute">
      <!-- set ownership to the file. The value is passed to chown -->
      <attribute name="owner"/>
    </define>
    <define name="k.file.permissions.attribute">
      <!-- set file permissions. The value is passed to chmod -->
      <attribute name="permissions"/>
    </define>
    <define name="k.file.attlist">
      <interleave>
        <ref name="k.file.name.attribute"/>
        <optional>
          <ref name="k.file.target.attribute"/>
        </optional>
        <optional>
          <ref name="k.file.owner.attribute"/>
        </optional>
        <optional>
          <ref name="k.file.permissions.attribute"/>
        </optional>
        <optional>
          <ref name="k.file.arch.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.file">
      <element name="file">
        <a:documentation>A Pointer to a File</a:documentation>
        <ref name="k.file.attlist"/>
        <empty/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <ignore>
    
  -->
  <div>
    <define name="k.ignore.name.attribute">
      <ref name="k.name.attribute"/>
    </define>
    <define name="k.ignore.arch.attribute">
      <ref name="k.arch.attribute"/>
    </define>
    <define name="k.ignore.attlist">
      <interleave>
        <ref name="k.ignore.name.attribute"/>
        <optional>
          <ref name="k.ignore.arch.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.ignore">
      <element name="ignore">
        <a:documentation>Ignores a Package</a:documentation>
        <ref name="k.ignore.attlist"/>
        <empty/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <keytable>
    
  -->
  <div>
    <define name="k.keytable.attlist">
      <empty/>
    </define>
    <define name="k.keytable">
      <element name="keytable">
        <a:documentation>Image keytable setup.</a:documentation>
        <ref name="k.keytable.attlist"/>
        <text/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <locale>
    
  -->
  <div>
    <!-- locale -->
    <define name="k.locale.attlist">
      <empty/>
    </define>
    <define name="k.locale">
      <element name="locale">
        <a:documentation>Image locale setup.</a:documentation>
        <ref name="k.locale.attlist"/>
        <ref name="locale-name"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <rpm-locale-filtering>
    
  -->
  <div>
    <define name="k.rpm-locale-filtering.content">
      <data type="boolean"/>
    </define>
    <define name="k.rpm-locale-filtering.attlist">
      <empty/>
    </define>
    <define name="k.rpm-locale-filtering">
      <!--
        locale-filtering sets the install_lang macro for rpm based
        installations to the configured locale list. This results
        in language specific files to become filtered out by rpm
        if they don't match the configured list. Please note it
        depends on the package design if the install_lang macro
        contents apply to the package or not.
      -->
      <element name="rpm-locale-filtering">
        <ref name="k.rpm-locale-filtering.attlist"/>
        <ref name="k.rpm-locale-filtering.content"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <namedCollection>
    
  -->
  <div>
    <define name="k.namedCollection.name.attribute">
      <ref name="k.name.attribute"/>
    </define>
    <define name="k.namedCollection.arch.attribute">
      <ref name="k.arch.attribute"/>
    </define>
    <define name="k.namedCollection.attlist">
      <interleave>
        <ref name="k.namedCollection.name.attribute"/>
        <optional>
          <ref name="k.namedCollection.arch.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.namedCollection">
      <element name="namedCollection">
        <a:documentation>Name of a Pattern for SUSE or a Group for RH</a:documentation>
        <ref name="k.namedCollection.attlist"/>
        <empty/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <collectionModule>
    
  -->
  <div>
    <sch:pattern id="collection_module_scope">
      <sch:rule context="collectionModule">
        <sch:assert test="../@type='bootstrap'">collectionModule is only available in the bootstrap packages section</sch:assert>
      </sch:rule>
    </sch:pattern>
    <sch:pattern id="collection_module_disable_constraint">
      <sch:rule context="collectionModule">
        <sch:assert test="@enable='true' or not(@stream)">@stream attribute is not allowed to disable a module</sch:assert>
      </sch:rule>
    </sch:pattern>
    <define name="k.collectionModule.name.attribute">
      <attribute name="name">
        <ref name="safe-posix-name"/>
      </attribute>
    </define>
    <define name="k.collectionModule.stream.attribute">
      <attribute name="stream">
        <ref name="safe-posix-name"/>
      </attribute>
    </define>
    <define name="k.collectionModule.arch.attribute">
      <ref name="k.arch.attribute"/>
    </define>
    <define name="k.collectionModule.enable.attribute">
      <attribute name="enable">
        <a:documentation>Specify the module to become enabled (for the optionally
given stream) or disabled.</a:documentation>
        <data type="boolean"/>
      </attribute>
    </define>
    <define name="k.collectionModule.attlist">
      <interleave>
        <ref name="k.collectionModule.name.attribute"/>
        <ref name="k.collectionModule.enable.attribute"/>
        <optional>
          <ref name="k.collectionModule.stream.attribute"/>
        </optional>
        <optional>
          <ref name="k.collectionModule.arch.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.collectionModule">
      <element name="collectionModule">
        <ref name="k.collectionModule.attlist"/>
        <empty/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-boot-title>
    
  -->
  <div>
    <define name="k.oem-boot-title.attlist">
      <empty/>
    </define>
    <define name="k.oem-boot-title">
      <element name="oem-boot-title">
        <a:documentation>For oemboot driven images: setup of the boot menu text
displayed within the square brackets after first reboot
of the OEM image</a:documentation>
        <ref name="k.oem-boot-title.attlist"/>
        <text/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-bootwait>
    
  -->
  <div>
    <define name="k.oem-bootwait.content">
      <data type="boolean"/>
    </define>
    <define name="k.oem-bootwait.attlist">
      <empty/>
    </define>
    <define name="k.oem-bootwait">
      <element name="oem-bootwait">
        <a:documentation>For oemboot driven images: halt system after image dump true/false</a:documentation>
        <ref name="k.oem-bootwait.attlist"/>
        <ref name="k.oem-bootwait.content"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-resize>
    
  -->
  <div>
    <define name="k.oem-resize.content">
      <data type="boolean"/>
    </define>
    <define name="k.oem-resize.attlist">
      <empty/>
    </define>
    <define name="k.oem-resize">
      <element name="oem-resize">
        <a:documentation>activate/deactivate disk resize on first boot: true/false
By default the repart/resize is activated when creating
an oem image. If the disk image should be more simple
and should not react on storage geometry changes at all
this option allows to switch off the use and inclusion
of the kiwi oem dracut module that implements the resize</a:documentation>
        <ref name="k.oem-resize.attlist"/>
        <ref name="k.oem-resize.content"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-resize-once>
    
  -->
  <div>
    <define name="k.oem-resize-once.content">
      <data type="boolean"/>
    </define>
    <define name="k.oem-resize-once.attlist">
      <empty/>
    </define>
    <define name="k.oem-resize-once">
      <element name="oem-resize-once">
        <a:documentation>For oem images: repart/resize only on first boot: true/false
By default the repart/resize happens on every reboot and
therefore also allows for disk geometry changes during the
livetime of the machine. If set to false the repart/resize
operation happens only once and then never again</a:documentation>
        <ref name="k.oem-resize-once.attlist"/>
        <ref name="k.oem-resize-once.content"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-device-filter>
    
  -->
  <div>
    <define name="k.oem-device-filter.content">
      <text/>
    </define>
    <define name="k.oem-device-filter.attlist">
      <empty/>
    </define>
    <define name="k.oem-device-filter">
      <element name="oem-device-filter">
        <a:documentation>For oemboot driven images: filter install devices by given
regular expression. The expression is handled by the bash regexp
operator</a:documentation>
        <ref name="k.oem-device-filter.attlist"/>
        <ref name="k.oem-device-filter.content"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-nic-filter>
    
  -->
  <div>
    <define name="k.oem-nic-filter.content">
      <text/>
    </define>
    <define name="k.oem-nic-filter.attlist">
      <empty/>
    </define>
    <define name="k.oem-nic-filter">
      <element name="oem-nic-filter">
        <a:documentation>For oemboot driven images: filter network interface names by given
regular expression. The expression is handled by the bash regexp
operator. Interface names matching the rule will be skipped. All
other interface names stay in the list. It is also possible to
pass the variable kiwi_oemnicfilter as kernel command
line in a netboot deployment</a:documentation>
        <ref name="k.oem-nic-filter.attlist"/>
        <ref name="k.oem-nic-filter.content"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-inplace-recovery>
    
  -->
  <div>
    <define name="k.oem-inplace-recovery.content">
      <data type="boolean"/>
    </define>
    <define name="k.oem-inplace-recovery.attlist">
      <empty/>
    </define>
    <define name="k.oem-inplace-recovery">
      <element name="oem-inplace-recovery">
        <a:documentation>For oemboot driven images: Specify whether the
recovery archive should be stored as part of the image
or not. If it's not stored it's created during install
of the oem image</a:documentation>
        <ref name="k.oem-inplace-recovery.attlist"/>
        <ref name="k.oem-inplace-recovery.content"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-kiwi-initrd>
    
  -->
  <div>
    <define name="k.oem-kiwi-initrd.content">
      <data type="boolean"/>
    </define>
    <define name="k.oem-kiwi-initrd.attlist">
      <empty/>
    </define>
    <define name="k.oem-kiwi-initrd">
      <element name="oem-kiwi-initrd">
        <a:documentation>For oemboot driven images: use kiwi initrd in any case
and don't replace it with mkinitrd created initrd</a:documentation>
        <ref name="k.oem-kiwi-initrd.attlist"/>
        <ref name="k.oem-kiwi-initrd.content"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-partition-install>
    
  -->
  <div>
    <define name="k.oem-partition-install.content">
      <data type="boolean"/>
    </define>
    <define name="k.oem-partition-install.attlist">
      <empty/>
    </define>
    <define name="k.oem-partition-install">
      <element name="oem-partition-install">
        <a:documentation>For oemboot driven images: install the system not as
disk but into a free partition. If this option is set
all other oem-* options concerning the partition table
will not have any effect</a:documentation>
        <ref name="k.oem-partition-install.attlist"/>
        <ref name="k.oem-partition-install.content"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-reboot>
    
  -->
  <div>
    <define name="k.oem-reboot.content">
      <data type="boolean"/>
    </define>
    <define name="k.oem-reboot.attlist">
      <empty/>
    </define>
    <define name="k.oem-reboot">
      <element name="oem-reboot">
        <a:documentation>For oemboot driven images: reboot after first deployment true/false</a:documentation>
        <ref name="k.oem-reboot.attlist"/>
        <ref name="k.oem-reboot.content"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-reboot-interactive>
    
  -->
  <div>
    <define name="k.oem-reboot-interactive.content">
      <data type="boolean"/>
    </define>
    <define name="k.oem-reboot-interactive.attlist">
      <empty/>
    </define>
    <define name="k.oem-reboot-interactive">
      <element name="oem-reboot-interactive">
        <a:documentation>For oemboot driven images: reboot after first deployment
with an interactive dialog true/false</a:documentation>
        <ref name="k.oem-reboot-interactive.attlist"/>
        <ref name="k.oem-reboot-interactive.content"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-recovery>
    
  -->
  <div>
    <define name="k.oem-recovery.content">
      <data type="boolean"/>
    </define>
    <define name="k.oem-recovery.attlist">
      <empty/>
    </define>
    <define name="k.oem-recovery">
      <element name="oem-recovery">
        <a:documentation>For oemboot driven images: create a recovery archive yes/no</a:documentation>
        <ref name="k.oem-recovery.attlist"/>
        <ref name="k.oem-recovery.content"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-recoveryID>
    
  -->
  <div>
    <define name="k.oem-recoveryID.attlist">
      <empty/>
    </define>
    <define name="k.oem-recoveryID">
      <element name="oem-recoveryID">
        <a:documentation>For oemboot driven images: Set the partition ID of
recovery partition. Default value is 83 (Linux)</a:documentation>
        <ref name="k.oem-recoveryID.attlist"/>
        <data type="nonNegativeInteger"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-recovery-part-size>
    
  -->
  <div>
    <define name="k.oem-recovery-part-size.attlist">
      <empty/>
    </define>
    <define name="k.oem-recovery-part-size">
      <element name="oem-recovery-part-size">
        <a:documentation>For oemboot driven images: Set the size of the
recovery partition. Value is interpreted as MB</a:documentation>
        <ref name="k.oem-recovery-part-size.attlist"/>
        <data type="nonNegativeInteger"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-shutdown>
    
  -->
  <div>
    <define name="k.oem-shutdown.content">
      <data type="boolean"/>
    </define>
    <define name="k.oem-shutdown.attlist">
      <empty/>
    </define>
    <define name="k.oem-shutdown">
      <element name="oem-shutdown">
        <a:documentation>For oemboot driven images: shutdown after first deployment
true/false</a:documentation>
        <ref name="k.oem-shutdown.attlist"/>
        <ref name="k.oem-shutdown.content"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-shutdown-interactive>
    
  -->
  <div>
    <define name="k.oem-shutdown-interactive.content">
      <data type="boolean"/>
    </define>
    <define name="k.oem-shutdown-interactive.attlist">
      <empty/>
    </define>
    <define name="k.oem-shutdown-interactive">
      <element name="oem-shutdown-interactive">
        <a:documentation>For oemboot driven images: shutdown after first deployment
true/false</a:documentation>
        <ref name="k.oem-shutdown-interactive.attlist"/>
        <ref name="k.oem-shutdown-interactive.content"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-silent-boot>
    
  -->
  <div>
    <define name="k.oem-silent-boot.content">
      <data type="boolean"/>
    </define>
    <define name="k.oem-silent-boot.attlist">
      <empty/>
    </define>
    <define name="k.oem-silent-boot">
      <element name="oem-silent-boot">
        <a:documentation>For oemboot driven images: boot silently during the initial boot
true/false</a:documentation>
        <ref name="k.oem-silent-boot.attlist"/>
        <ref name="k.oem-silent-boot.content"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-silent-install>
    
  -->
  <div>
    <define name="k.oem-silent-install.content">
      <data type="boolean"/>
    </define>
    <define name="k.oem-silent-install.attlist">
      <empty/>
    </define>
    <define name="k.oem-silent-install">
      <element name="oem-silent-install">
        <a:documentation>For oemboot driven images: do not show progress of the image
dump process, true/false</a:documentation>
        <ref name="k.oem-silent-install.attlist"/>
        <ref name="k.oem-silent-install.content"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-skip-verify>
    
  -->
  <div>
    <define name="k.oem-skip-verify.content">
      <data type="boolean"/>
    </define>
    <define name="k.oem-skip-verify.attlist">
      <empty/>
    </define>
    <define name="k.oem-skip-verify">
      <element name="oem-skip-verify">
        <a:documentation>For oemboot driven images: do not perform the md5
verification process, true/false</a:documentation>
        <ref name="k.oem-skip-verify.attlist"/>
        <ref name="k.oem-skip-verify.content"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-vmcp-parmfile>
    
  -->
  <div>
    <define name="k.oem-vmcp-parmfile.content">
      <text/>
    </define>
    <define name="k.oem-vmcp-parmfile.attlist">
      <empty/>
    </define>
    <define name="k.oem-vmcp-parmfile">
      <element name="oem-vmcp-parmfile">
        <a:documentation>For oemboot driven images: provide the name of a parmfile
which is loaded via cmsfscat on s390 systems. Default value
is set to: PARM-S11</a:documentation>
        <ref name="k.oem-vmcp-parmfile.attlist"/>
        <ref name="k.oem-vmcp-parmfile.content"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-multipath-scan>
    
  -->
  <div>
    <define name="k.oem-multipath-scan.content">
      <data type="boolean"/>
    </define>
    <define name="k.oem-multipath-scan.attlist">
      <empty/>
    </define>
    <define name="k.oem-multipath-scan">
      <element name="oem-multipath-scan">
        <a:documentation>For oemboot driven images: turn on or off the search
for multipath devices: true/false (default is true)</a:documentation>
        <ref name="k.oem-multipath-scan.attlist"/>
        <ref name="k.oem-multipath-scan.content"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-silent-verify>
    
  -->
  <div>
    <define name="k.oem-silent-verify.content">
      <data type="boolean"/>
    </define>
    <define name="k.oem-silent-verify.attlist">
      <empty/>
    </define>
    <define name="k.oem-silent-verify">
      <element name="oem-silent-verify">
        <a:documentation>For oemboot driven images: do not show progress of the image
verification process, true/false</a:documentation>
        <ref name="k.oem-silent-verify.attlist"/>
        <ref name="k.oem-silent-verify.content"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-swap>
    
  -->
  <div>
    <define name="k.oem-swap.content">
      <data type="boolean"/>
    </define>
    <define name="k.oem-swap.attlist">
      <empty/>
    </define>
    <define name="k.oem-swap">
      <element name="oem-swap">
        <a:documentation>For oemboot driven images: use a swap partition yes/no</a:documentation>
        <ref name="k.oem-swap.attlist"/>
        <ref name="k.oem-swap.content"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-swapsize>
    
  -->
  <div>
    <define name="k.oem-swapsize.attlist">
      <empty/>
    </define>
    <define name="k.oem-swapsize">
      <element name="oem-swapsize">
        <a:documentation>For oemboot driven images: Set the size of the swap
partition in MB</a:documentation>
        <ref name="k.oem-swapsize.attlist"/>
        <data type="nonNegativeInteger"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-swapname>
    
  -->
  <div>
    <define name="k.oem-swapname.attlist">
      <empty/>
    </define>
    <define name="k.oem-swapname">
      <element name="oem-swapname">
        <a:documentation>For oem images: Set the name of the swap space
The name of the swap space is used only if the
image is configured to use the LVM volume manager.
In this case swap is a volume and the volume takes
a name. In any other case the given name will have
no effect.</a:documentation>
        <ref name="k.oem-swapname.attlist"/>
        <text/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-systemsize>
    
  -->
  <div>
    <define name="k.oem-systemsize.attlist">
      <empty/>
    </define>
    <define name="k.oem-systemsize">
      <element name="oem-systemsize">
        <a:documentation>For oemboot driven images: Set the size of the system (root)
partition or LVM partition in MB. If not provided the partition
will grow to the maximum available free space on the disk</a:documentation>
        <ref name="k.oem-systemsize.attlist"/>
        <data type="nonNegativeInteger"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-unattended>
    
  -->
  <div>
    <define name="k.oem-unattended.content">
      <data type="boolean"/>
    </define>
    <define name="k.oem-unattended.attlist">
      <empty/>
    </define>
    <define name="k.oem-unattended">
      <element name="oem-unattended">
        <a:documentation>For oemboot driven images: don't ask questions if possible
true/false</a:documentation>
        <ref name="k.oem-unattended.attlist"/>
        <ref name="k.oem-unattended.content"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <oem-unattended-id>
    
  -->
  <div>
    <define name="k.oem-unattended-id.attlist">
      <empty/>
    </define>
    <define name="k.oem-unattended-id">
      <element name="oem-unattended-id">
        <a:documentation>For oemboot driven images: use the specified disk id
the device is looked up in /dev/disk/by-* and /dev/mapper/*</a:documentation>
        <ref name="k.oem-unattended-id.attlist"/>
        <text/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <product>
    
  -->
  <div>
    <define name="k.product.name.attribute">
      <ref name="k.name.attribute"/>
    </define>
    <define name="k.product.arch.attribute">
      <ref name="k.arch.attribute"/>
    </define>
    <define name="k.product.attlist">
      <interleave>
        <ref name="k.product.name.attribute"/>
        <optional>
          <ref name="k.product.arch.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.product">
      <element name="product">
        <a:documentation>Name of a Product From openSUSE</a:documentation>
        <ref name="k.product.attlist"/>
        <empty/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <option>
    
  -->
  <div>
    <define name="k.option.name.attribute">
      <attribute name="name"/>
    </define>
    <define name="k.option.value.attribute">
      <attribute name="value"/>
    </define>
    <define name="k.option.attlist">
      <interleave>
        <ref name="k.option.name.attribute"/>
        <optional>
          <ref name="k.option.value.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.option">
      <element name="option">
        <a:documentation>A commandline option specification</a:documentation>
        <ref name="k.option.attlist"/>
        <empty/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <shimoption>
    
  -->
  <div>
    <define name="k.shimoption.name.attribute">
      <attribute name="name"/>
    </define>
    <define name="k.shimoption.value.attribute">
      <attribute name="value"/>
    </define>
    <define name="k.shimoption.attlist">
      <interleave>
        <ref name="k.shimoption.name.attribute"/>
        <optional>
          <ref name="k.shimoption.value.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.shimoption">
      <element name="shimoption">
        <a:documentation>A shim setup option specification</a:documentation>
        <ref name="k.shimoption.attlist"/>
        <empty/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <installoption>
    
  -->
  <div>
    <define name="k.installoption.name.attribute">
      <attribute name="name"/>
    </define>
    <define name="k.installoption.value.attribute">
      <attribute name="value"/>
    </define>
    <define name="k.installoption.attlist">
      <interleave>
        <ref name="k.installoption.name.attribute"/>
        <optional>
          <ref name="k.installoption.value.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.installoption">
      <element name="installoption">
        <a:documentation>A install command option specification</a:documentation>
        <ref name="k.installoption.attlist"/>
        <empty/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <configoption>
    
  -->
  <div>
    <define name="k.configoption.name.attribute">
      <attribute name="name"/>
    </define>
    <define name="k.configoption.value.attribute">
      <attribute name="value"/>
    </define>
    <define name="k.configoption.attlist">
      <interleave>
        <ref name="k.configoption.name.attribute"/>
        <optional>
          <ref name="k.configoption.value.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.configoption">
      <element name="configoption">
        <a:documentation>A config command option specification</a:documentation>
        <ref name="k.configoption.attlist"/>
        <empty/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <package>
    
  -->
  <div>
    <define name="k.package.name.attribute">
      <ref name="k.name.attribute"/>
    </define>
    <define name="k.package.arch.attribute">
      <ref name="k.arch.attribute"/>
    </define>
    <define name="k.package.bootinclude.attribute">
      <ref name="k.bootinclude.attribute"/>
    </define>
    <define name="k.package.bootdelete.attribute">
      <ref name="k.bootdelete.attribute"/>
    </define>
    <define name="k.package.attlist">
      <interleave>
        <ref name="k.package.name.attribute"/>
        <optional>
          <ref name="k.package.arch.attribute"/>
        </optional>
        <optional>
          <ref name="k.bootdelete.attribute"/>
        </optional>
        <optional>
          <ref name="k.bootinclude.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.package">
      <element name="package">
        <a:documentation>Name of an image Package</a:documentation>
        <ref name="k.package.attlist"/>
        <empty/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <packagemanager>
    
  -->
  <div>
    <define name="k.packagemanager.content">
      <choice>
        <value>apt</value>
        <value>zypper</value>
        <value>dnf4</value>
        <value>dnf5</value>
        <value>microdnf</value>
        <value>pacman</value>
      </choice>
    </define>
    <define name="k.packagemanager.attlist">
      <empty/>
    </define>
    <define name="k.packagemanager">
      <element name="packagemanager">
        <a:documentation>Name of the Package Manager</a:documentation>
        <ref name="k.packagemanager.attlist"/>
        <ref name="k.packagemanager.content"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <release-version>
    
  -->
  <div>
    <define name="k.release-version.content">
      <text/>
    </define>
    <define name="k.release-version.attlist">
      <empty/>
    </define>
    <define name="k.release-version">
      <element name="release-version">
        <a:documentation>Name of the Package Manager</a:documentation>
        <ref name="k.release-version.attlist"/>
        <ref name="k.release-version.content"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <profile>
    
  -->
  <div>
    <define name="k.profile.name.attribute">
      <ref name="k.name.attribute"/>
    </define>
    <define name="k.profile.arch.attribute">
      <ref name="k.arch.attribute"/>
    </define>
    <define name="k.profile.description.attribute">
      <attribute name="description">
        <a:documentation>Description of how this profiles influences the image</a:documentation>
      </attribute>
    </define>
    <define name="k.profile.import.attribute">
      <attribute name="import">
        <a:documentation>Import profile by default if no profile was set on
the command line</a:documentation>
        <data type="boolean"/>
      </attribute>
    </define>
    <define name="k.profile.attlist">
      <interleave>
        <ref name="k.profile.name.attribute"/>
        <ref name="k.profile.description.attribute"/>
        <optional>
          <ref name="k.profile.import.attribute"/>
        </optional>
        <optional>
          <ref name="k.profile.arch.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.profile">
      <element name="profile">
        <a:documentation>Profiles creates a namespace on an image description and
thus can be used to have one description with different
profiles for example KDE and GNOME including different
packages.</a:documentation>
        <ref name="k.profile.attlist"/>
        <zeroOrMore>
          <ref name="k.requires"/>
        </zeroOrMore>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <requires>
    
  -->
  <div>
    <define name="k.requires.profile.attribute">
      <attribute name="profile">
        <a:documentation>The profile name required as part of the current profile
definition.</a:documentation>
      </attribute>
    </define>
    <define name="k.requires.attlist">
      <ref name="k.requires.profile.attribute"/>
    </define>
    <define name="k.requires">
      <element name="requires">
        <a:documentation>Requires is used to set profiles dependencies, with it a profile
definition can be composed by other existing profiles.</a:documentation>
        <ref name="k.requires.attlist"/>
        <empty/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <repository>
    
  -->
  <div>
    <sch:pattern abstract="true" id="repo_type">
      <sch:rule context="repository[@$attr]">
        <sch:assert test="contains('$types', @type)">$attr attribute is only available for the following repository types: $types</sch:assert>
      </sch:rule>
    </sch:pattern>
    <define name="k.repository.profiles.attribute">
      <ref name="k.profiles.attribute"/>
    </define>
    <define name="k.repository.arch.attribute">
      <ref name="k.arch.attribute"/>
    </define>
    <define name="k.repository.type.attribute">
      <attribute name="type">
        <a:documentation>Type of repository</a:documentation>
        <choice>
          <value>apt-deb</value>
          <value>apt-rpm</value>
          <value>deb-dir</value>
          <value>mirrors</value>
          <value>rpm-md</value>
        </choice>
      </attribute>
    </define>
    <define name="k.repository.alias.attribute">
      <attribute name="alias">
        <a:documentation>Alias name to be used for this repository. This is an
optional free-form text restricted to characters from the
POSIX standard. If not set the source attribute
value is used and builds the alias name by running a md5 digest
of the defined URI of the repository. An alias name should be
set if the source argument doesn't really explain what this
repository contains.</a:documentation>
        <ref name="safe-posix-name"/>
      </attribute>
    </define>
    <define name="k.repository.components.attribute">
      <attribute name="components">
        <a:documentation>Distribution components, used for deb repositories. If
not set it defaults to main</a:documentation>
      </attribute>
    </define>
    <define name="k.repository.distribution.attribute">
      <attribute name="distribution">
        <a:documentation>Distribution name information, used for deb repositories</a:documentation>
      </attribute>
    </define>
    <define name="k.repository.imageinclude.attribute">
      <attribute name="imageinclude">
        <a:documentation>Specify whether or not this repository should be configured in the
resulting image. Boolean value true or false, the default is false.</a:documentation>
        <data type="boolean"/>
      </attribute>
    </define>
    <define name="k.repository.imageonly.attribute">
      <attribute name="imageonly">
        <a:documentation>Specify whether or not this repository should be configured in the
resulting image without using it at build time. Boolean value true
or false, the default is false.</a:documentation>
        <data type="boolean"/>
      </attribute>
    </define>
    <define name="k.repository.repository_gpgcheck.attribute">
      <attribute name="repository_gpgcheck">
        <a:documentation>Specify whether or not this specific repository is configured to
to run repository signature validation. If not set, no value is
appended into the repository configuration file.</a:documentation>
        <data type="boolean"/>
      </attribute>
    </define>
    <define name="k.repository.package_gpgcheck.attribute">
      <attribute name="package_gpgcheck">
        <a:documentation>Specify whether or not this specific repository is configured
to run package signature validation. If not set, no value is
appended into the repository configuration file.</a:documentation>
        <data type="boolean"/>
      </attribute>
    </define>
    <define name="k.repository.customize.attribute">
      <attribute name="customize">
        <a:documentation>Specify the path to a customization script.
The script receives the repo file according to the
used package manager as a parameter such that custom
modifications can be placed when needed</a:documentation>
      </attribute>
    </define>
    <define name="k.repository.priority.attribute">
      <attribute name="priority">
        <a:documentation>Channel priority assigned to all packages available in
this channel (0 if not set). If the exact same package
is available in more than one channel, the highest
priority is used</a:documentation>
        <data type="integer"/>
      </attribute>
    </define>
    <define name="k.repository.password.attribute">
      <ref name="k.password.attribute">
        <a:documentation>Channel password if required. It depends on the url type
whether and how this information is passed</a:documentation>
      </ref>
    </define>
    <define name="k.repository.username.attribute">
      <ref name="k.username.attribute">
        <a:documentation>Channel username if required. It depends on the url type
whether and how this information is passed</a:documentation>
      </ref>
    </define>
    <define name="k.repository.sourcetype.attribute">
      <attribute name="sourcetype">
        <a:documentation>Specify the source type of the repository path.
Depending on if the source path is a simple url or a
pointer to a metadata file or mirror list, the
configured package manager needs to be setup
appropriately. By default the source is expected to
be a simple repository url</a:documentation>
        <choice>
          <value>baseurl</value>
          <value>metalink</value>
          <value>mirrorlist</value>
        </choice>
      </attribute>
    </define>
    <define name="k.repository.architectures.attribute">
      <attribute name="architectures">
        <a:documentation>Specifies for which architecture(s) this repository is
supposed to provide packages. Multiple architecture names
needs to be separated by a comma</a:documentation>
        <ref name="arch-name"/>
      </attribute>
      <sch:pattern id="architectures" is-a="repo_type">
        <sch:param name="attr" value="architectures"/>
        <sch:param name="types" value="apt-deb"/>
      </sch:pattern>
    </define>
    <define name="k.repository.attlist">
      <interleave>
        <optional>
          <ref name="k.repository.type.attribute"/>
        </optional>
        <optional>
          <ref name="k.repository.profiles.attribute"/>
        </optional>
        <optional>
          <ref name="k.repository.arch.attribute"/>
        </optional>
        <optional>
          <ref name="k.repository.alias.attribute"/>
        </optional>
        <optional>
          <ref name="k.repository.sourcetype.attribute"/>
        </optional>
        <optional>
          <ref name="k.repository.components.attribute"/>
        </optional>
        <optional>
          <ref name="k.repository.distribution.attribute"/>
        </optional>
        <optional>
          <choice>
            <ref name="k.repository.imageinclude.attribute"/>
            <ref name="k.repository.imageonly.attribute"/>
          </choice>
        </optional>
        <optional>
          <ref name="k.repository.repository_gpgcheck.attribute"/>
        </optional>
        <optional>
          <ref name="k.repository.customize.attribute"/>
        </optional>
        <optional>
          <ref name="k.repository.package_gpgcheck.attribute"/>
        </optional>
        <optional>
          <ref name="k.repository.priority.attribute"/>
        </optional>
        <optional>
          <ref name="k.repository.password.attribute"/>
        </optional>
        <optional>
          <ref name="k.repository.username.attribute"/>
        </optional>
        <optional>
          <ref name="k.repository.architectures.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.repository">
      <element name="repository">
        <a:documentation>The Name of the Repository</a:documentation>
        <ref name="k.repository.attlist"/>
        <ref name="k.source"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <signing>
    
  -->
  <div>
    <define name="k.signing.key.attribute">
      <attribute name="key">
        <a:documentation>Specify path to a signing key for this repo</a:documentation>
        <ref name="simple-uri-type"/>
      </attribute>
    </define>
    <define name="k.signing.attlist">
      <ref name="k.signing.key.attribute"/>
    </define>
    <define name="k.signing">
      <element name="signing">
        <a:documentation>The signing element holds information about
repo/package signing keys</a:documentation>
        <ref name="k.signing.attlist"/>
        <empty/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <source>
    
  -->
  <div>
    <define name="k.source.path.attribute">
      <ref name="k.path.attribute"/>
    </define>
    <define name="k.source.attlist">
      <ref name="k.source.path.attribute"/>
    </define>
    <define name="k.source">
      <element name="source">
        <a:documentation>A Pointer to a data source. This can be a remote location
as well as a path specification</a:documentation>
        <ref name="k.source.attlist"/>
        <zeroOrMore>
          <ref name="k.signing"/>
        </zeroOrMore>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <rpm-check-signatures>
    
  -->
  <div>
    <define name="k.rpm-check-signatures.content">
      <data type="boolean"/>
    </define>
    <define name="k.rpm-check-signatures.attlist">
      <empty/>
    </define>
    <define name="k.rpm-check-signatures">
      <element name="rpm-check-signatures">
        <a:documentation>Sets the used package manager to validate, or not, the
repository and/or package signatures. The behavior can be
slightly different depending on the used package manager.
This is a system wide package manager option, so that, this
value can be overwritten by repository specific configurations.
The default value is false.</a:documentation>
        <ref name="k.rpm-check-signatures.attlist"/>
        <ref name="k.rpm-check-signatures.content"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <rpm-excludedocs>
    
  -->
  <div>
    <define name="k.rpm-excludedocs.content">
      <data type="boolean"/>
    </define>
    <define name="k.rpm-excludedocs.attlist">
      <empty/>
    </define>
    <define name="k.rpm-excludedocs">
      <element name="rpm-excludedocs">
        <a:documentation>Setup if the package manager should exclude docs files
during package installation. This option could be ignored
according to the used package manager.</a:documentation>
        <ref name="k.rpm-excludedocs.attlist"/>
        <ref name="k.rpm-excludedocs.content"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <showlicense>
    
  -->
  <div>
    <define name="k.showlicense.attlist">
      <empty/>
    </define>
    <define name="k.showlicense">
      <element name="showlicense">
        <a:documentation>Image license setup. The specfied license name
will be displayed in a dialog window on boot.</a:documentation>
        <ref name="k.showlicense.attlist"/>
        <text/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <size>
    
  -->
  <div>
    <define name="k.size.unit.attribute">
      <attribute name="unit">
        <a:documentation>The unit of the image size</a:documentation>
        <choice>
          <value>M</value>
          <value>G</value>
        </choice>
      </attribute>
    </define>
    <define name="k.size.unpartitioned.attribute">
      <attribute name="unpartitioned">
        <a:documentation>Specifies the image empty space that will not be partitioned</a:documentation>
        <data type="nonNegativeInteger"/>
      </attribute>
    </define>
    <sch:pattern id="unpartitioned_validation">
      <sch:rule context="type/size[@unpartitioned]">
        <sch:assert test="@unpartitioned &lt;= text()">unpartitioned size must be smaller or equal to the defined size</sch:assert>
      </sch:rule>
    </sch:pattern>
    <define name="k.size.additive.attribute">
      <attribute name="additive">
        <a:documentation>Specifies if the size value is absolute or added on top
of the current data size</a:documentation>
        <data type="boolean"/>
      </attribute>
    </define>
    <define name="k.size.attlist">
      <interleave>
        <optional>
          <ref name="k.size.unit.attribute"/>
        </optional>
        <optional>
          <ref name="k.size.unpartitioned.attribute"/>
        </optional>
        <optional>
          <ref name="k.size.additive.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.size">
      <element name="size">
        <a:documentation>Specifies the Size of an Image in (M)egabyte or (G)igabyte
If the attribute additive is set the value will be added
to the required size of the image</a:documentation>
        <ref name="k.size.attlist"/>
        <data type="nonNegativeInteger"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <specification>
    
  -->
  <div>
    <define name="k.specification.attlist">
      <empty/>
    </define>
    <define name="k.specification">
      <element name="specification">
        <a:documentation>A detailed description of this image and what it
can be used for.</a:documentation>
        <ref name="k.specification.attlist"/>
        <text/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <systemdisk>
    
  -->
  <div>
    <define name="k.systemdisk.name.attribute">
      <attribute name="name">
        <a:documentation>Specify Volume group name, default is kiwiVG. This
information is only used if the LVM volume management
is used</a:documentation>
      </attribute>
    </define>
    <define name="k.systemdisk.preferlvm.attribute">
      <attribute name="preferlvm">
        <a:documentation>Prefer LVM even if the used filesystem has its own
volume management system</a:documentation>
        <data type="boolean"/>
      </attribute>
    </define>
    <define name="k.systemdisk.attlist">
      <interleave>
        <optional>
          <ref name="k.systemdisk.name.attribute"/>
        </optional>
        <optional>
          <ref name="k.systemdisk.preferlvm.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.systemdisk">
      <element name="systemdisk">
        <a:documentation>Specify volumes and size attributes</a:documentation>
        <interleave>
          <ref name="k.systemdisk.attlist"/>
          <zeroOrMore>
            <ref name="k.volume"/>
          </zeroOrMore>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <timezone>
    
  -->
  <div>
    <define name="k.timezone.attlist">
      <empty/>
    </define>
    <define name="k.timezone">
      <element name="timezone">
        <a:documentation>Setup Image Timezone setup</a:documentation>
        <ref name="k.timezone.attlist"/>
        <text/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <type>
    
  -->
  <div>
    <sch:pattern abstract="true" id="image_type">
      <sch:rule context="type[@$attr]">
        <sch:assert test="contains('$types', @image)">$attr attribute is only available for the following image types: $types</sch:assert>
      </sch:rule>
    </sch:pattern>
    <sch:pattern abstract="true" id="image_type_requirement">
      <sch:rule context="type[contains('$types', @image)]">
        <sch:assert test="@$attr">$attr attribute must be set for the following image types: $types</sch:assert>
      </sch:rule>
    </sch:pattern>
    <sch:pattern abstract="true" id="image_expandable">
      <sch:rule context="type[@$attr='true']">
        <sch:assert test="oemconfig/oem-resize[contains(text(), 'false')]">$attr attribute also needs the setting: &lt;oem-resize&gt;false&lt;/oem-resize&gt; in the &lt;oemconfig&gt; section of the selected &lt;type&gt;</sch:assert>
      </sch:rule>
    </sch:pattern>
    <sch:pattern abstract="true" id="image_verity_requirement">
      <sch:rule context="type[@embed_verity_metadata]">
        <sch:assert test="@$attr">$attr attribute must be set for embed_verity_metadata</sch:assert>
      </sch:rule>
    </sch:pattern>
    <sch:pattern abstract="true" id="image_integrity_requirement">
      <sch:rule context="type[@embed_integrity_metadata]">
        <sch:assert test="@$attr">$attr attribute must be set for embed_integrity_metadata</sch:assert>
      </sch:rule>
    </sch:pattern>
    <define name="k.type.boot.attribute">
      <attribute name="boot">
        <a:documentation>Specifies the path of the boot image (initrd) description
provided with KIWI</a:documentation>
      </attribute>
      <sch:pattern id="boot" is-a="image_type">
        <sch:param name="attr" value="boot"/>
        <sch:param name="types" value="oem pxe"/>
      </sch:pattern>
    </define>
    <define name="k.type.bootkernel.attribute">
      <attribute name="bootkernel">
        <a:documentation>Specifies the kernel boot profile defined in the boot
image description. When kiwi builds the boot image the
information is passed as add-profile option</a:documentation>
      </attribute>
    </define>
    <define name="k.type.xen_server.attribute">
      <attribute name="xen_server">
        <a:documentation>Specify the image is a Xen dom0 (Xen Server) image
The information is used to create a correct bootloader
configuration with regards to the required loading of
the Xen Hypervisor</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="xen_server" is-a="image_type">
        <sch:param name="attr" value="xen_server"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.btrfs_quota_groups.attribute">
      <attribute name="btrfs_quota_groups">
        <a:documentation>activate the quota system if the filesystem is btrfs based.
By default the quota system is inactive</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="btrfs_quota_groups" is-a="image_type">
        <sch:param name="attr" value="btrfs_quota_groups"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.btrfs_set_default_volume.attribute">
      <attribute name="btrfs_set_default_volume">
        <a:documentation>Tell kiwi to explicitly make a volume the default volume
This can be either (/) or the root subvolume or the root
snapshot depending on the specified btrfs configuration
attributes. By default btrfs_set_default_volume is set to: true
If no default volume should be set, this attribute can be
used to turn it off</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="btrfs_set_default_volume" is-a="image_type">
        <sch:param name="attr" value="btrfs_set_default_volume"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.btrfs_root_is_subvolume.attribute">
      <attribute name="btrfs_root_is_subvolume">
        <a:documentation>Tell kiwi to create a root volume to host (/) inside.
The name of this subvolume is by default set to: '@'
The name of the subvolume can be changed via
a volume entry of the form '&lt;volume name="@root=NAME"/&gt;'
By default the creation of a root subvolume is set to: true</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="btrfs_root_is_subvolume" is-a="image_type">
        <sch:param name="attr" value="btrfs_root_is_subvolume"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.btrfs_root_is_snapshot.attribute">
      <attribute name="btrfs_root_is_snapshot">
        <a:documentation>Tell kiwi to install the system into a btrfs snapshot
The snapshot layout is compatible with the snapper management
toolkit. By default no snapshots are used</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="btrfs_root_is_snapshot" is-a="image_type">
        <sch:param name="attr" value="btrfs_root_is_snapshot"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.btrfs_root_is_readonly_snapshot.attribute">
      <attribute name="btrfs_root_is_readonly_snapshot">
        <a:documentation>Tell kiwi to set the btrfs root filesystem snapshot read-only
Once all data has been placed to the root filesystem snapshot
it will be turned into read-only mode if this option is set to
true. The option is only effective if btrfs_root_is_snapshot
is also set to true. By default the root filesystem snapshot
is writable</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="btrfs_root_is_readonly_snapshot" is-a="image_type">
        <sch:param name="attr" value="btrfs_root_is_readonly_snapshot"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.target_blocksize.attribute">
      <attribute name="target_blocksize">
        <a:documentation>Specifies the image blocksize in bytes which has to match
the logical (SSZ) blocksize of the target storage device.
By default 512 byte is used which works on many disks
However 4096 byte disks are coming. You can check the
desired target by calling: blockdev --report device</a:documentation>
        <data type="nonNegativeInteger"/>
      </attribute>
      <sch:pattern id="target_blocksize" is-a="image_type">
        <sch:param name="attr" value="target_blocksize"/>
        <sch:param name="types" value="oem kis"/>
      </sch:pattern>
    </define>
    <define name="k.type.target_removable.attribute">
      <attribute name="target_removable">
        <a:documentation>Indicate if the target disk for oem images is deployed
to a removable device e.g a USB stick or not. This only
affects the EFI setup if requested and in the end avoids
the creation of a custom boot menu entry in the firmware
of the target machine. By default the target disk is
expected to be non-removable</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="target_removable" is-a="image_type">
        <sch:param name="attr" value="target_removable"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.selinux_policy.attribute">
      <attribute name="selinux_policy">
        <a:documentation>On systems using selinux use the given policy.
by default 'targeted' is used</a:documentation>
        <choice>
          <value>targeted</value>
          <value>mls</value>
          <value>minimum</value>
        </choice>
      </attribute>
    </define>
    <define name="k.type.spare_part.attribute">
      <attribute name="spare_part">
        <a:documentation>Request a spare partition right before the root partition
of the requested size. The attribute takes a size value
and allows a unit in MB or GB, e.g 200M. If no unit is given
the value is considered to be mbytes. A spare partition
can only be configured for the disk image type oem</a:documentation>
        <ref name="partition-size-type"/>
      </attribute>
      <sch:pattern id="spare_part" is-a="image_type">
        <sch:param name="attr" value="spare_part"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.spare_part_mountpoint.attribute">
      <attribute name="spare_part_mountpoint">
        <a:documentation>Specify mount point for spare partition in the system.
Can only be configured for the disk image type oem</a:documentation>
      </attribute>
      <sch:pattern id="spare_part_mountpoint" is-a="image_type">
        <sch:param name="attr" value="spare_part_mountpoint"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.spare_part_fs.attribute">
      <attribute name="spare_part_fs">
        <a:documentation>Specify filesystem for spare partition in the system.
Can only be configured for the disk image type oem</a:documentation>
        <choice>
          <value>btrfs</value>
          <value>ext2</value>
          <value>ext3</value>
          <value>ext4</value>
          <value>xfs</value>
        </choice>
      </attribute>
      <sch:pattern id="spare_part_fs" is-a="image_type">
        <sch:param name="attr" value="spare_part_fs"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.spare_part_fs_attributes.attribute">
      <attribute name="spare_part_fs_attributes">
        <a:documentation>Specify filesystem attributes for the spare partition.
Attributes can be specified as comma separated list.
Can only be configured for the disk image type oem</a:documentation>
        <ref name="fs_attributes"/>
      </attribute>
      <sch:pattern id="spare_part_fs_attributes" is-a="image_type">
        <sch:param name="attr" value="spare_part_fs_attributes"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.spare_part_is_last.attribute">
      <attribute name="spare_part_is_last">
        <a:documentation>Specify if the spare partition should be the last one in
the partition table. Can only be configured for the oem
type with oem-resize switched off. By default the root
partition is the last one and the spare partition lives
before it. With this attribute that setup can be toggled.
However if the root partition is no longer the last one
the oem repart/resize code can no longer work because
the spare part would block it. Because of that moving
the spare part at the end of the disk is only applied
if oem-resize is switched off. There is a runtime
check in the kiwi code to check this condition</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="spare_part_is_last" is-a="image_type">
        <sch:param name="attr" value="spare_part_is_last"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
      <sch:pattern id="spare_part_is_last_valid" is-a="image_expandable">
        <sch:param name="attr" value="spare_part_is_last"/>
      </sch:pattern>
    </define>
    <define name="k.type.bootpartsize.attribute">
      <attribute name="bootpartsize">
        <a:documentation>For images with a separate boot partition this attribute
specifies the size in MB. If not set the min bootpart
size is set to 200 MB</a:documentation>
        <data type="nonNegativeInteger"/>
      </attribute>
      <sch:pattern id="bootpartsize" is-a="image_type">
        <sch:param name="attr" value="bootpartsize"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.efipartsize.attribute">
      <attribute name="efipartsize">
        <a:documentation>For images with an EFI fat partition this attribute
specifies the size in MB. If not set the min efipart
size is set to 20 MB</a:documentation>
        <data type="nonNegativeInteger"/>
      </attribute>
      <sch:pattern id="efipartsize" is-a="image_type">
        <sch:param name="attr" value="efipartsize"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.eficsm.attribute">
      <attribute name="eficsm">
        <a:documentation>For images with an EFI layout, specify if the legacy
CSM (BIOS) mode should be supported or not. By default
CSM mode is enabled</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="eficsm" is-a="image_type">
        <sch:param name="attr" value="eficsm"/>
        <sch:param name="types" value="oem iso"/>
      </sch:pattern>
    </define>
    <define name="k.type.efifatimagesize.attribute">
      <attribute name="efifatimagesize">
        <a:documentation>For ISO images (live and install) the EFI boot requires
an embedded FAT image. This attribute specifies the size
in MB. If not set the min efifatimage size is set to 20 MB</a:documentation>
        <data type="nonNegativeInteger"/>
      </attribute>
      <sch:pattern id="efifatimagesize" is-a="image_type">
        <sch:param name="attr" value="efifatimagesize"/>
        <sch:param name="types" value="oem iso"/>
      </sch:pattern>
    </define>
    <define name="k.type.dosparttable_extended_layout.attribute">
      <attribute name="dosparttable_extended_layout">
        <a:documentation>Specify to make use of logical partitions inside of an
extended one. If set to true and if the msdos table type
is active, this will cause the fourth partition to be an
extended partition and all following partitions will be
placed as logical partitions inside of that extended
partition. This setting is useful if more than 4 primary
partitions needs to be created in an msdos table</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="dosparttable_extended_layout" is-a="image_type">
        <sch:param name="attr" value="dosparttable_extended_layout"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.efiparttable.attribute">
      <attribute name="efiparttable">
        <a:documentation>For images with an EFI firmware specifies the partition
table type to use. If not set defaults to gpt partition
table type.</a:documentation>
        <choice>
          <value>msdos</value>
          <value>gpt</value>
        </choice>
      </attribute>
      <sch:pattern id="efiparttable" is-a="image_type">
        <sch:param name="attr" value="efiparttable"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.bootprofile.attribute">
      <attribute name="bootprofile">
        <a:documentation>Specifies the boot profile defined in the boot image
description. When kiwi builds the boot image the
information is passed as add-profile option</a:documentation>
      </attribute>
      <sch:pattern id="bootprofile" is-a="image_type">
        <sch:param name="attr" value="bootprofile"/>
        <sch:param name="types" value="oem iso pxe cpio"/>
      </sch:pattern>
    </define>
    <define name="k.type.compressed.attribute">
      <attribute name="compressed">
        <a:documentation>Specifies whether the image output file should be
compressed or not. This makes only sense for filesystem
only images.</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="compressed" is-a="image_type">
        <sch:param name="attr" value="compressed"/>
        <sch:param name="types" value="pxe kis"/>
      </sch:pattern>
    </define>
    <define name="k.type.devicepersistency.attribute">
      <attribute name="devicepersistency">
        <a:documentation>Specifies which method to use in order to get persistent
storage device names. By default by-uuid is used.</a:documentation>
        <choice>
          <value>by-uuid</value>
          <value>by-label</value>
          <value>by-partuuid</value>
        </choice>
      </attribute>
    </define>
    <define name="k.type.editbootconfig.attribute">
      <attribute name="editbootconfig">
        <a:documentation>Specifies the path to a script which is called right
before the bootloader is installed. The script runs
relative to the directory which contains the image
structure</a:documentation>
      </attribute>
      <sch:pattern id="editbootconfig" is-a="image_type">
        <sch:param name="attr" value="editbootconfig"/>
        <sch:param name="types" value="oem iso"/>
      </sch:pattern>
    </define>
    <define name="k.type.editbootinstall.attribute">
      <attribute name="editbootinstall">
        <a:documentation>Specifies the path to a script which is called right
after the bootloader is installed. The script runs
relative to the directory which contains the image
structure</a:documentation>
      </attribute>
      <sch:pattern id="editbootinstall" is-a="image_type">
        <sch:param name="attr" value="editbootinstall"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.filesystem.attribute">
      <attribute name="filesystem">
        <a:documentation>Specifies the root filesystem type</a:documentation>
        <choice>
          <value>btrfs</value>
          <value>ext2</value>
          <value>ext3</value>
          <value>ext4</value>
          <value>squashfs</value>
          <value>erofs</value>
          <value>xfs</value>
        </choice>
      </attribute>
      <sch:pattern id="filesystem" is-a="image_type">
        <sch:param name="attr" value="filesystem"/>
        <sch:param name="types" value="oem pxe kis iso"/>
      </sch:pattern>
      <sch:pattern id="filesystem_mandatory" is-a="image_type_requirement">
        <sch:param name="attr" value="filesystem"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.erofscompression.attribute">
      <attribute name="erofscompression">
        <a:documentation>Specifies the compression type for erofs</a:documentation>
      </attribute>
      <sch:pattern id="erofscompression" is-a="image_type">
        <sch:param name="attr" value="erofscompression"/>
        <sch:param name="types" value="oem pxe kis iso erofs"/>
      </sch:pattern>
    </define>
    <define name="k.type.squashfscompression.attribute">
      <attribute name="squashfscompression">
        <a:documentation>Specifies the compression type for mksquashfs</a:documentation>
        <choice>
          <value>uncompressed</value>
          <value>gzip</value>
          <value>lzo</value>
          <value>lz4</value>
          <value>xz</value>
          <value>zstd</value>
        </choice>
      </attribute>
      <sch:pattern id="squashfscompression" is-a="image_type">
        <sch:param name="attr" value="squashfscompression"/>
        <sch:param name="types" value="oem pxe kis iso squashfs"/>
      </sch:pattern>
    </define>
    <define name="k.type.verity_blocks.attribute">
      <attribute name="verity_blocks">
        <a:documentation>Specifies to create a dm verity hash from the number of
given blocks and placed at the end of the root filesystem
If the verity hash should be calculated from the complete
file the value 'all' can be specified.</a:documentation>
        <ref name="blocks-type"/>
      </attribute>
      <sch:pattern id="verity_blocks" is-a="image_type">
        <sch:param name="attr" value="verity_blocks"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.embed_verity_metadata.attribute">
      <attribute name="embed_verity_metadata">
        <a:documentation>In combination with the verity_blocks attribute, embed
a verification metadata block at the end of the partition
serving the root filesystem</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="embed_verity_metadata" is-a="image_type">
        <sch:param name="attr" value="embed_verity_metadata"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
      <sch:pattern id="verity_blocks_mandatory" is-a="image_verity_requirement">
        <sch:param name="attr" value="verity_blocks"/>
      </sch:pattern>
    </define>
    <define name="k.type.standalone_integrity.attribute">
      <attribute name="standalone_integrity">
        <a:documentation>Specifies to create a standalone dm integrity layer on
top of the root filesystem</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="standalone_integrity" is-a="image_type">
        <sch:param name="attr" value="standalone_integrity"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.embed_integrity_metadata.attribute">
      <attribute name="embed_integrity_metadata">
        <a:documentation>In combination with the standalone_integrity attribute, embed
an integrity metadata block at the end of the partition
serving the root filesystem</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="embed_integrity_metadata" is-a="image_type">
        <sch:param name="attr" value="embed_integrity_metadata"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
      <sch:pattern id="standalone_integrity_mandatory" is-a="image_integrity_requirement">
        <sch:param name="attr" value="standalone_integrity"/>
      </sch:pattern>
    </define>
    <define name="k.type.integrity_legacy_hmac.attribute">
      <attribute name="integrity_legacy_hmac">
        <a:documentation>In combination with the standalone_integrity attribute,
Allow to use old flawed HMAC calculation (does not protect superblock)</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="integrity_legacy_hmac" is-a="image_type">
        <sch:param name="attr" value="integrity_legacy_hmac"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
      <sch:pattern id="standalone_integrity_mandatory" is-a="integrity_legacy_hmac_requirement">
        <sch:param name="attr" value="standalone_integrity"/>
      </sch:pattern>
    </define>
    <define name="k.type.integrity_keyfile.attribute">
      <attribute name="integrity_keyfile">
        <a:documentation>In combination with the standalone_integrity attribute,
protect access to the integrity map using the given key.</a:documentation>
      </attribute>
      <sch:pattern id="integrity_keyfile" is-a="image_type">
        <sch:param name="attr" value="integrity_keyfile"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.integrity_metadata_key_description">
      <attribute name="integrity_metadata_key_description">
        <a:documentation>In combination with the embed_integrity_metadata attribute,
allows to specify a custom description of an integrity key
as it is expected to be present in the kernel keyring. The
information is placed in the integrity metadata block. If
not specified kiwi creates a key argument string instead
which is based on the given integrity_keyfile filename.
The format of this key argument is:
':basename_of_integrity_keyfile_no_file_extension'</a:documentation>
      </attribute>
      <sch:pattern id="integrity_metadata_key_description" is-a="image_type">
        <sch:param name="attr" value="integrity_metadata_key_description"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.overlayroot.attribute">
      <attribute name="overlayroot">
        <a:documentation>Specifies to use an overlay root system consisting
out of a squashfs compressed read-only root system
overlayed using the overlayfs filesystem into an
extra read-write partition. Available for the disk
image type oem</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="overlayroot" is-a="image_type">
        <sch:param name="attr" value="overlayroot"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.overlayroot_write_partition.attribute">
      <attribute name="overlayroot_write_partition">
        <a:documentation>Specifies to create an extra read-write partition
in combination with the overlayroot attribute on the
target disk. By default the partition is created
and the kiwi-overlay dracut module also expect it
to be present. However, the overlayroot feature could
also be used without dracut (initrd_system="none")
and under certain circumstances it is handy to
configure if the partition table should contain
the read-write partition or not. Available for
the disk image type oem</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="overlayroot_write_partition" is-a="image_type">
        <sch:param name="attr" value="overlayroot_write_partition"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.overlayroot_readonly_partsize.attribute">
      <attribute name="overlayroot_readonly_partsize">
        <a:documentation>Specifies the size in MB of the partition which stores the
squashfs compressed read-only root filesystem in an
overlayroot setup. If not specified kiwi calculates
the needed size by a preliminary creation of the
squashfs compressed file. However this is only accurate
if no changes to the root filesystem data happens
after this calculation, which cannot be guaranteed as
there is at least one optional script hook which is
allowed and applied after the calculation.</a:documentation>
        <data type="nonNegativeInteger"/>
      </attribute>
      <sch:pattern id="overlayroot_readonly_partsize" is-a="image_type">
        <sch:param name="attr" value="overlayroot_readonly_partsize"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.firmware.attribute">
      <attribute name="firmware">
        <a:documentation>Specifies the boot firmware of the system. Most systems
uses a standard BIOS but there are also other firmware
systems like efi, coreboot, etc.. This attribute is
used to differentiate the image according to the firmware
which boots up the system. It mostly has an impact on
the disk layout and the partition table type. The default
firmware setting is based on the architecture. If no
action should be taken on behalf of a firmware setting
or kiwi's default selection, set the firmware to: custom</a:documentation>
        <choice>
          <value>bios</value>
          <value>ec2</value>
          <value>efi</value>
          <value>uefi</value>
          <value>ofw</value>
          <value>opal</value>
          <value>custom</value>
        </choice>
      </attribute>
      <sch:pattern id="firmware" is-a="image_type">
        <sch:param name="attr" value="firmware"/>
        <sch:param name="types" value="oem pxe iso"/>
      </sch:pattern>
    </define>
    <define name="k.type.bootpartition.attribute">
      <attribute name="bootpartition">
        <a:documentation>specify if an extra boot partition should be used or not.
This will overwrite kiwi's default layout</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="bootpartition" is-a="image_type">
        <sch:param name="attr" value="bootpartition"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.bootfilesystem.attribute">
      <attribute name="bootfilesystem">
        <a:documentation>if an extra boot partition is required this attribute
specify which filesystem should be used for it. The
type of the bootloader might overwrite this setting</a:documentation>
        <choice>
          <value>btrfs</value>
          <value>ext2</value>
          <value>ext3</value>
          <value>ext4</value>
          <value>xfs</value>
          <value>fat32</value>
          <value>fat16</value>
        </choice>
      </attribute>
      <sch:pattern id="bootfilesystem" is-a="image_type">
        <sch:param name="attr" value="bootfilesystem"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.flags.attribute">
      <attribute name="flags">
        <a:documentation>Specifies live iso technology and dracut module to use.
If set to overlay the kiwi-live dracut module will be
used to support a live iso system based on squashfs+overlayfs.
If set to dmsquash the dracut standard dmsquash-live module
will be used to support a live iso system based on squashfs
and the device mapper. Please note both modules supports
a different set of live features.</a:documentation>
        <choice>
          <value>overlay</value>
          <value>dmsquash</value>
        </choice>
      </attribute>
      <sch:pattern id="flags" is-a="image_type">
        <sch:param name="attr" value="flags"/>
        <sch:param name="types" value="iso"/>
      </sch:pattern>
    </define>
    <define name="k.type.format.attribute">
      <attribute name="format">
        <a:documentation>Specifies the format of the virtual disk.</a:documentation>
        <choice>
          <value>gce</value>
          <value>ova</value>
          <value>qcow2</value>
          <value>vagrant</value>
          <value>vmdk</value>
          <value>vdi</value>
          <value>vhd</value>
          <value>vhdx</value>
          <value>vhd-fixed</value>
        </choice>
      </attribute>
      <sch:pattern id="format" is-a="image_type">
        <sch:param name="attr" value="format"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.enclave_format.attribute">
      <attribute name="enclave_format">
        <a:documentation>Specifies the format of the virtual disk.</a:documentation>
        <value>aws-nitro</value>
      </attribute>
      <sch:pattern id="enclave_format" is-a="image_type">
        <sch:param name="attr" value="enclave_format"/>
        <sch:param name="types" value="enclave"/>
      </sch:pattern>
    </define>
    <define name="k.type.formatoptions.attribute">
      <attribute name="formatoptions">
        <a:documentation>Specifies additional format options passed on to qemu-img
formatoptions is a comma separated list of format specific
options in a name=value format like qemu-img expects it.
kiwi will take the information and pass it as parameter to
the -o option in the qemu-img call</a:documentation>
      </attribute>
      <sch:pattern id="formatoptions" is-a="image_type">
        <sch:param name="attr" value="formatoptions"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.force_mbr.attribute">
      <attribute name="force_mbr">
        <a:documentation>Force use of MBR (msdos table) partition table even if the
use of the GPT would be the natural choice. On e.g some
arm systems an EFI partition layout is required but must
not be stored in a GPT. For those rare cases this attribute
allows to force the use of the msdos table including all
its restrictions in max partition size and amount of
partitions</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="force_mbr" is-a="image_type">
        <sch:param name="attr" value="force_mbr"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.fsmountoptions.attribute">
      <attribute name="fsmountoptions">
        <a:documentation>Specifies the filesystem mount options which also ends up in fstab
The string given here is passed as value to the -o option of mount</a:documentation>
      </attribute>
    </define>
    <define name="k.type.fscreateoptions.attribute">
      <attribute name="fscreateoptions">
        <a:documentation>Specifies options to create the filesystem</a:documentation>
      </attribute>
    </define>
    <define name="k.type.hybridpersistent.attribute">
      <attribute name="hybridpersistent">
        <a:documentation>Will trigger the creation of a partition for a COW file
to keep data persistent over a reboot</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="hybridpersistent" is-a="image_type">
        <sch:param name="attr" value="hybridpersistent"/>
        <sch:param name="types" value="iso pxe"/>
      </sch:pattern>
    </define>
    <define name="k.type.hybridpersistent_filesystem.attribute">
      <attribute name="hybridpersistent_filesystem">
        <a:documentation>Set the filesystem to use for persistent writing if a
hybrid image is used as disk on e.g a USB Stick. By default
the ext4 filesystem is used</a:documentation>
        <choice>
          <value>ext4</value>
          <value>xfs</value>
        </choice>
      </attribute>
      <sch:pattern id="hybridpersistent_filesystem" is-a="image_type">
        <sch:param name="attr" value="hybridpersistent_filesystem"/>
        <sch:param name="types" value="iso pxe"/>
      </sch:pattern>
    </define>
    <define name="k.type.gpt_hybrid_mbr.attribute">
      <attribute name="gpt_hybrid_mbr">
        <a:documentation>for gpt disk types only:
create a hybrid GPT/MBR partition table</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="gpt_hybrid_mbr" is-a="image_type">
        <sch:param name="attr" value="gpt_hybrid_mbr"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.initrd_system.attribute">
      <attribute name="initrd_system">
        <a:documentation>specify which initrd builder to use, default is dracut
initrd architecture.</a:documentation>
        <choice>
          <value>kiwi</value>
          <value>dracut</value>
          <value>none</value>
        </choice>
      </attribute>
      <sch:pattern id="initrd_system" is-a="image_type">
        <sch:param name="attr" value="initrd_system"/>
        <sch:param name="types" value="oem pxe kis"/>
      </sch:pattern>
    </define>
    <define name="k.type.image.attribute">
      <attribute name="image">
        <a:documentation>Specifies the image type</a:documentation>
        <choice>
          <value>btrfs</value>
          <value>cpio</value>
          <value>docker</value>
          <value>ext2</value>
          <value>ext3</value>
          <value>ext4</value>
          <value>iso</value>
          <value>oem</value>
          <value>pxe</value>
          <value>kis</value>
          <value>squashfs</value>
          <value>erofs</value>
          <value>tbz</value>
          <value>xfs</value>
          <value>oci</value>
          <value>appx</value>
          <value>enclave</value>
        </choice>
      </attribute>
      <sch:pattern id="metadata_path_mandatory" is-a="image_type_requirement">
        <sch:param name="attr" value="metadata_path"/>
        <sch:param name="types" value="appx"/>
      </sch:pattern>
    </define>
    <define name="k.type.metadata_path.attribute">
      <attribute name="metadata_path">
        <a:documentation>Specifies a path to additional metadata required for
the selected image type or its tools used to create
that image type</a:documentation>
      </attribute>
      <sch:pattern id="metadata_path" is-a="image_type">
        <sch:param name="attr" value="metadata_path"/>
        <sch:param name="types" value="appx"/>
      </sch:pattern>
    </define>
    <define name="k.type.installboot.attribute">
      <attribute name="installboot">
        <a:documentation>Specifies the bootloader default boot entry for the
initial boot of a kiwi install image.</a:documentation>
        <choice>
          <value>failsafe-install</value>
          <value>harddisk</value>
          <value>install</value>
        </choice>
      </attribute>
      <sch:pattern id="installboot" is-a="image_type">
        <sch:param name="attr" value="installboot"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.install_continue_on_timeout.attribute">
      <attribute name="install_continue_on_timeout">
        <a:documentation>Specifies the boot timeout handling for the KIWI
install image. If set to "true" the configured timeout
or its default value applies. If set to "false" no
timeout applies in the boot menu of the install image.</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="install_continue_on_timeout" is-a="image_type">
        <sch:param name="attr" value="install_continue_on_timeout"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.installprovidefailsafe.attribute">
      <attribute name="installprovidefailsafe">
        <a:documentation>Specifies if the bootloader menu should provide an
failsafe entry with special kernel parameters or not</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="installprovidefailsafe" is-a="image_type">
        <sch:param name="attr" value="installprovidefailsafe"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.installiso.attribute">
      <attribute name="installiso">
        <a:documentation>Specifies if a install iso should be created (oem only)</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="installiso" is-a="image_type">
        <sch:param name="attr" value="installiso"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.installstick.attribute">
      <attribute name="installstick">
        <a:documentation>Specifies if a install stick should be created (oem only)</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="installstick" is-a="image_type">
        <sch:param name="attr" value="installstick"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.installpxe.attribute">
      <attribute name="installpxe">
        <a:documentation>Specifies if all data for a pxe network installation should
be created (oem only)</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="installpxe" is-a="image_type">
        <sch:param name="attr" value="installpxe"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.mediacheck.attribute">
      <attribute name="mediacheck">
        <a:documentation>Specifies if the bootloader menu should provide an
mediacheck entry to verify ISO integrity or not.
Disabled by default and only available for x86 arch family.</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="mediacheck" is-a="image_type">
        <sch:param name="attr" value="mediacheck"/>
        <sch:param name="types" value="iso"/>
      </sch:pattern>
    </define>
    <define name="k.type.kernelcmdline.attribute">
      <attribute name="kernelcmdline">
        <a:documentation>The kernelcmdline element specifies additional
kernel command line options</a:documentation>
      </attribute>
      <sch:pattern id="kernelcmdline" is-a="image_type">
        <sch:param name="attr" value="kernelcmdline"/>
        <sch:param name="types" value="oem iso pxe kis enclave"/>
      </sch:pattern>
    </define>
    <define name="k.type.luks_version.attribute">
      <attribute name="luks_version">
        <a:documentation>Specify LUKS version. This can be either set to "luks", "luks1"
or "luks2". By default "luks" is used.</a:documentation>
        <choice>
          <value>luks</value>
          <value>luks1</value>
          <value>luks2</value>
        </choice>
      </attribute>
      <sch:pattern id="luksversion" is-a="image_type">
        <sch:param name="attr" value="luksversion"/>
        <sch:param name="types" value="oem iso pxe kis"/>
      </sch:pattern>
    </define>
    <define name="k.type.luks.attribute">
      <attribute name="luks">
        <a:documentation>Setup cryptographic volume along with the given filesystem
using the LUKS extension. The value of this attribute
represents either the password string or the location of
a key file if specified as file:// resource. When using
a key file it is in the responsibility of the user how
this key file is actually being used. By default any
distribution will just open an interactive dialog asking
for credentials at boot time.</a:documentation>
      </attribute>
      <sch:pattern id="luks" is-a="image_type">
        <sch:param name="attr" value="luks"/>
        <sch:param name="types" value="oem iso pxe kis"/>
      </sch:pattern>
    </define>
    <define name="k.type.luksOS.attribute">
      <attribute name="luksOS">
        <a:documentation>With the luksOS value a predefined set of cipher, keysize
and hash format options is passed to the cryptsetup call
in order to create a format compatible to the specified
distribution</a:documentation>
        <value>sle12</value>
      </attribute>
      <sch:pattern id="luksOS" is-a="image_type">
        <sch:param name="attr" value="luksOS"/>
        <sch:param name="types" value="oem iso pxe kis"/>
      </sch:pattern>
    </define>
    <define name="k.type.luks_randomize.attribute">
      <attribute name="luks_randomize">
        <a:documentation>By default, all blocks of a LUKS volume will be filled
with pseudo-random data. If you're shipping an image with
a well-known key, which is going to be re-encrypted at
deployment time, you can decrease the size of the image
by setting this attribute to false.</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="luks_randomize" is-a="image_type">
        <sch:param name="attr" value="luksversion"/>
        <sch:param name="types" value="oem iso pxe kis"/>
      </sch:pattern>
    </define>
    <define name="k.type.luks_pbkdf.attribute">
      <attribute name="luks_pbkdf">
        <a:documentation>When LUKS unlocks a key slot using a user provided
password, it uses a so-called key derivation function
to derive a symmetric encryption key from the password.
Not all boot loaders support all KDF algorithms, hence
this attribute can be used to select a specific algorithm.</a:documentation>
        <choice>
          <value>pbkdf2</value>
          <value>argon2i</value>
          <value>argon2id</value>
        </choice>
      </attribute>
      <sch:pattern id="luks_pbkdf" is-a="image_type">
        <sch:param name="attr" value="luks_pbkdf"/>
        <sch:param name="types" value="oem iso pxe kis"/>
      </sch:pattern>
    </define>
    <define name="k.type.mdraid.attribute">
      <attribute name="mdraid">
        <a:documentation>Setup software raid in degraded mode with one disk
Thus only mirroring and striping is possible</a:documentation>
        <choice>
          <value>mirroring</value>
          <value>striping</value>
        </choice>
      </attribute>
      <sch:pattern id="mdraid" is-a="image_type">
        <sch:param name="attr" value="mdraid"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.primary.attribute">
      <attribute name="primary">
        <a:documentation>Specifies the primary type (choose KIWI option type)</a:documentation>
        <data type="boolean"/>
      </attribute>
    </define>
    <define name="k.type.ramonly.attribute">
      <attribute name="ramonly">
        <a:documentation>for use with overlay filesystems only:
will force any COW action to happen in RAM</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="ramonly" is-a="image_type">
        <sch:param name="attr" value="ramonly"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.rootfs_label.attribute">
      <attribute name="rootfs_label">
        <a:documentation>label to set for the root filesystem. By default ROOT is used</a:documentation>
      </attribute>
      <sch:pattern id="rootfs_label" is-a="image_type">
        <sch:param name="attr" value="rootfs_label"/>
        <sch:param name="types" value="oem pxe kis docker"/>
      </sch:pattern>
    </define>
    <define name="k.type.vga.attribute">
      <attribute name="vga">
        <a:documentation>Specifies the kernel framebuffer mode. More information
about the possible values can be found by calling
hwinfo --framebuffer or in /usr/src/linux/Documentation/fb/vesafb.txt</a:documentation>
      </attribute>
      <sch:pattern id="vga" is-a="image_type">
        <sch:param name="attr" value="vga"/>
        <sch:param name="types" value="oem pxe kis iso"/>
      </sch:pattern>
    </define>
    <define name="k.type.gcelicense.attribute">
      <attribute name="gcelicense">
        <a:documentation>Specifies the license tag in a GCE format</a:documentation>
      </attribute>
      <sch:pattern id="gcelicense" is-a="image_type">
        <sch:param name="attr" value="gcelicense"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.vhdfixedtag.attribute">
      <attribute name="vhdfixedtag">
        <a:documentation>Specifies the GUID in a fixed format VHD</a:documentation>
        <ref name="vhd-tag-type"/>
      </attribute>
      <sch:pattern id="vhdfixedtag" is-a="image_type">
        <sch:param name="attr" value="vhdfixedtag"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.volid.attribute">
      <attribute name="volid">
        <a:documentation>for the iso type only:
Specifies the volume ID (volume name or label) to be written
into the master block. There is space for 32 characters.</a:documentation>
        <ref name="safe-posix-short-name"/>
      </attribute>
      <sch:pattern id="volid" is-a="image_type">
        <sch:param name="attr" value="volid"/>
        <sch:param name="types" value="iso oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.application_id.attribute">
      <attribute name="application_id">
        <a:documentation>for the iso/(oem install iso) type only:
Specifies the Application ID to be written
into the master block. There is space for 128 characters.</a:documentation>
        <ref name="safe-posix-long-name"/>
      </attribute>
      <sch:pattern id="application_id" is-a="image_type">
        <sch:param name="attr" value="application_id"/>
        <sch:param name="types" value="iso oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.wwid_wait_timeout.attribute">
      <attribute name="wwid_wait_timeout">
        <a:documentation>Specifies the wait period in seconds after launching
the multipath daemon to wait until all presented devices
are available on the host. Default timeout is 3 seconds</a:documentation>
        <data type="nonNegativeInteger"/>
      </attribute>
      <sch:pattern id="wwid_wait_timeout" is-a="image_type">
        <sch:param name="attr" value="wwid_wait_timeout"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.derived_from.attribute">
      <attribute name="derived_from">
        <a:documentation>Specifies the image URI of the container image. The image created
by KIWI will use the specified container as the base root
to work on.</a:documentation>
      </attribute>
      <sch:pattern id="derived_from" is-a="image_type">
        <sch:param name="attr" value="derived_from"/>
        <sch:param name="types" value="docker oci"/>
      </sch:pattern>
    </define>
    <define name="k.type.delta_root.attribute">
      <attribute name="delta_root">
        <a:documentation>Together with derived_from create a delta root tree</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="delta_root" is-a="image_type">
        <sch:param name="attr" value="delta_root"/>
        <sch:param name="types" value="docker oci"/>
      </sch:pattern>
    </define>
    <define name="k.type.ensure_empty_tmpdirs.attribute">
      <attribute name="ensure_empty_tmpdirs">
        <a:documentation>Whether to ensure /run and /tmp directories are empty in the
container image created by Kiwi.  Default is true.</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="ensure_empty_tmpdirs" is-a="image_type">
        <sch:param name="attr" value="ensure_empty_tmpdirs"/>
        <sch:param name="types" value="docker oci"/>
      </sch:pattern>
    </define>
    <define name="k.type.publisher.attribute">
      <attribute name="publisher">
        <a:documentation>Specifies the publisher name of the ISO.</a:documentation>
      </attribute>
      <sch:pattern id="publisher" is-a="image_type">
        <sch:param name="attr" value="publisher"/>
        <sch:param name="types" value="iso"/>
      </sch:pattern>
    </define>
    <define name="k.type.disk_start_sector.attribute">
      <attribute name="disk_start_sector">
        <a:documentation>Specifies the first disk sector for the first partition.
Default value is 2048 and it can't be set to any number below the
default.</a:documentation>
        <data type="integer">
          <param name="minInclusive">2048</param>
        </data>
      </attribute>
      <sch:pattern id="disk_start_sector" is-a="image_type">
        <sch:param name="attr" value="disk_start_sector"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.root_clone.attribute">
      <attribute name="root_clone">
        <a:documentation>Clone root partition N times</a:documentation>
        <ref name="number-type"/>
      </attribute>
      <sch:pattern id="root_clone" is-a="image_type">
        <sch:param name="attr" value="root_clone"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.boot_clone.attribute">
      <attribute name="boot_clone">
        <a:documentation>Clone boot partition N times. If no boot partition is
used, the attribute has no effect. The use of a boot
partition can be enforced through the bootpartition
attribute or is implicitly activated according to the
combination of type settings that makes the use of an
extra boot partition a requirement</a:documentation>
        <ref name="number-type"/>
      </attribute>
      <sch:pattern id="boot_clone" is-a="image_type">
        <sch:param name="attr" value="boot_clone"/>
        <sch:param name="types" value="oem"/>
      </sch:pattern>
    </define>
    <define name="k.type.bundle_format.attribute">
      <attribute name="bundle_format">
        <a:documentation>Specifies the bundle format pattern
The format string can contain placeholders for the
following elements

%N : Image name
%P : Concatenated profile name (_)
%A : Architecture name
%I : Bundle ID
%T : Image build type name
%M : Image Major version number
%m : Image Minor version number
%p : Image Patch version number

The specified bundle_format will be used as base name
for all target image files at call time of:
kiwi-ng result bundle ...</a:documentation>
      </attribute>
    </define>
    <define name="k.type.attlist">
      <interleave>
        <optional>
          <ref name="k.type.boot.attribute">
            <a:documentation>Specifies the image type</a:documentation>
          </ref>
        </optional>
        <optional>
          <ref name="k.type.bootfilesystem.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.firmware.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.bootkernel.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.bootpartition.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.bootpartsize.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.efipartsize.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.efifatimagesize.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.eficsm.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.efiparttable.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.dosparttable_extended_layout.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.bootprofile.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.btrfs_quota_groups.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.btrfs_root_is_snapshot.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.btrfs_root_is_subvolume.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.btrfs_set_default_volume.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.btrfs_root_is_readonly_snapshot.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.compressed.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.devicepersistency.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.editbootconfig.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.editbootinstall.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.filesystem.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.flags.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.enclave_format.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.format.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.formatoptions.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.fsmountoptions.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.fscreateoptions.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.squashfscompression.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.erofscompression.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.gcelicense.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.hybridpersistent.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.hybridpersistent_filesystem.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.gpt_hybrid_mbr.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.force_mbr.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.initrd_system.attribute"/>
        </optional>
        <ref name="k.type.image.attribute"/>
        <optional>
          <ref name="k.type.metadata_path.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.installboot.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.install_continue_on_timeout.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.installprovidefailsafe.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.installiso.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.installstick.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.installpxe.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.mediacheck.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.kernelcmdline.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.luks.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.luks_version.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.luksOS.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.luks_randomize.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.luks_pbkdf.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.mdraid.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.overlayroot.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.overlayroot_write_partition.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.overlayroot_readonly_partsize.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.verity_blocks.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.embed_verity_metadata.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.standalone_integrity.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.embed_integrity_metadata.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.integrity_legacy_hmac.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.integrity_metadata_key_description"/>
        </optional>
        <optional>
          <ref name="k.type.integrity_keyfile.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.primary.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.ramonly.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.rootfs_label.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.spare_part.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.spare_part_mountpoint.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.spare_part_fs.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.spare_part_fs_attributes.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.spare_part_is_last.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.target_blocksize.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.target_removable.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.selinux_policy.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.vga.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.vhdfixedtag.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.volid.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.application_id.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.wwid_wait_timeout.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.derived_from.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.delta_root.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.ensure_empty_tmpdirs.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.xen_server.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.publisher.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.disk_start_sector.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.root_clone.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.boot_clone.attribute"/>
        </optional>
        <optional>
          <ref name="k.type.bundle_format.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.type">
      <element name="type">
        <a:documentation>The Image Type of the Logical Extend</a:documentation>
        <interleave>
          <ref name="k.type.attlist"/>
          <optional>
            <ref name="k.bootloader"/>
          </optional>
          <optional>
            <ref name="k.containerconfig"/>
          </optional>
          <optional>
            <ref name="k.machine"/>
          </optional>
          <optional>
            <ref name="k.oemconfig"/>
          </optional>
          <optional>
            <ref name="k.size"/>
          </optional>
          <optional>
            <ref name="k.systemdisk"/>
          </optional>
          <optional>
            <ref name="k.partitions"/>
          </optional>
          <zeroOrMore>
            <ref name="k.vagrantconfig"/>
          </zeroOrMore>
          <optional>
            <ref name="k.installmedia"/>
          </optional>
          <optional>
            <ref name="k.luksformat"/>
          </optional>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <user>
    
  -->
  <div>
    <define name="k.user.name.attribute">
      <ref name="k.name.attribute"/>
    </define>
    <define name="k.user.id.attribute">
      <attribute name="id">
        <a:documentation>The user ID for this user</a:documentation>
        <data type="nonNegativeInteger"/>
      </attribute>
    </define>
    <define name="k.user.groups.attribute">
      <attribute name="groups">
        <a:documentation>The list of groups that the user belongs to. The
first item in the list is used as the login group.
If 'groups' is not present a default group is assigned
to the user according to he specifing toolchain behaviour.</a:documentation>
        <ref name="groups-list"/>
      </attribute>
    </define>
    <define name="k.user.realname.attribute">
      <attribute name="realname">
        <a:documentation>The name of an user</a:documentation>
      </attribute>
    </define>
    <define name="k.user.password.attribute">
      <ref name="k.password.attribute"/>
    </define>
    <define name="k.user.pwdformat">
      <attribute name="pwdformat">
        <a:documentation>Format of the given password, encrypted is the default</a:documentation>
        <choice>
          <value>encrypted</value>
          <value>plain</value>
        </choice>
      </attribute>
    </define>
    <define name="k.user.home.attribute">
      <attribute name="home">
        <a:documentation>The home directory for this user</a:documentation>
      </attribute>
    </define>
    <define name="k.user.shell.attribute">
      <attribute name="shell">
        <a:documentation>The shell for this user</a:documentation>
      </attribute>
    </define>
    <define name="k.user.attlist">
      <interleave>
        <optional>
          <ref name="k.user.groups.attribute"/>
        </optional>
        <optional>
          <ref name="k.user.home.attribute"/>
        </optional>
        <optional>
          <ref name="k.user.id.attribute"/>
        </optional>
        <ref name="k.user.name.attribute"/>
        <ref name="k.user.password.attribute"/>
        <optional>
          <ref name="k.user.pwdformat"/>
        </optional>
        <optional>
          <ref name="k.user.realname.attribute"/>
        </optional>
        <optional>
          <ref name="k.user.shell.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.user">
      <element name="user">
        <a:documentation>A User with Name, Password, Path to Its Home And Shell</a:documentation>
        <interleave>
          <ref name="k.user.attlist"/>
          <empty/>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <version>
    
  -->
  <div>
    <define name="k.version.attlist">
      <empty/>
    </define>
    <define name="k.version">
      <element name="version">
        <a:documentation>A Version Number for the Image, Consists of Major.Minor.Release</a:documentation>
        <interleave>
          <ref name="k.version.attlist"/>
          <text/>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <vmconfig-entry>
    
  -->
  <div>
    <define name="k.vmconfig-entry.attlist">
      <empty/>
    </define>
    <define name="k.vmconfig-entry">
      <element name="vmconfig-entry">
        <a:documentation>An entry for the VM configuration file</a:documentation>
        <interleave>
          <ref name="k.vmconfig-entry.attlist"/>
          <text/>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <vmdisk>
    
  -->
  <div>
    <define name="k.vmdisk.disktype.attribute">
      <attribute name="disktype">
        <a:documentation>The type of the disk as it is internally handled
by the VM (ova only)</a:documentation>
      </attribute>
    </define>
    <define name="k.vmdisk.controller.attribute">
      <attribute name="controller">
        <a:documentation>The disk controller used for the VM guest (vmdk only)</a:documentation>
        <choice>
          <value>ide</value>
          <value>buslogic</value>
          <value>lsilogic</value>
          <value>lsisas1068</value>
          <value>legacyESX</value>
          <value>pvscsi</value>
        </choice>
      </attribute>
    </define>
    <define name="k.vmdisk.id.attribute">
      <attribute name="id">
        <a:documentation>The disk ID / device for the VM disk (vmdk only)</a:documentation>
        <data type="nonNegativeInteger"/>
      </attribute>
    </define>
    <define name="k.vmdisk.device.attribute">
      <attribute name="device">
        <a:documentation>The disk device to appear in the guest (xen only)</a:documentation>
      </attribute>
    </define>
    <define name="k.vmdisk.diskmode.attribute">
      <attribute name="diskmode">
        <a:documentation>The disk mode (vmdk only)</a:documentation>
        <choice>
          <value>monolithicSparse</value>
          <value>monolithicFlat</value>
          <value>twoGbMaxExtentSparse</value>
          <value>twoGbMaxExtentFlat</value>
          <value>streamOptimized</value>
        </choice>
      </attribute>
    </define>
    <define name="k.vmdisk.attlist">
      <interleave>
        <optional>
          <ref name="k.vmdisk.disktype.attribute"/>
        </optional>
        <optional>
          <ref name="k.vmdisk.controller.attribute"/>
        </optional>
        <optional>
          <ref name="k.vmdisk.id.attribute"/>
        </optional>
        <optional>
          <ref name="k.vmdisk.device.attribute"/>
        </optional>
        <optional>
          <ref name="k.vmdisk.diskmode.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.vmdisk">
      <element name="vmdisk">
        <a:documentation>The VM disk definition.</a:documentation>
        <interleave>
          <ref name="k.vmdisk.attlist"/>
          <empty/>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <vmdvd>
    
  -->
  <div>
    <define name="k.vmdvd.controller.attribute">
      <attribute name="controller">
        <a:documentation>The CD/DVD controller used for the VM guest</a:documentation>
        <choice>
          <value>ide</value>
          <value>scsi</value>
        </choice>
      </attribute>
    </define>
    <define name="k.vmdvd.id.attribute">
      <attribute name="id">
        <a:documentation>The CD/DVD ID for the VM CD rom drive</a:documentation>
        <data type="nonNegativeInteger"/>
      </attribute>
    </define>
    <define name="k.vmdvd.attlist">
      <interleave>
        <ref name="k.vmdvd.controller.attribute"/>
        <ref name="k.vmdvd.id.attribute"/>
      </interleave>
    </define>
    <define name="k.vmdvd">
      <element name="vmdvd">
        <a:documentation>The VM CD/DVD drive definition. You can setup either a
scsi CD or an ide CD drive</a:documentation>
        <interleave>
          <ref name="k.vmdvd.attlist"/>
          <empty/>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <vmnic>
    
  -->
  <div>
    <define name="k.vmnic.driver.attribute">
      <attribute name="driver">
        <a:documentation>The driver used for the VM network interface</a:documentation>
      </attribute>
    </define>
    <define name="k.vmnic.interface.attribute">
      <attribute name="interface">
        <a:documentation>The interface ID for the VM network interface</a:documentation>
      </attribute>
    </define>
    <define name="k.vmnic.mode.attribute">
      <attribute name="mode">
        <a:documentation>The VM network mode</a:documentation>
      </attribute>
    </define>
    <define name="k.vmnic.mac.attribute">
      <attribute name="mac">
        <a:documentation>The VM mac address</a:documentation>
        <ref name="mac-address-type"/>
      </attribute>
    </define>
    <define name="k.vmnic.attlist">
      <interleave>
        <optional>
          <ref name="k.vmnic.driver.attribute"/>
        </optional>
        <ref name="k.vmnic.interface.attribute"/>
        <optional>
          <ref name="k.vmnic.mode.attribute"/>
        </optional>
        <optional>
          <ref name="k.vmnic.mac.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.vmnic">
      <element name="vmnic">
        <a:documentation>The VM network interface definition</a:documentation>
        <interleave>
          <ref name="k.vmnic.attlist"/>
          <empty/>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <partition>
    
  -->
  <div>
    <sch:pattern abstract="true" id="partition_name_type">
      <sch:rule context="partition[@name]">
        <sch:assert test="not(contains('$reserved', @name))">partition(name) is reserved Reserved names are '$reserved'</sch:assert>
      </sch:rule>
    </sch:pattern>
    <define name="k.partition.name.attribute">
      <attribute name="name">
        <a:documentation>Partition map name. The name of the partition as handled
by KIWI. Note, that there are the following reserved
names which cannot be used because they are already
represented by existing KIWI attributes: root, readonly,
boot, prep, spare, swap, efi_csm and efi. The filesystem
created on the partition will also use this name in
uppercase as its label</a:documentation>
      </attribute>
      <sch:pattern id="partition_name" is-a="partition_name_type">
        <sch:param name="reserved" value="root readonly boot prep spare swap efi_csm efi"/>
      </sch:pattern>
    </define>
    <define name="k.partition.size.attribute">
      <attribute name="size">
        <a:documentation>Absolute size of the partition.
The value is used as MB by default but you can
add "M" and/or "G" as postfix</a:documentation>
        <ref name="partition-size-type"/>
      </attribute>
    </define>
    <define name="k.partition.partition_type.attribute">
      <attribute name="partition_type">
        <a:documentation>Partition type name in the context of kiwi
Allowed values are: t.linux</a:documentation>
        <choice>
          <value>t.linux</value>
          <value>t.raid</value>
        </choice>
      </attribute>
    </define>
    <define name="k.partition.partition_name.attribute">
      <attribute name="partition_name">
        <a:documentation>Partition name as it appears in the table</a:documentation>
        <ref name="safe-posix-short-name"/>
      </attribute>
    </define>
    <define name="k.partition.mountpoint.attribute">
      <attribute name="mountpoint">
        <a:documentation>Mountpoint below which this partition should be mounted to</a:documentation>
      </attribute>
    </define>
    <define name="k.partition.filesystem.attribute">
      <attribute name="filesystem">
        <a:documentation>Filesystem which should be created on the partition</a:documentation>
        <choice>
          <value>btrfs</value>
          <value>ext2</value>
          <value>ext3</value>
          <value>ext4</value>
          <value>squashfs</value>
          <value>xfs</value>
          <value>fat32</value>
          <value>fat16</value>
        </choice>
      </attribute>
    </define>
    <define name="k.partition.clone.attribute">
      <attribute name="clone">
        <a:documentation>Clone this partition N times</a:documentation>
        <ref name="number-type"/>
      </attribute>
    </define>
    <define name="k.partition.attlist">
      <interleave>
        <ref name="k.partition.name.attribute"/>
        <ref name="k.partition.size.attribute"/>
        <optional>
          <ref name="k.partition.partition_name.attribute"/>
        </optional>
        <optional>
          <ref name="k.partition.partition_type.attribute"/>
        </optional>
        <optional>
          <ref name="k.partition.mountpoint.attribute"/>
        </optional>
        <optional>
          <ref name="k.partition.filesystem.attribute"/>
        </optional>
        <optional>
          <ref name="k.partition.clone.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.partition">
      <element name="partition">
        <a:documentation>Specify custom partition in the partition table</a:documentation>
        <ref name="k.partition.attlist"/>
        <empty/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    common element <volume>
    
  -->
  <div>
    <sch:pattern abstract="true" id="btrfs_quota">
      <sch:rule context="volume">
        <sch:assert test="not(@quota) or ../../@filesystem='btrfs'">quota attribute is only available for the following image filesystem: btrfs</sch:assert>
      </sch:rule>
    </sch:pattern>
    <define name="k.volume.freespace.attribute">
      <attribute name="freespace">
        <a:documentation>free space to be added to this volume. The value is
used as MB by default but you can add "M" and/or "G" as
postfix</a:documentation>
        <ref name="volume-size-type"/>
      </attribute>
    </define>
    <define name="k.volume.name.attribute">
      <attribute name="name">
        <a:documentation>volume name. The name of the volume. if mountpoint is
not specified the name specifies a path which has to
exist inside the root directory.</a:documentation>
      </attribute>
    </define>
    <define name="k.volume.parent.attribute">
      <attribute name="parent">
        <a:documentation>The name/path of the parent volume.
Evaluated only for the btrfs volume manager to allow
specifying the parent subvolume to nest this volume in.
If not specified the parent is always the volume set
as the default volume</a:documentation>
      </attribute>
    </define>
    <define name="k.volume.mountpoint.attribute">
      <attribute name="mountpoint">
        <a:documentation>volume path. The mountpoint specifies a path which has to
exist inside the root directory.</a:documentation>
      </attribute>
    </define>
    <define name="k.volume.size.attribute">
      <attribute name="size">
        <a:documentation>absolute size of the volume. If the size value
is too small to store all data kiwi will exit.
The value is used as MB by default but you can
add "M" and/or "G" as postfix</a:documentation>
        <ref name="volume-size-type"/>
      </attribute>
    </define>
    <define name="k.volume.copy_on_write.attribute">
      <attribute name="copy_on_write">
        <a:documentation>Apply the filesystem copy-on-write attribute for this volume</a:documentation>
        <data type="boolean"/>
      </attribute>
    </define>
    <define name="k.volume.quota.attribute">
      <attribute name="quota">
        <a:documentation>Apply quota value to filesystem volume if supported</a:documentation>
        <ref name="partition-size-type"/>
      </attribute>
      <sch:pattern id="quota" is-a="btrfs_quota"/>
    </define>
    <define name="k.volume.filesystem_check">
      <attribute name="filesystem_check">
        <a:documentation>Indicate that this filesystem should perform the validation
to become filesystem checked. The actual constraints if the
check is performed or not depends on systemd and filesystem
specific components. If not set or set to false no system
component will be triggered to run an eventual filesystem
check, which results in this filesystem to be never checked.
The latter is the default.</a:documentation>
        <data type="boolean"/>
      </attribute>
    </define>
    <define name="k.volume.label.attribute">
      <attribute name="label">
        <a:documentation>filesystem label name of the volume.</a:documentation>
      </attribute>
    </define>
    <define name="k.volume.arch.attribute">
      <ref name="k.arch.attribute"/>
    </define>
    <define name="k.volume.attlist">
      <interleave>
        <optional>
          <ref name="k.volume.copy_on_write.attribute"/>
        </optional>
        <optional>
          <ref name="k.volume.quota.attribute"/>
        </optional>
        <optional>
          <ref name="k.volume.filesystem_check"/>
        </optional>
        <optional>
          <ref name="k.volume.freespace.attribute"/>
        </optional>
        <optional>
          <ref name="k.volume.mountpoint.attribute"/>
        </optional>
        <optional>
          <ref name="k.volume.label.attribute"/>
        </optional>
        <ref name="k.volume.name.attribute"/>
        <optional>
          <ref name="k.volume.parent.attribute"/>
        </optional>
        <optional>
          <ref name="k.volume.size.attribute"/>
        </optional>
        <optional>
          <ref name="k.volume.arch.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.volume">
      <element name="volume">
        <a:documentation>Specify which parts of the filesystem should be
on an extra volume.</a:documentation>
        <ref name="k.volume.attlist"/>
        <empty/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <include>
    
  -->
  <div>
    <define name="k.include.from.attribute">
      <attribute name="from">
        <a:documentation>include given file and replace the include
statement with its contents</a:documentation>
      </attribute>
    </define>
    <define name="k.include.attlist">
      <ref name="k.include.from.attribute"/>
    </define>
    <define name="k.include">
      <element name="include">
        <ref name="k.include.attlist"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <description>
    
  -->
  <div>
    <define name="k.description.type.attribute">
      <attribute name="type">
        <a:documentation>Kiwi distinguishes between two basic image description types
which uses the same format but one is created and provided by
the kiwi developers and the other is created by the users of
kiwi. The type=boot specifies a boot image (initrd) which should
be provided by the kiwi developers wheras type=system specifies
a standard image description created by a kiwi user.</a:documentation>
        <choice>
          <value>boot</value>
          <value>system</value>
        </choice>
      </attribute>
    </define>
    <define name="k.description.attlist">
      <ref name="k.description.type.attribute"/>
    </define>
    <define name="k.description">
      <element name="description">
        <a:documentation>A Short Description</a:documentation>
        <interleave>
          <ref name="k.description.attlist"/>
          <ref name="k.author"/>
          <oneOrMore>
            <ref name="k.contact"/>
          </oneOrMore>
          <ref name="k.specification"/>
          <optional>
            <ref name="k.license"/>
          </optional>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <drivers>
    
  -->
  <div>
    <define name="k.drivers.profiles.attribute">
      <ref name="k.profiles.attribute"/>
    </define>
    <define name="k.drivers.attlist">
      <optional>
        <ref name="k.drivers.profiles.attribute"/>
      </optional>
    </define>
    <define name="k.drivers">
      <element name="drivers">
        <a:documentation>A Collection of Driver Files</a:documentation>
        <interleave>
          <ref name="k.drivers.attlist"/>
          <oneOrMore>
            <ref name="k.file"/>
          </oneOrMore>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <strip>
    
  -->
  <div>
    <define name="k.strip.type.attribute">
      <attribute name="type">
        <a:documentation>Specifies the strip data type. `delete` references
a list of custom files and directories to delete, `tools`
references file names in linux bin/sbin directories to keep, `libs`
references file names in linux lib directories to keep.</a:documentation>
        <choice>
          <value>delete</value>
          <value>tools</value>
          <value>libs</value>
        </choice>
      </attribute>
    </define>
    <define name="k.strip.profiles.attribute">
      <ref name="k.profiles.attribute"/>
    </define>
    <define name="k.strip.attlist">
      <interleave>
        <ref name="k.strip.type.attribute"/>
        <optional>
          <ref name="k.strip.profiles.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.strip">
      <element name="strip">
        <a:documentation>A Collection of files to strip</a:documentation>
        <interleave>
          <ref name="k.strip.attlist"/>
          <oneOrMore>
            <ref name="k.file"/>
          </oneOrMore>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <bootloader>
    
  -->
  <div>
    <sch:pattern abstract="true" id="bootloader_image_type">
      <sch:rule context="bootloader[@$attr]">
        <sch:assert test="contains('$types', ../@image)">bootloader($attr) is only available for the following image types: $types</sch:assert>
      </sch:rule>
    </sch:pattern>
    <sch:pattern abstract="true" id="bootloader_name_type">
      <sch:rule context="bootloader[@$attr]">
        <sch:assert test="contains('$types', @name)">bootloader($attr) attribute is only available for the following bootloader types: $types</sch:assert>
      </sch:rule>
    </sch:pattern>
    <define name="k.bootloader.name.attribute">
      <attribute name="name">
        <a:documentation>Specifies the bootloader used for booting the image.
At the moment grub2, systemd_boot(EFI only), zipl and the
combination of zipl plus userspace grub2(grub2_s390x_emu)
are supported.
The special custom entry allows to skip the bootloader
configuration and installation and leaves this up to the
user which can be done by using the editbootinstall and
editbootconfig custom scripts</a:documentation>
        <choice>
          <value>grub2</value>
          <value>grub2_s390x_emu</value>
          <value>systemd_boot</value>
          <value>custom</value>
          <value>zipl</value>
        </choice>
      </attribute>
      <sch:pattern id="loader_name" is-a="bootloader_image_type">
        <sch:param name="attr" value="name"/>
        <sch:param name="types" value="oem iso"/>
      </sch:pattern>
    </define>
    <define name="k.bootloader.grub_template.attribute">
      <attribute name="grub_template">
        <a:documentation>Specifies a custom grub bootloader template file which will be used
instead of the one provided with Kiwi. A static bootloader template to
create the grub config file is only used in Kiwi if the native method
via the grub mkconfig toolchain does not work properly. As of today,
this is only the case for live and install ISO images. Thus, this
setting only affects the oem and iso image types.</a:documentation>
      </attribute>
      <sch:pattern id="loader_grub_template" is-a="bootloader_image_type">
        <sch:param name="attr" value="grub_template"/>
        <sch:param name="types" value="oem iso"/>
      </sch:pattern>
    </define>
    <define name="k.bootloader.bls.attribute">
      <attribute name="bls">
        <a:documentation>Specifies if the GRUB2 bootloader uses the boot loader specification</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="bls" is-a="bootloader_name_type">
        <sch:param name="attr" value="bls"/>
        <sch:param name="types" value="grub2"/>
      </sch:pattern>
    </define>
    <define name="k.bootloader.console.attribute">
      <attribute name="console">
        <a:documentation>Specifies the bootloader console.</a:documentation>
        <ref name="grub_console"/>
      </attribute>
      <sch:pattern id="loader_console" is-a="bootloader_name_type">
        <sch:param name="attr" value="console"/>
        <sch:param name="types" value="grub2 grub2_s390x_emu"/>
      </sch:pattern>
    </define>
    <define name="k.bootloader.serial_line.attribute">
      <attribute name="serial_line">
        <a:documentation>Specifies the bootloader serial line setup. The setup
is effective if the bootloader console is set to use
the serial line. The attribute is available for the grub
bootloader</a:documentation>
      </attribute>
      <sch:pattern id="serial_line" is-a="bootloader_name_type">
        <sch:param name="attr" value="serial_line"/>
        <sch:param name="types" value="grub2 grub2_s390x_emu"/>
      </sch:pattern>
    </define>
    <define name="k.bootloader.timeout.attribute">
      <attribute name="timeout">
        <a:documentation>Specifies the boot timeout in seconds prior to launching
the default boot option. By default the timeout is set
to 10sec</a:documentation>
        <data type="nonNegativeInteger"/>
      </attribute>
      <sch:pattern id="timeout" is-a="bootloader_name_type">
        <sch:param name="attr" value="timeout"/>
        <sch:param name="types" value="grub2 grub2_s390x_emu systemd_boot zipl"/>
      </sch:pattern>
    </define>
    <define name="k.bootloader.timeout_style.attribute">
      <attribute name="timeout_style">
        <a:documentation>Specifies the boot timeout style to control the way in which
the timeout interacts with displaying the menu. If set the
display of the bootloader menu is delayed after the timeout
expired. In countdown mode an indication of the remaining time
is displayed. The attribute is available for the grub loader.</a:documentation>
        <choice>
          <value>countdown</value>
          <value>hidden</value>
          <value>menu</value>
        </choice>
      </attribute>
      <sch:pattern id="timeout_style" is-a="bootloader_name_type">
        <sch:param name="attr" value="timeout_style"/>
        <sch:param name="types" value="grub2 grub2_s390x_emu"/>
      </sch:pattern>
    </define>
    <define name="k.bootloader.targettype.attribute">
      <attribute name="targettype">
        <a:documentation>The device type of the disk on s390. For zFCP
devices use SCSI, for  emulated DASD devices use FBA,
for 4k DASD devices use CDL</a:documentation>
        <choice>
          <value>FBA</value>
          <value>SCSI</value>
          <value>CDL</value>
        </choice>
      </attribute>
      <sch:pattern id="targettype" is-a="bootloader_name_type">
        <sch:param name="attr" value="targettype"/>
        <sch:param name="types" value="grub2_s390x_emu zipl"/>
      </sch:pattern>
    </define>
    <define name="k.bootloader.use_disk_password.attribute">
      <attribute name="use_disk_password">
        <a:documentation>When /boot is encrypted, make the boot loader store the
password in its configuration file (in cleartext). This
is useful for full disk encryption images</a:documentation>
        <data type="boolean"/>
      </attribute>
    </define>
    <define name="k.bootloader.attlist">
      <interleave>
        <ref name="k.bootloader.name.attribute"/>
        <optional>
          <ref name="k.bootloader.bls.attribute"/>
        </optional>
        <optional>
          <ref name="k.bootloader.console.attribute"/>
        </optional>
        <optional>
          <ref name="k.bootloader.serial_line.attribute"/>
        </optional>
        <optional>
          <ref name="k.bootloader.timeout.attribute"/>
        </optional>
        <optional>
          <ref name="k.bootloader.timeout_style.attribute"/>
        </optional>
        <optional>
          <ref name="k.bootloader.targettype.attribute"/>
        </optional>
        <optional>
          <ref name="k.bootloader.use_disk_password.attribute"/>
        </optional>
        <optional>
          <ref name="k.bootloader.grub_template.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.bootloader">
      <element name="bootloader">
        <a:documentation>The bootloader section is used to select the bootloader
and to provide configuration parameters for it</a:documentation>
        <interleave>
          <ref name="k.bootloader.attlist"/>
          <optional>
            <ref name="k.bootloadersettings"/>
          </optional>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <containerconfig>
    
  -->
  <div>
    <sch:pattern abstract="true" id="container_type">
      <sch:rule context="containerconfig[@$attr]">
        <sch:assert test="contains('$types', ../@image)">containerconfig($attr) is only available for the following image types: $types</sch:assert>
      </sch:rule>
    </sch:pattern>
    <define name="k.containerconfig.name.attribute">
      <attribute name="name">
        <a:documentation>Specifies a name for the container. This is usually the
the repository name of the container as read if the container
image is imported via the docker load command</a:documentation>
      </attribute>
      <sch:pattern id="name" is-a="container_type">
        <sch:param name="attr" value="name"/>
        <sch:param name="types" value="docker oci appx"/>
      </sch:pattern>
    </define>
    <define name="k.containerconfig.tag.attribute">
      <attribute name="tag">
        <a:documentation>Specifies a tag for the container. This is usually the
the tag name of the container as read if the container
image is imported via the docker load command</a:documentation>
      </attribute>
      <sch:pattern id="tag" is-a="container_type">
        <sch:param name="attr" value="tag"/>
        <sch:param name="types" value="docker oci"/>
      </sch:pattern>
    </define>
    <define name="k.containerconfig.additionalnames.attribute">
      <attribute name="additionalnames">
        <a:documentation>Specifies additional names for the container using a comma
separated values string. It supports '&lt;repo1&gt;:&lt;tag2&gt;,&lt;repo2:tag2&gt;'
format. If any of the names does not include the repository or tag
in that case `name` or `tag` attribute values from containerconfig
will be used to build a complete image referrence.</a:documentation>
      </attribute>
      <sch:pattern id="additionalnames" is-a="container_type">
        <sch:param name="attr" value="additionalnames"/>
        <sch:param name="types" value="docker oci"/>
      </sch:pattern>
    </define>
    <define name="k.containerconfig.maintainer.attribute">
      <attribute name="maintainer">
        <a:documentation>Specifies a maintainer for the container.</a:documentation>
      </attribute>
      <sch:pattern id="maintainer" is-a="container_type">
        <sch:param name="attr" value="maintainer"/>
        <sch:param name="types" value="docker oci"/>
      </sch:pattern>
    </define>
    <define name="k.containerconfig.user.attribute">
      <attribute name="user">
        <a:documentation>Specifies a user for the container.</a:documentation>
      </attribute>
      <sch:pattern id="user" is-a="container_type">
        <sch:param name="attr" value="user"/>
        <sch:param name="types" value="docker oci"/>
      </sch:pattern>
    </define>
    <define name="k.containerconfig.workingdir.attribute">
      <attribute name="workingdir">
        <a:documentation>Specifies the default working directory of the container</a:documentation>
      </attribute>
      <sch:pattern id="workingdir" is-a="container_type">
        <sch:param name="attr" value="workingdir"/>
        <sch:param name="types" value="docker oci"/>
      </sch:pattern>
    </define>
    <define name="k.containerconfig.attlist">
      <interleave>
        <ref name="k.containerconfig.name.attribute"/>
        <optional>
          <ref name="k.containerconfig.tag.attribute"/>
        </optional>
        <optional>
          <ref name="k.containerconfig.additionalnames.attribute"/>
        </optional>
        <optional>
          <ref name="k.containerconfig.maintainer.attribute"/>
        </optional>
        <optional>
          <ref name="k.containerconfig.user.attribute"/>
        </optional>
        <optional>
          <ref name="k.containerconfig.workingdir.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.containerconfig">
      <element name="containerconfig">
        <a:documentation>The containerconfig element provides metadata information
to setup a container in order to be prepared for use with
the container engine tool chain. container specific data
should be provided in an additional subsection whereas this
section provides globally useful container information.</a:documentation>
        <interleave>
          <ref name="k.containerconfig.attlist"/>
          <optional>
            <ref name="k.entrypoint"/>
          </optional>
          <optional>
            <ref name="k.subcommand"/>
          </optional>
          <optional>
            <ref name="k.expose"/>
          </optional>
          <optional>
            <ref name="k.volumes"/>
          </optional>
          <optional>
            <ref name="k.stopsignal"/>
          </optional>
          <optional>
            <ref name="k.environment"/>
          </optional>
          <optional>
            <ref name="k.labels"/>
          </optional>
          <optional>
            <ref name="k.history"/>
          </optional>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <entrypoint>
    
  -->
  <div>
    <define name="k.entrypoint.execute.attribute">
      <attribute name="execute">
        <a:documentation>Specifies the entry point program name to execute</a:documentation>
      </attribute>
    </define>
    <define name="k.entrypoint.attlist">
      <choice>
        <ref name="k.entrypoint.execute.attribute"/>
        <ref name="k.clear.attribute"/>
      </choice>
    </define>
    <define name="k.entrypoint">
      <element name="entrypoint">
        <a:documentation>Provides details for the entry point command. This
includes the execution name and its parameters. Arguments
can be optionally specified</a:documentation>
        <interleave>
          <ref name="k.entrypoint.attlist"/>
          <zeroOrMore>
            <ref name="k.argument"/>
          </zeroOrMore>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <subcommand>
    
  -->
  <div>
    <define name="k.subcommand.execute.attribute">
      <attribute name="execute">
        <a:documentation>Specifies the subcommand program name to execute</a:documentation>
      </attribute>
    </define>
    <define name="k.subcommand.attlist">
      <choice>
        <ref name="k.subcommand.execute.attribute"/>
        <ref name="k.clear.attribute"/>
      </choice>
    </define>
    <define name="k.subcommand">
      <element name="subcommand">
        <a:documentation>Provides details for the subcommand command. This
includes the execution name and its parameters. Arguments
can be optionally specified. The subcommand is appended
the command information from the entrypoint. It is in
the responsibility of the author to make sure the
combination of entrypoint and subcommand forms a valid
execution command</a:documentation>
        <interleave>
          <ref name="k.subcommand.attlist"/>
          <zeroOrMore>
            <ref name="k.argument"/>
          </zeroOrMore>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <argument>
    
  -->
  <div>
    <define name="k.argument.name.attribute">
      <attribute name="name">
        <a:documentation>Specifies a command argument name</a:documentation>
      </attribute>
    </define>
    <define name="k.argument.attlist">
      <ref name="k.argument.name.attribute"/>
    </define>
    <define name="k.argument">
      <element name="argument">
        <a:documentation>Provides details about a command argument</a:documentation>
        <interleave>
          <ref name="k.argument.attlist"/>
          <empty/>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <expose>
    
  -->
  <div>
    <define name="k.expose.attlist">
      <empty/>
    </define>
    <define name="k.expose">
      <element name="expose">
        <a:documentation>Provides details about network ports which should be
exposed from the container. At least one port must
be configured</a:documentation>
        <interleave>
          <ref name="k.expose.attlist"/>
          <oneOrMore>
            <ref name="k.port"/>
          </oneOrMore>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <port>
    
  -->
  <div>
    <define name="k.port.number.attribute">
      <attribute name="number">
        <a:documentation>Specifies the port number and transport protocol to expose.
If no protocol is defined OCI defaults are applied.</a:documentation>
        <ref name="portnum-type"/>
      </attribute>
    </define>
    <define name="k.port.attlist">
      <ref name="k.port.number.attribute"/>
    </define>
    <define name="k.port">
      <element name="port">
        <a:documentation>Provides details about an exposed port.</a:documentation>
        <interleave>
          <ref name="k.port.attlist"/>
          <empty/>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <volumes>
    
  -->
  <div>
    <define name="k.volumes.attlist">
      <empty/>
    </define>
    <define name="k.volumes">
      <element name="volumes">
        <a:documentation>Provides details about storage volumes in the container
At least one volume must be configured</a:documentation>
        <interleave>
          <ref name="k.volumes.attlist"/>
          <oneOrMore>
            <ref name="k.volume"/>
          </oneOrMore>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <stopsignal>
    
  -->
  <div>
    <define name="k.stopsignal.attlist">
      <empty/>
    </define>
    <define name="k.stopsignal">
      <element name="stopsignal">
        <a:documentation>The stopsignal element sets the system call signal that
will be sent to the container to exit. This signal can be a
signal name in the format SIG&lt;NAME&gt;, for instance SIGKILL,
or an unsigned number that matches a position in the kernel's
syscall table, for instance 9. The default is SIGTERM if not
defined.</a:documentation>
        <interleave>
          <ref name="k.stopsignal.attlist"/>
          <text/>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <partitions>
    
  -->
  <div>
    <define name="k.partitions.attlist">
      <empty/>
    </define>
    <define name="k.partitions">
      <element name="partitions">
        <a:documentation>Partition table entries within the custom area
of the storage device</a:documentation>
        <interleave>
          <ref name="k.partitions.attlist"/>
          <oneOrMore>
            <ref name="k.partition"/>
          </oneOrMore>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <luksformat>
    
  -->
  <div>
    <sch:pattern id="luks_requirement">
      <sch:rule context="luksformat">
        <sch:assert test="../@luks">luks attribute must be set when using luksformat option(s)</sch:assert>
      </sch:rule>
    </sch:pattern>
    <define name="k.luksformat.attlist">
      <empty/>
    </define>
    <define name="k.luksformat">
      <element name="luksformat">
        <a:documentation>luksFormat option settings</a:documentation>
        <interleave>
          <ref name="k.luksformat.attlist"/>
          <oneOrMore>
            <ref name="k.option"/>
          </oneOrMore>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <bootloadersettings>
    
  -->
  <div>
    <define name="k.bootloadersettings.attlist">
      <empty/>
    </define>
    <define name="k.bootloadersettings">
      <element name="bootloadersettings">
        <a:documentation>Additional bootloader settings</a:documentation>
        <interleave>
          <ref name="k.bootloadersettings.attlist"/>
          <zeroOrMore>
            <ref name="k.shimoption"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="k.installoption"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="k.configoption"/>
          </zeroOrMore>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <environment>
    
  -->
  <div>
    <define name="k.environment.attlist">
      <empty/>
    </define>
    <define name="k.environment">
      <element name="environment">
        <a:documentation>Provides details about the container environment variables
At least one environment variable must be configured</a:documentation>
        <interleave>
          <ref name="k.environment.attlist"/>
          <oneOrMore>
            <ref name="k.env"/>
          </oneOrMore>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <env>
    
  -->
  <div>
    <define name="k.env.name.attribute">
      <attribute name="name">
        <a:documentation>Specifies the environment variable name</a:documentation>
      </attribute>
    </define>
    <define name="k.env.value.attribute">
      <attribute name="value">
        <a:documentation>Specifies the environment variable value</a:documentation>
      </attribute>
    </define>
    <define name="k.env.attlist">
      <interleave>
        <ref name="k.env.name.attribute"/>
        <ref name="k.env.value.attribute"/>
      </interleave>
    </define>
    <define name="k.env">
      <element name="env">
        <a:documentation>Provides details about an environment variable</a:documentation>
        <interleave>
          <ref name="k.env.attlist"/>
          <empty/>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <labels>
    
  -->
  <div>
    <define name="k.labels.attlist">
      <empty/>
    </define>
    <define name="k.labels">
      <element name="labels">
        <a:documentation>Provides details about container labels
At least one label must be configured</a:documentation>
        <interleave>
          <ref name="k.labels.attlist"/>
          <oneOrMore>
            <ref name="k.label"/>
          </oneOrMore>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <label>
    
  -->
  <div>
    <define name="k.label.name.attribute">
      <attribute name="name">
        <a:documentation>Specifies the label name</a:documentation>
      </attribute>
    </define>
    <define name="k.label.value.attribute">
      <attribute name="value">
        <a:documentation>Specifies the label value</a:documentation>
      </attribute>
    </define>
    <define name="k.label.attlist">
      <interleave>
        <ref name="k.label.name.attribute"/>
        <ref name="k.label.value.attribute"/>
      </interleave>
    </define>
    <define name="k.label">
      <element name="label">
        <a:documentation>Provides details about a container label</a:documentation>
        <interleave>
          <ref name="k.label.attlist"/>
          <empty/>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <history>
    
  -->
  <div>
    <define name="k.history.created_by.attribute">
      <attribute name="created_by">
        <a:documentation>Specifies the 'created by' history record. By default set to 'KIWI'</a:documentation>
      </attribute>
    </define>
    <define name="k.history.author.attribute">
      <attribute name="author">
        <a:documentation>Specifies the 'author' history record.</a:documentation>
      </attribute>
    </define>
    <define name="k.history.application_id">
      <attribute name="application_id">
        <a:documentation>Specifies a custom application ID, used for WSL containers</a:documentation>
      </attribute>
    </define>
    <define name="k.history.package_version">
      <attribute name="package_version">
        <a:documentation>Specifies a version information, used for WSL containers.
The version given here follows the package numbering rules
as documented in: https://docs.microsoft.com/en-us/windows/uwp/publish/package-version-numbering</a:documentation>
        <ref name="package-version-type"/>
      </attribute>
    </define>
    <define name="k.history.launcher">
      <attribute name="launcher">
        <a:documentation>Specifies name of the container launcher program
Used for WSL containers</a:documentation>
      </attribute>
    </define>
    <define name="k.history.attlist">
      <interleave>
        <optional>
          <ref name="k.history.created_by.attribute"/>
        </optional>
        <optional>
          <ref name="k.history.author.attribute"/>
        </optional>
        <optional>
          <ref name="k.history.application_id"/>
        </optional>
        <optional>
          <ref name="k.history.package_version"/>
        </optional>
        <optional>
          <ref name="k.history.launcher"/>
        </optional>
      </interleave>
    </define>
    <define name="k.history">
      <element name="history">
        <a:documentation>Provides details about the container history. Includes the
'created by', 'author' as attributes and its content represents
the 'comment' entry.</a:documentation>
        <ref name="k.history.attlist"/>
        <text/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <oemconfig>
    
  -->
  <div>
    <define name="k.oemconfig.attlist">
      <empty/>
    </define>
    <define name="k.oemconfig">
      <element name="oemconfig">
        <a:documentation>The oemconfig element specifies the OEM image
configuration options which are used to repartition
and setup the system disk.</a:documentation>
        <interleave>
          <ref name="k.oemconfig.attlist"/>
          <optional>
            <ref name="k.oem-boot-title"/>
          </optional>
          <optional>
            <ref name="k.oem-bootwait"/>
          </optional>
          <optional>
            <ref name="k.oem-resize"/>
          </optional>
          <optional>
            <ref name="k.oem-resize-once"/>
          </optional>
          <optional>
            <ref name="k.oem-device-filter"/>
          </optional>
          <optional>
            <ref name="k.oem-nic-filter"/>
          </optional>
          <optional>
            <ref name="k.oem-inplace-recovery"/>
          </optional>
          <optional>
            <ref name="k.oem-kiwi-initrd"/>
          </optional>
          <optional>
            <ref name="k.oem-multipath-scan"/>
          </optional>
          <optional>
            <ref name="k.oem-vmcp-parmfile"/>
          </optional>
          <optional>
            <ref name="k.oem-partition-install"/>
          </optional>
          <optional>
            <ref name="k.oem-reboot"/>
          </optional>
          <optional>
            <ref name="k.oem-reboot-interactive"/>
          </optional>
          <optional>
            <ref name="k.oem-recovery"/>
          </optional>
          <optional>
            <ref name="k.oem-recoveryID"/>
          </optional>
          <optional>
            <ref name="k.oem-recovery-part-size"/>
          </optional>
          <optional>
            <ref name="k.oem-shutdown"/>
          </optional>
          <optional>
            <ref name="k.oem-shutdown-interactive"/>
          </optional>
          <optional>
            <ref name="k.oem-silent-boot"/>
          </optional>
          <optional>
            <ref name="k.oem-silent-install"/>
          </optional>
          <optional>
            <ref name="k.oem-silent-verify"/>
          </optional>
          <optional>
            <ref name="k.oem-skip-verify"/>
          </optional>
          <optional>
            <ref name="k.oem-swap"/>
          </optional>
          <optional>
            <ref name="k.oem-swapsize"/>
          </optional>
          <optional>
            <ref name="k.oem-swapname"/>
          </optional>
          <optional>
            <ref name="k.oem-systemsize"/>
          </optional>
          <optional>
            <ref name="k.oem-unattended"/>
          </optional>
          <optional>
            <ref name="k.oem-unattended-id"/>
          </optional>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <vagrantconfig>
    
  -->
  <div>
    <sch:pattern abstract="true" id="vagrant_provider">
      <sch:rule context="vagrantconfig[@$attr]">
        <sch:assert test="contains('$providers', @provider)">$attr attribute is only available for the following vagrant providers: $providers</sch:assert>
      </sch:rule>
    </sch:pattern>
    <define name="k.vagrantconfig.provider.attribute">
      <attribute name="provider">
        <a:documentation>The vagrant provider for this box</a:documentation>
        <choice>
          <value>libvirt</value>
          <value>virtualbox</value>
        </choice>
      </attribute>
    </define>
    <define name="k.vagrantconfig.virtualbox_guest_additions_present.attribute">
      <attribute name="virtualbox_guest_additions_present">
        <a:documentation>Guest additions are present in this box</a:documentation>
        <data type="boolean"/>
      </attribute>
      <sch:pattern id="virtualbox_guest_additions_present" is-a="vagrant_provider">
        <sch:param name="attr" value="virtualbox_guest_additions_present"/>
        <sch:param name="providers" value="virtualbox"/>
      </sch:pattern>
    </define>
    <define name="k.vagrantconfig.embedded_vagrantfile.attribute">
      <attribute name="embedded_vagrantfile">
        <a:documentation>Path to a Vagrantfile that will be embedded in the box
Kiwi cannot check the Vagrantfile for correctnes, therefore use this
at your own risk!</a:documentation>
      </attribute>
    </define>
    <define name="k.vagrantconfig.virtualsize.attribute">
      <attribute name="virtualsize">
        <a:documentation>virtualsize provides the value of the virtual_size key which
is embedded in the metadata.json hash inside the box file, as
described in http://docs.vagrantup.com/v2/boxes/format.html
This tells the Vagrant provider how big to make the
virtual disk when it creates the VM.</a:documentation>
        <data type="nonNegativeInteger"/>
      </attribute>
    </define>
    <define name="k.vagrantconfig.boxname.attribute">
      <attribute name="boxname">
        <a:documentation>The boxname as it's written into the json file
If not specified the image name is used</a:documentation>
      </attribute>
    </define>
    <define name="k.vagrantconfig.attlist">
      <interleave>
        <ref name="k.vagrantconfig.provider.attribute"/>
        <ref name="k.vagrantconfig.virtualsize.attribute"/>
        <optional>
          <ref name="k.vagrantconfig.boxname.attribute"/>
        </optional>
        <optional>
          <ref name="k.vagrantconfig.virtualbox_guest_additions_present.attribute"/>
        </optional>
        <optional>
          <ref name="k.vagrantconfig.embedded_vagrantfile.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.vagrantconfig">
      <element name="vagrantconfig">
        <a:documentation>The vagrantconfig element specifies the Vagrant meta
configuration options which are used inside a vagrant box</a:documentation>
        <ref name="k.vagrantconfig.attlist"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <installmedia>
    
  -->
  <div>
    <sch:pattern id="installation_media">
      <sch:rule context="installmedia">
        <sch:assert test="../@installiso='true' or ../@installpxe='true'">installmedia is only available for the oem type with 'installiso' or 'installpxe' set to 'true'</sch:assert>
      </sch:rule>
    </sch:pattern>
    <define name="k.installmedia.attlist">
      <empty/>
    </define>
    <define name="k.installmedia">
      <element name="installmedia">
        <a:documentation>The installmedia element defined the configuration parameters
for the installation media of OEM images.</a:documentation>
        <interleave>
          <ref name="k.installmedia.attlist"/>
          <zeroOrMore>
            <ref name="k.initrd"/>
          </zeroOrMore>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <initrd>
    
  -->
  <div>
    <define name="k.initrd.action.attribute">
      <attribute name="action">
        <a:documentation>Sets weather the dracut modules list are meant to be appended,
omitted or they define the static list of modules for the
installation initrd.</a:documentation>
        <choice>
          <value>omit</value>
          <value>add</value>
          <value>set</value>
        </choice>
      </attribute>
    </define>
    <define name="k.initrd.attlist">
      <ref name="k.initrd.action.attribute"/>
    </define>
    <define name="k.initrd">
      <element name="initrd">
        <a:documentation>The initrd element defines the dracut modules configuration
for the installation media.</a:documentation>
        <interleave>
          <ref name="k.initrd.attlist"/>
          <zeroOrMore>
            <ref name="k.dracut"/>
          </zeroOrMore>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <dracut>
    
  -->
  <div>
    <define name="k.dracut.module.attribute">
      <attribute name="module">
        <a:documentation>A module name</a:documentation>
      </attribute>
    </define>
    <define name="k.dracut.attlist">
      <ref name="k.dracut.module.attribute"/>
    </define>
    <define name="k.dracut">
      <element name="dracut">
        <a:documentation>A dracut module</a:documentation>
        <ref name="k.dracut.attlist"/>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <machine>
    
  -->
  <div>
    <define name="k.machine.ovftype.attribute">
      <attribute name="ovftype">
        <a:documentation>The OVF configuration type.
The Open Virtualization Format is a standard for describing
virtual appliances and distribute them in an archive also
called Open Virtual Appliance(OVA). The standard describes
major components associated with a disk image. The exact
specification depends on the product using the format
and is specified in KIWI as the OVF type.</a:documentation>
        <choice>
          <value>zvm</value>
          <value>powervm</value>
          <value>xen</value>
          <value>vmware</value>
        </choice>
      </attribute>
    </define>
    <define name="k.machine.HWversion.attribute">
      <attribute name="HWversion">
        <a:documentation>The virtual HW version number for the VM configuration
(vmdk and ova)</a:documentation>
        <data type="integer"/>
      </attribute>
    </define>
    <define name="k.machine.arch.attribute">
      <attribute name="arch">
        <a:documentation>the VM architecture type (vmdk only)</a:documentation>
        <choice>
          <value>ix86</value>
          <value>x86_64</value>
        </choice>
      </attribute>
    </define>
    <define name="k.machine.xen_loader.attribute">
      <attribute name="xen_loader">
        <a:documentation>the Xen target loader which is expected to load this guest</a:documentation>
        <choice>
          <value>hvmloader</value>
          <value>pygrub</value>
          <value>pvgrub</value>
        </choice>
      </attribute>
    </define>
    <define name="k.machine.guestOS.attribute">
      <attribute name="guestOS">
        <a:documentation>The virtual guestOS identification string for the VM
(vmdk and ova, note the name designation is different for the two
formats)</a:documentation>
      </attribute>
    </define>
    <define name="k.machine.min_memory.attribute">
      <attribute name="min_memory">
        <a:documentation>The virtual machine min memory in MB (ova only)</a:documentation>
        <data type="nonNegativeInteger"/>
      </attribute>
    </define>
    <define name="k.machine.max_memory.attribute">
      <attribute name="max_memory">
        <a:documentation>The virtual machine max memory in MB (ova only)</a:documentation>
        <data type="nonNegativeInteger"/>
      </attribute>
    </define>
    <define name="k.machine.min_cpu.attribute">
      <attribute name="min_cpu">
        <a:documentation>The virtual machine min CPU count (ova only)</a:documentation>
        <data type="nonNegativeInteger"/>
      </attribute>
    </define>
    <define name="k.machine.max_cpu.attribute">
      <attribute name="max_cpu">
        <a:documentation>The virtual machine max CPU count (ova only)</a:documentation>
        <data type="nonNegativeInteger"/>
      </attribute>
    </define>
    <define name="k.machine.memory.attribute">
      <attribute name="memory">
        <a:documentation>The memory, in MB, setup for the guest VM (all formats)</a:documentation>
        <data type="nonNegativeInteger"/>
      </attribute>
    </define>
    <define name="k.machine.ncpus.attribute">
      <attribute name="ncpus">
        <a:documentation>The number of virtual cpus for the guest VM (all formats)</a:documentation>
        <data type="nonNegativeInteger"/>
      </attribute>
    </define>
    <define name="k.machine.attlist">
      <interleave>
        <optional>
          <ref name="k.machine.min_memory.attribute"/>
        </optional>
        <optional>
          <ref name="k.machine.max_memory.attribute"/>
        </optional>
        <optional>
          <ref name="k.machine.min_cpu.attribute"/>
        </optional>
        <optional>
          <ref name="k.machine.max_cpu.attribute"/>
        </optional>
        <optional>
          <ref name="k.machine.ovftype.attribute"/>
        </optional>
        <optional>
          <ref name="k.machine.HWversion.attribute"/>
        </optional>
        <optional>
          <ref name="k.machine.arch.attribute"/>
        </optional>
        <optional>
          <ref name="k.machine.xen_loader.attribute"/>
        </optional>
        <optional>
          <ref name="k.machine.guestOS.attribute"/>
        </optional>
        <optional>
          <ref name="k.machine.memory.attribute"/>
        </optional>
        <optional>
          <ref name="k.machine.ncpus.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.machine">
      <element name="machine">
        <a:documentation>The machine element specifies VM guest configuration
options which are used by the virtual machine when
running the image.</a:documentation>
        <interleave>
          <ref name="k.machine.attlist"/>
          <zeroOrMore>
            <ref name="k.vmconfig-entry"/>
          </zeroOrMore>
          <optional>
            <ref name="k.vmdisk"/>
          </optional>
          <optional>
            <ref name="k.vmdvd"/>
          </optional>
          <zeroOrMore>
            <ref name="k.vmnic"/>
          </zeroOrMore>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <packages>
    
  -->
  <div>
    <sch:pattern abstract="true" id="packages_type">
      <sch:rule context="packages[@$attr]">
        <sch:assert test="contains('$types', @type)">$attr attribute is only available for the following packages type(s): $types</sch:assert>
      </sch:rule>
    </sch:pattern>
    <define name="k.packages.type.attribute">
      <attribute name="type">
        <a:documentation>Specifies package collection type. `bootstrap` packages
gets installed in the very first phase of an image build
in order to fill the empty root directory with bootstrap
data. `image` packages are installed after the bootstrap
phase as chroot operation. `delete` packages are uninstalled
after the preparation phase is done. `image_type_name`
packages are only installed if this build type is requested.</a:documentation>
        <choice>
          <value>bootstrap</value>
          <value>delete</value>
          <value>docker</value>
          <value>image</value>
          <value>iso</value>
          <value>oem</value>
          <value>pxe</value>
          <value>kis</value>
          <value>oci</value>
          <value>uninstall</value>
        </choice>
      </attribute>
    </define>
    <define name="k.packages.profiles.attribute">
      <ref name="k.profiles.attribute"/>
    </define>
    <define name="k.packages.patternType.attribute">
      <attribute name="patternType">
        <a:documentation>Selection type for patterns. Can be onlyRequired
or plusRecommended</a:documentation>
        <choice>
          <value>onlyRequired</value>
          <value>plusRecommended</value>
        </choice>
      </attribute>
    </define>
    <define name="k.packages.bootstrap_package.attribute">
      <attribute name="bootstrap_package">
        <a:documentation>Specify bootstrap package providing a bootstrap tarball
in /var/cache/kiwi/bootstrap/PACKAGE_NAME.ARCH.tar.xz
The tarball will be unpacked and used as the bootstrap
rootfs to begin with. The feature is currently only
available with the apt package manager to allow an
alternative bootstrap method</a:documentation>
      </attribute>
      <sch:pattern id="bootstrap_package" is-a="packages_type">
        <sch:param name="attr" value="bootstrap_package"/>
        <sch:param name="types" value="bootstrap"/>
      </sch:pattern>
    </define>
    <sch:pattern id="bootstrap_package_validation">
      <sch:rule context="packages">
        <sch:assert test="../preferences/packagemanager[text()='apt'] or not(@bootstrap_package)">bootstrap_package attribute only available for the apt packagemanager</sch:assert>
      </sch:rule>
    </sch:pattern>
    <define name="k.packages.attlist">
      <interleave>
        <ref name="k.packages.type.attribute"/>
        <optional>
          <ref name="k.packages.profiles.attribute"/>
        </optional>
        <optional>
          <ref name="k.packages.patternType.attribute"/>
        </optional>
        <optional>
          <ref name="k.packages.bootstrap_package.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.packages">
      <element name="packages">
        <a:documentation>Specifies Packages/Patterns Used in Different Stages</a:documentation>
        <interleave>
          <ref name="k.packages.attlist"/>
          <zeroOrMore>
            <ref name="k.archive"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="k.file"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="k.ignore"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="k.namedCollection"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="k.collectionModule"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="k.product"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="k.package"/>
          </zeroOrMore>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <preferences>
    
  -->
  <div>
    <define name="k.preferences.profiles.attribute">
      <ref name="k.profiles.attribute"/>
    </define>
    <define name="k.preferences.arch.attribute">
      <ref name="k.arch.attribute"/>
    </define>
    <define name="k.preferences.attlist">
      <interleave>
        <optional>
          <ref name="k.preferences.profiles.attribute"/>
        </optional>
        <optional>
          <ref name="k.preferences.arch.attribute"/>
        </optional>
      </interleave>
    </define>
    <define name="k.preferences">
      <element name="preferences">
        <a:documentation>Configuration Information Needed for Logical Extend
All elements are optional since the combination of appropriate
preference sections based on profiles combine to create on vaild
definition</a:documentation>
        <interleave>
          <ref name="k.preferences.attlist"/>
          <optional>
            <ref name="k.bootsplash-theme"/>
          </optional>
          <optional>
            <ref name="k.bootloader-theme"/>
          </optional>
          <optional>
            <ref name="k.keytable"/>
          </optional>
          <optional>
            <ref name="k.locale"/>
          </optional>
          <optional>
            <ref name="k.packagemanager"/>
          </optional>
          <optional>
            <ref name="k.release-version"/>
          </optional>
          <optional>
            <ref name="k.rpm-locale-filtering"/>
          </optional>
          <optional>
            <ref name="k.rpm-check-signatures"/>
          </optional>
          <optional>
            <ref name="k.rpm-excludedocs"/>
          </optional>
          <zeroOrMore>
            <ref name="k.showlicense"/>
          </zeroOrMore>
          <optional>
            <ref name="k.timezone"/>
          </optional>
          <zeroOrMore>
            <ref name="k.type"/>
          </zeroOrMore>
          <optional>
            <ref name="k.version"/>
          </optional>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <profiles>
    
  -->
  <div>
    <define name="k.profiles.attlist">
      <empty/>
    </define>
    <define name="k.profiles">
      <element name="profiles">
        <a:documentation>Namespace section which creates a namespace and the
drivers can bind itself to one of the listed namespaces.</a:documentation>
        <interleave>
          <ref name="k.profiles.attlist"/>
          <oneOrMore>
            <ref name="k.profile"/>
          </oneOrMore>
        </interleave>
      </element>
    </define>
  </div>
  <!--
    ==========================================
    main block: <users>
    
  -->
  <div>
    <define name="k.users.profiles.attribute">
      <ref name="k.profiles.attribute"/>
    </define>
    <define name="k.users.attlist">
      <optional>
        <ref name="k.users.profiles.attribute"/>
      </optional>
    </define>
    <define name="k.users">
      <element name="users">
        <a:documentation>A List of Users</a:documentation>
        <interleave>
          <ref name="k.users.attlist"/>
          <oneOrMore>
            <ref name="k.user"/>
          </oneOrMore>
        </interleave>
      </element>
    </define>
  </div>
</grammar>
<!-- vim: set noexpandtab: -->
