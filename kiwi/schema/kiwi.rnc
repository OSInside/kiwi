#================
# FILE          : kiwi.rnc
#****************
# PROJECT       : KIWI - Appliance Builder
# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH, Germany
#               :
# AUTHOR        : Thomas Schraitle <toms@suse.de>
# AUTHOR        : Marcus Schaefer <ms@suse.de>
#               :
# BELONGS TO    : Operating System images
#               :
# DESCRIPTION   : This is the RELAX NG Schema for KIWI
#               : configuration files. The schema is maintained
#               : in the relax compact syntax. Any changes should
#               : made in !! *** kiwi.rnc *** !!
#               : 
#               :
# STATUS        : Development
#****************
namespace rng = "http://relaxng.org/ns/structure/1.0"
namespace xsi = "http://www.w3.org/2001/XMLSchema-instance"
datatypes xsd = "http://www.w3.org/2001/XMLSchema-datatypes"
namespace db  = "http://docbook.org/ns/docbook"

db:info [
    db:releaseinfo [
        "$Id: $"
    ]
    db:releaseinfo [ "RNC Schema Version 6.4" ]
    db:pubdate [ "START" ]
    db:pubdate [ "2016-03-18" ]
]

image-name = xsd:token {pattern = "[a-zA-Z0-9_\-\.]+"}
locale-name = xsd:token {pattern = "[a-z]{2}_[A-Z]{2}(,[a-z]{2}_[A-Z]{2})*"}
mac-address-type = xsd:token {pattern = "([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}"}
size-type = xsd:token {pattern = "\d*|image"}
volume-size-type = xsd:token {pattern = "\d+|\d+M|\d+G|all"}
vhd-tag-type = xsd:token {pattern = "[0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12}"}
groups-list = xsd:token {pattern = "[a-zA-Z0-9_\-\.]+(,[a-zA-Z0-9_\-\.]+)*"}

#==========================================
# start with image description
#
start =
    ## The start pattern of an image
    k.image

#==========================================
# main block: <image>
#
div {
    k.image.name.attribute = k.imagename.attribute 
    k.image.displayname.attribute = k.displayname.attribute
    k.image.noNamespaceSchemaLocation.attribute =
        ## The location of the XSD Schema (not relevant for RELAX NG or DTD)
        attribute xsi:noNamespaceSchemaLocation { xsd:anyURI }
    k.image.schemaLocation.attribute =
        ## A pair of URI references: First is a namespace name,
        ## second the location of the XSD Schema
        ## (not relevant for RELAX NG or DTD)
        attribute xsi:schemaLocation { xsd:anyURI }
    k.image.schemaversion.attribute =
        ## The allowed Schema version (fixed value)
        attribute schemaversion { "6.4" }
    k.image.kiwirevision.attribute =
        ## A kiwi git revision number which is known to build
        ## a working image from this description. If the kiwi git
        ## revision doesn't match the installed kiwi revision the
        ## process will exit.
        attribute kiwirevision { text }
    k.image.id =
        ## An identification number which is represented in a file
        ## named /etc/ImageID
        attribute id { xsd:string {length="10"} }
    k.image.attlist = k.image.name.attribute 
        & k.image.displayname.attribute?
        & k.image.kiwirevision.attribute?
        & k.image.id?
        & k.image.schemaversion.attribute
        & ( k.image.noNamespaceSchemaLocation.attribute?
            | k.image.schemaLocation.attribute? )?

    k.image =
        ## The root element of the configuration file   
        [
        db:para [
            "Each KIWI configuration file consists of a root element\x{a}" ~
            "image."
        ]
        ]
        element image {
            k.image.attlist &
            k.description &
            k.preferences+ &
            k.profiles? &
            k.instsource? &
            k.users* &
            k.drivers* &
            k.strip* &
            k.repository* &
            k.packages*
        }
}

#==========================================
# common attributes
#
k.id.attribute          =
    ## An ID
    attribute id { xsd:ID }
k.name.attribute        =
    ## A name
    attribute name { text }
k.replaces.attribute    =
    ## Replace package with some other package
    attribute replaces { text }
k.bootinclude.attribute =
    ## Indicates that this package should be part of
    ## the boot image (initrd) too. This attribute
    ## can be used to include for example branding packages
    ## specified in the system image description to become
    ## part of the boot image also
    attribute bootinclude { xsd:boolean }
k.bootdelete.attribute =
    ## Indicates that this package should be removed from
    ## the boot image (initrd). the attribute is only
    ## evaluated if the bootinclude attribute is specified
    ## along with it too
    attribute bootdelete { xsd:boolean }
k.displayname.attribute =
    ## A friendly display name. Used in the boot menu
    ## for isolinux and grub
    attribute displayname { text }
k.arch.attribute        =
    ## An architecture
    attribute arch { text }
k.description.attribute =
    ## A short description
    attribute description { text }
k.path.attribute        =
    ## A path
    attribute path { text }
k.profiles.attribute    =
    ## A profile name which binds the section to this name
    attribute profiles { text }
k.password.attribute    =
    ## The password
    attribute password { text }
k.script.attribute      =
    ## A script hook for meta files to be called after the
    ## file was fetched
    attribute script { text }
k.source.attribute      =
    ## A location where packages can be found to build an
    ## installation source from
    attribute source { text }
k.size.attribute        =
    ## A partition size or optional image size
    attribute size { size-type }
k.dest.attribute        =
    ## Destination of a resource
    attribute dest { text }
k.username.attribute    =
    ## A name of a user
    attribute username { text }
k.imagename.attribute   =
    ## An image name without / and spaces
    attribute name { image-name }

#==========================================
# common element <archive>
#
div {
    k.archive.name.attribute = k.name.attribute
    k.archive.bootinclude.attribute = k.bootinclude.attribute
    k.archive.attlist =
        k.archive.name.attribute &
        k.archive.bootinclude.attribute?
    k.archive =
        ## Name of an image archive file (tarball)
        element archive {
            k.archive.attlist,
            empty
        }
}

#==========================================
# common element <author>
#
div {
    k.author.attlist = empty
    k.author =
        ## Author of the image
        element author { k.author.attlist, text }
}

#==========================================
# common element <bootloader-theme>
#
div {
    k.bootloader-theme.attlist = empty
    k.bootloader-theme =
        ## Image bootloader theme setup.
        [
        db:para [
            "The value will be used in KIWIConfig.sh::suseGFXBoot"
        ]
        ]
        element bootloader-theme {
            k.bootloader-theme.attlist,
            text
        }
}

#==========================================
# common element <bootsplash-theme>
#
div {
    k.bootsplash-theme.attlist = empty
    k.bootsplash-theme =
        ## Image bootsplash theme setup.
        [
        db:para [
            "The value will be used in KIWIConfig.sh::suseGFXBoot"
        ]
        ]
        element bootsplash-theme {
            k.bootsplash-theme.attlist,
            text
        }
}

#==========================================
# common element <configuration>
#
div {
    k.configuration.source.attribute = k.source.attribute
    k.configuration.dest.attribute = k.dest.attribute
    k.configuration.arch.attribute = k.arch.attribute
    k.configuration.attlist = 
        k.configuration.source.attribute &
        k.configuration.dest.attribute &
        k.configuration.arch.attribute?

    k.configuration =
        ## Specifies Configuration files
        [
        db:para [
            "As part of the network deploy configuration this section\x{a}" ~
            "specifies the configuration files which should be included\x{a}"~
            "into the image after deployment."
        ]
        ]
        element configuration {
            k.configuration.attlist,
            empty
        }
}

#==========================================
# common element <contact>
#
div {
    k.contact.attlist = empty
    k.contact = 
        ## Contact Information from the Author, like Email etc.
        element contact {
            k.contact.attlist,
            text
        }
}

#==========================================
# common element <defaultdestination>
#
div {
    k.defaultdestination.attlist = empty
    k.defaultdestination =
        ## Default Path if destdir Otion is Not Specified
        element defaultdestination {
            k.defaultdestination.attlist,
            text
        }
}

#==========================================
# common element <defaultprebuilt>
#
div {
    k.defaultprebuilt.attlist = empty
    k.defaultprebuilt =
        ## Default directory name for pre-built boot images, used if
        ## the directory is not specified on the command line
        element defaultprebuilt {
            k.defaultroot.attlist,
            text
        }
}

#==========================================
# common element <defaultroot>
#
div {
    k.defaultroot.attlist = empty
    k.defaultroot =
        ## Default Root Directory Name if root Option is Not Specified
        element defaultroot {
            k.defaultroot.attlist,
            text
        }
}

#==========================================
# common element <file>
#
div {
    k.file.name.attribute = k.name.attribute
    k.file.arch.attribute = k.arch.attribute
    k.file.attlist =
        k.file.name.attribute &
        k.file.arch.attribute?
    k.file =
        ## A Pointer to a File
        element file {
            k.file.attlist,
            empty
        }
}

#==========================================
# common element <hwclock>
#
div {
    k.hwclock.content = "utc" | "localtime"
    k.hwclock.attlist = empty
    k.hwclock =
        ## Setup Image harware clock setup, either utc or localtime
        [
        db:para [
            "Image hardware clock setup. The value can be either\x{a}"~
            "set to utc or localtime."
        ]
        ]
        element hwclock {
            k.hwclock.attlist,
            k.hwclock.content
        }
}

#==========================================
# common element <ignore>
#
div {
    k.ignore.name.attribute = k.name.attribute
    k.ignore.attlist = k.ignore.name.attribute
    k.ignore = 
        ## Ignores a Package
        element ignore {
            k.ignore.attlist,
            empty
        }
}

#==========================================
# common element <initrd>
#
div {
    k.initrd.attlist = empty
    k.initrd =
        ## Specifies where the Boot Image can be Found
        [
        db:para [
            "As part of the network deploy configuration this element\x{a}"~
            "specifies where the boot image (initrd) can be found."
        ]
        ]
        element initrd {
            k.initrd.attlist,
            text
        }
}

#==========================================
# common element <instrepo>
#
div {
    k.instrepo.local.attribute =
        attribute local { xsd:boolean }
    k.instrepo.name.attribute = 
        attribute name { xsd:ID }
    k.instrepo.password.attribute = k.password.attribute
    k.instrepo.priority.attribute =
        ## Search priority for packages in this repo
        attribute priority { text }
    k.instrepo.username.attribute = k.username.attribute
    k.instrepo.attlist =
        k.instrepo.local.attribute? &
        k.instrepo.name.attribute &
        k.instrepo.password.attribute? &
        k.instrepo.priority.attribute &
        k.instrepo.username.attribute?
    k.instrepo =
        ## Name of a Installation Repository
        [
        db:para [
            "Name of a repository which is used to create an\x{a}" ~
            "installation source\x{a}"~
            "The Priority specifies the order the repositories are\x{a}"~
            "layered when looking for a package.\x{a}"~
            "Username and password are the credentials for ftp access.\x{a}"~
            "The local attribute tells kiwi to use hardlinks instead of\x{a}"~
            "downloads in case the source and destination trees are on\x{a}"~
            "the same machine."
        ]
        ]
        element instrepo {
            k.instrepo.attlist,
            k.source
        }
}

#==========================================
# common element <kernel>
#
div {
    k.kernel.attlist = empty
    k.kernel =
        ## Specifies Where to Find the Boot Kernel
        [
        db:para [
            "As part of the network deploy configuration this section\x{a}" ~
            "specifies the where to find the boot kernel."
        ]
        ]
        element kernel {
            k.kernel.attlist,
            text
        }
}

#==========================================
# common element <keytable>
#
div {
    k.keytable.attlist = empty
    k.keytable =
        ## Image keytable setup.
        [
        db:para [
            "The value will be part of /etc/sysconfig/keyboard"
        ]
        ]
        element keytable {
            k.keytable.attlist,
            text
        }
}

#==========================================
# common element <locale>
#
div { # locale
    k.locale.attlist = empty
    k.locale =
        ## Image locale setup.
        [
        db:para [
            "The value will be part of /etc/sysconfig/keyboard"
        ]
        ]
        element locale {
            k.locale.attlist,
            locale-name
        }
}

#==========================================
# common element <metadata>
#
div {
    k.metadata.attlist = empty
    k.metadata =
        ## Contains Metadata
        [
        db:para [
            "When building an installation source not only packages are\x{a}" ~
            "relevant but also metadata. metadata are files or packages\x{a}"~
            "combined with script calls. If a package is specified as\x{a}"~
            "metadata it will not be installed by rpm but its cpio\x{a}"~
            "archive is extracted in a specific way."       
        ]
        ]
        element metadata {
            k.metadata.attlist &
            k.repopackage* &
            k.metafile* &
            k.chroot*
        }
}

#==========================================
# common element <metafile>
#
div {
    k.metafile.url.attribute =
        ## URL where to find the metafile
        attribute url { text }
    k.metafile.script.attribute = k.script.attribute
    k.metafile.target.attribute =
        ## Destination path where to download the file
        attribute target { text }
    k.metafile.attlist =
        k.metafile.url.attribute &
        k.metafile.script.attribute &
        k.metafile.target.attribute
    k.metafile =
        ## A file Pointer Optionally Bundled With a Script
        element metafile {
            k.metafile.attlist,
            empty
        }
}

#==========================================
# common element <namedCollection>
#
div {
    k.namedCollection.name.attribute = k.name.attribute
    k.namedCollection.arch.attribute = k.arch.attribute
    k.namedCollection.attlist =
        k.namedCollection.name.attribute &
        k.namedCollection.arch.attribute?
    k.namedCollection =
        ## Name of a Pattern for SUSE or a Group for RH
        element namedCollection {
            k.namedCollection.attlist,
            empty
        }
}

#==========================================
# common element <oem-boot-title>
#
div {
    k.oem-boot-title.attlist = empty
    k.oem-boot-title =
        ## For oemboot driven images: setup of the boot menu text
        ## displayed within the square brackets after first reboot
        ## of the OEM image
        [
        db:para [
            "For oemboot driven images: setup of the boot menu text\x{a}"~
            "displayed within the square brackets after first reboot\x{a}"~
            "of the OEM image."
        ]
        ]
        element oem-boot-title {
            k.oem-boot-title.attlist,
            text
        }
}

#==========================================
# common element <oem-bootwait>
#
div {
    k.oem-bootwait.content = xsd:boolean
    k.oem-bootwait.attlist = empty
    k.oem-bootwait =
        ## For oemboot driven images: halt system after image dump true/false
        [
        db:para [
            "For oemboot driven images: wait for user acknowledgement "~
            "after first deployment true/false. A message to be "~
            "acknowledged by the user is posted after the image has been "~
            "dumped (installed) on the target disk. After user interaction "~
            "the system reboots (softboot)."
        ]
        ]
        element oem-bootwait {
            k.oem-bootwait.attlist,
            k.oem-bootwait.content
        }
}

#==========================================
# common element <oem-device-filter>
#
div {
    k.oem-device-filter.content = text
    k.oem-device-filter.attlist = empty
    k.oem-device-filter =
        ## For oemboot driven images: filter install devices by given
        ## regular expression. The expression is handled by the bash regexp
        ## operator
        [
        db:para [
            "For oemboot driven images: filter install devices by given"~
            "regular expression. The expression is handled by the bash"~
            "regexp operator"
        ]
        ]
        element oem-device-filter {
            k.oem-device-filter.attlist,
            k.oem-device-filter.content
        }
}

#==========================================
# common element <oem-inplace-recovery>
#
div {
    k.oem-inplace-recovery.content = xsd:boolean
    k.oem-inplace-recovery.attlist = empty
    k.oem-inplace-recovery =
        ## For oemboot driven images: Specify whether the
        ## recovery archive should be stored as part of the image
        ## or not. If it's not stored it's created during install
        ## of the oem image
        [
        db:para [
            "For oemboot driven images: Specify whether the\x{a}"~
            "recovery archive should be stored as part of the image\x{a}"~
            "or not. If it's not stored it's created during install\x{a}"~
            "of the oem image"
        ]
        ]
        element oem-inplace-recovery {
            k.oem-inplace-recovery.attlist,
            k.oem-inplace-recovery.content
        }
}

#==========================================
# common element <oem-kiwi-initrd>
#
div {
    k.oem-kiwi-initrd.content = xsd:boolean
    k.oem-kiwi-initrd.attlist = empty
    k.oem-kiwi-initrd =
        ## For oemboot driven images: use kiwi initrd in any case
        ## and don't replace it with mkinitrd created initrd
        [
        db:para [
            "For oemboot driven images: use kiwi initrd in any case\x{a}"~
            "and don't replace it with mkinitrd created initrd"
        ]
        ]
        element oem-kiwi-initrd {
            k.oem-kiwi-initrd.attlist,
            k.oem-kiwi-initrd.content
        }
}

#==========================================
# common element <oem-partition-install>
#
div {
    k.oem-partition-install.content = xsd:boolean
    k.oem-partition-install.attlist = empty
    k.oem-partition-install =
        ## For oemboot driven images: install the system not as
        ## disk but into a free partition. If this option is set
        ## all other oem-* options concerning the partition table
        ## will not have any effect
        [
        db:para [
            "For oemboot driven images: install the system not as\x{a}"~
            "disk but into a free partition. If this option is set\x{a}"~
            "all other oem-* options concerning the partition table\x{a}"~
            "will not have any effect"
        ]
        ]
        element oem-partition-install {
            k.oem-partition-install.attlist,
            k.oem-partition-install.content
        }
}

#==========================================
# common element <oem-reboot>
#
div {
    k.oem-reboot.content = xsd:boolean
    k.oem-reboot.attlist = empty
    k.oem-reboot =
        ## For oemboot driven images: reboot after first deployment true/false
        [
        db:para [
            "For oemboot driven images: reboot after first deployment "~
            "true/false. The system is rebooted in similar fashion to "~
            "shutdown -r after the image has been dumped (installed) "~
            "and expanded on the target disk."
        ]
        ]
        element oem-reboot {
            k.oem-reboot.attlist,
            k.oem-reboot.content
        }
}

#==========================================
# common element <oem-reboot-interactive>
#
div {
    k.oem-reboot-interactive.content = xsd:boolean
    k.oem-reboot-interactive.attlist = empty
    k.oem-reboot-interactive =
        ## For oemboot driven images: reboot after first deployment true/false
        [
        db:para [
            "For oemboot driven images: reboot after first deployment "~
            "true/false. A message to be acknowledged by the user is "~
            "posted after the image has been dumped (installed) and "~
            "expanded on the target disk. After user interaction the "~
            "system is rebooted in similar fashion to shutdown -r."
        ]
        ]
        element oem-reboot-interactive {
            k.oem-reboot-interactive.attlist,
            k.oem-reboot-interactive.content
        }
}

#==========================================
# common element <oem-recovery>
#
div {
    k.oem-recovery.content = xsd:boolean
    k.oem-recovery.attlist = empty
    k.oem-recovery =
        ## For oemboot driven images: create a recovery archive yes/no
        [
        db:para [
            "For oemboot driven images: create a recovery archive yes/no"
        ]
        ]
        element oem-recovery {
            k.oem-recovery.attlist,
            k.oem-recovery.content
        }
}

#==========================================
# common element <oem-recoveryID>
#
div {
    k.oem-recoveryID.attlist = empty
    k.oem-recoveryID =
        ## For oemboot driven images: Set the partition ID of
        ## recovery partition. Default value is 83 (Linux)
        [
        db:para [
            "For oemboot driven images: Set the partition ID of\x{a}"~
            "recovery partition. Default value is 83 (Linux)"
        ]
        ]
        element oem-recoveryID {
            k.oem-recoveryID.attlist,
            xsd:nonNegativeInteger
        }
}

#==========================================
# common element <oem-recovery-part-size>
#
div {
    k.oem-recovery-part-size.attlist = empty
    k.oem-recovery-part-size =
        ## For oemboot driven images: Set the size of the
        ## recovery partition. Value is interpreted as MB
        [
        db:para [
            "For oemboot driven images: Set the size of\x{a}"~
            "the recovery partition in MBytes."
        ]
        ]
        element oem-recovery-part-size {
            k.oem-recovery-part-size.attlist,
            xsd:nonNegativeInteger
        }
}

#==========================================
# common element <oem-shutdown>
#
div {
    k.oem-shutdown.content = xsd:boolean
    k.oem-shutdown.attlist = empty
    k.oem-shutdown =
        ## For oemboot driven images: shutdown after first deployment 
        ## true/false
        [
        db:para [
            "For oemboot driven images: shutdown after first deployment "~
            "true/false. The system is powered down after the image has "~
            "been dumped (installed) and expanded on the target disk. "
        ]
        ]
        element oem-shutdown {
            k.oem-shutdown.attlist,
            k.oem-shutdown.content
        }
}

#==========================================
# common element <oem-shutdown-interactive>
#
div {
    k.oem-shutdown-interactive.content = xsd:boolean
    k.oem-shutdown-interactive.attlist = empty
    k.oem-shutdown-interactive =
        ## For oemboot driven images: shutdown after first deployment 
        ## true/false
        [
        db:para [
            "For oemboot driven images: shutdown after first deployment "~
            "true/false. A message to be acknowledged by the user is posted "~
            "after the image has been dumped (installed) and expanded on "~
            "the target disk. After user interaction the system is shutdown."
        ]
        ]
        element oem-shutdown-interactive {
            k.oem-shutdown-interactive.attlist,
            k.oem-shutdown-interactive.content
        }
}

#==========================================
# common element <oem-silent-boot>
#
div {
    k.oem-silent-boot.content = xsd:boolean
    k.oem-silent-boot.attlist = empty
    k.oem-silent-boot =
        ## For oemboot driven images: boot silently during the initial boot
        ## true/false
        [
        db:para [
            "For oemboot driven images: complete the initial boot of the "~
            "system in silent mode, true/false. "
        ]
        ]
        element oem-silent-boot {
            k.oem-silent-boot.attlist,
            k.oem-silent-boot.content
        }
}

#==========================================
# common element <oem-silent-install>
#
div {
    k.oem-silent-install.content = xsd:boolean
    k.oem-silent-install.attlist = empty
    k.oem-silent-install =
        ## For oemboot driven images: do not show progress of the image
                ## dump process, true/false
        [
        db:para [
            "For oemboot driven images: do not show progress of the image "~
                        "dump process, true/false (default is false.) "
        ]
        ]
        element oem-silent-install {
                        k.oem-silent-install.attlist,
            k.oem-silent-install.content
        }
}

#==========================================
# common element <oem-skip-verify>
#
div {
    k.oem-skip-verify.content = xsd:boolean
    k.oem-skip-verify.attlist = empty
    k.oem-skip-verify =
        ## For oemboot driven images: do not perform the md5
        ## verification process, true/false
        [
        db:para [
            "For oemboot driven images: do not perform the md5 "~
            "verification process, true/false (default is false.) "
        ]
        ]
        element oem-skip-verify {
            k.oem-skip-verify.attlist,
            k.oem-skip-verify.content
        }
}

#==========================================
# common element <oem-ataraid-scan>
#
div {
    k.oem-ataraid-scan.content = xsd:boolean
    k.oem-ataraid-scan.attlist = empty
    k.oem-ataraid-scan =
        ## For oemboot driven images: turn on or off the search
        ## for ata raid devices (aka fake raid controllers)
        ## true/false (default is true)
        [
        db:para [
            "For oemboot driven images: turn on or off the search "~
            "for ata raid devices (aka fake raid controllers) "
            "true/false (default is true) "
        ]
        ]
        element oem-ataraid-scan {
            k.oem-ataraid-scan.attlist,
            k.oem-ataraid-scan.content
        }
}

#==========================================
# common element <oem-vmcp-parmfile>
#
div {
    k.oem-vmcp-parmfile.content = text
    k.oem-vmcp-parmfile.attlist = empty
    k.oem-vmcp-parmfile =
        ## For oemboot driven images: provide the name of a parmfile
        ## which is loaded via cmsfscat on s390 systems. Default value
        ## is set to: PARM-S11
        [
        db:para [
            "For oemboot driven images: provide the name of a parmfile "~
            "which is loaded via cmsfscat on s390 systems. Default value "~
            "is set to: PARM-S11"
        ]
        ]
        element oem-vmcp-parmfile {
            k.oem-vmcp-parmfile.attlist,
            k.oem-vmcp-parmfile.content
        }
}

#==========================================
# common element <oem-multipath-scan>
#
div {
    k.oem-multipath-scan.content = xsd:boolean
    k.oem-multipath-scan.attlist = empty
    k.oem-multipath-scan =
        ## For oemboot driven images: turn on or off the search
        ## for multipath devices: true/false (default is true)
        [
        db:para [
            "For oemboot driven images: turn on or off the search "~
            "for multipath devices: true/false (default is true) "
        ]
        ]
        element oem-multipath-scan {
            k.oem-multipath-scan.attlist,
            k.oem-multipath-scan.content
        }
}

#==========================================
# common element <oem-silent-verify>
#
div {
    k.oem-silent-verify.content = xsd:boolean
    k.oem-silent-verify.attlist = empty
    k.oem-silent-verify =
        ## For oemboot driven images: do not show progress of the image
                ## verification process, true/false
        [
        db:para [
            "For oemboot driven images: do not show progress of the image "~
                        "verification process, true/false (default is false.) "
        ]
        ]
        element oem-silent-verify {
                        k.oem-silent-verify.attlist,
            k.oem-silent-verify.content
        }
}

#==========================================
# common element <oem-swap>
#
div {
    k.oem-swap.content = xsd:boolean
    k.oem-swap.attlist = empty
    k.oem-swap =
        ## For oemboot driven images: use a swap partition yes/no
        [
        db:para [
            "For oemboot driven images: use a swap partition yes/no."
        ]
        ]
        element oem-swap {
            k.oem-swap.attlist,
            k.oem-swap.content
        }
}

#==========================================
# common element <oem-swapsize>
#
div {
    k.oem-swapsize.attlist = empty
    k.oem-swapsize =
        ## For oemboot driven images: Set the size of the swap
        ## partition in MB
        [
        db:para [
            "For oemboot driven images: Set the size of the swap\x{a}"~
            "partition in MB. No swapspace with oem-swap set to false."
        ]
        ]
        element oem-swapsize {
            k.oem-swapsize.attlist,
            xsd:nonNegativeInteger
        }
}

#==========================================
# common element <oem-systemsize>
#
div {
    k.oem-systemsize.attlist = empty
    k.oem-systemsize =
        ## For oemboot driven images: Set the size of the system
        ## (root) partition in MB
        [
        db:para [
            "For oemboot driven images: Set the size of the system\x{a}"~
            "(root) partition in MB."
        ]
        ]
        element oem-systemsize {
            k.oem-systemsize.attlist,
            xsd:nonNegativeInteger
        }
}

#==========================================
# common element <oem-unattended>
#
div {
    k.oem-unattended.content = xsd:boolean
    k.oem-unattended.attlist = empty
    k.oem-unattended =
        ## For oemboot driven images: don't ask questions if possible
        ## true/false
        [
        db:para [
            "For oemboot driven images: don't ask questions if"~
            "possible true/false"
        ]
        ]
        element oem-unattended {
            k.oem-unattended.attlist,
            k.oem-unattended.content
        }
}

#==========================================
# common element <oem-unattended-id>
#
div {
    k.oem-unattended-id.attlist = empty
    k.oem-unattended-id =
        ## For oemboot driven images: use the specified disk id
        ## the device is looked up in /dev/disk/by-* and /dev/mapper/*
        [
        db:para [
            "For oemboot driven images: use the specified disk id"
            "the device is looked up in /dev/disk/by-* and /dev/mapper/*"
        ]
        ]
        element oem-unattended-id {
            k.oem-unattended-id.attlist,
            text
        }
}

#==========================================
# common element <product>
#
div {
    k.product.name.attribute = k.name.attribute
    k.product.arch.attribute = k.arch.attribute
    k.product.attlist =
        k.product.name.attribute &
        k.product.arch.attribute?
    k.product =
        ## Name of a Product From openSUSE
        element product {
            k.product.attlist,
            empty
        }
}

#==========================================
# common element <package>
#
div {
    k.package.name.attribute = k.name.attribute
    k.package.arch.attribute = k.arch.attribute
    k.package.replaces.attribute = k.replaces.attribute
    k.package.bootinclude.attribute = k.bootinclude.attribute
    k.package.bootdelete.attribute = k.bootdelete.attribute
    k.package.attlist =
        k.package.name.attribute &
        k.package.arch.attribute? &
        k.replaces.attribute? &
        k.bootdelete.attribute? &
        k.bootinclude.attribute?
    k.package =
        ## Name of an image Package
        element package {
            k.package.attlist,
            empty
        }
}

#==========================================
# common element <packagemanager>
#
div {
    k.packagemanager.content = 
        "apt-get" | "zypper" | "yum"
    k.packagemanager.attlist = empty
    k.packagemanager =
        ## Name of the Package Manager
        [
        db:para [
            "The package manager used for package installation\x{a}"~
            "could be either zypper or smart"
        ]
        ]
        element packagemanager {
            k.packagemanager.attlist,
            k.packagemanager.content
        }
}

#==========================================
# common element <partitioner>
#
div {
    k.partitioner.content = "parted" | "fdasd"
    k.partitioner.attlist = empty
    k.partitioner =
        ## Name of the Partitioner used for any disk partition tasks
        [
        db:para [
            "The partitioner used for creating disk partitions\x{a}"~
            "could be either parted or fdasd"
        ]
        ]
        element partitioner {
            k.partitioner.attlist,
            k.partitioner.content
        }
}

#==========================================
# common element <partition>
#
div {
    k.partition.type.attribute =
        ## Partition Type identifier, see parted for details
        attribute type { text }
    k.partition.number.attribute =
        ## Partition ID
        attribute number { text }
    k.partition.size.attribute = k.size.attribute
    k.partition.mountpoint.attribute = 
        ## Mount path for this partition
        attribute mountpoint { text }
    k.partition.target.attribute =
        ## Is a real target or not which means is part of
        ## the /etc/fstab file or not
        attribute target { xsd:boolean }
    k.partition.attlist =
        k.partition.type.attribute &
        k.partition.number.attribute & 
        k.partition.size.attribute? &
        k.partition.mountpoint.attribute? &
        k.partition.target.attribute?
    k.partition =
        ## A Partition
        element partition {
            k.partition.attlist,
            empty
        }
}

#==========================================
# common element <partitions>
#
div {
    k.partitions.device.attribute =
        ## As part of the network deploy configuration this section
        ## specifies the disk device name
        attribute device { text }
    k.partitions.attlist = k.partitions.device.attribute?
    k.partitions =
        ## A List of Partitions
        element partitions { 
            k.partitions.attlist, 
            k.partition+
        }
}

#==========================================
# common element <profile>
#
div {
    k.profile.name.attribute = k.name.attribute
    k.profile.description.attribute =
        ## Description of how this profiles influences the image
        attribute description { text }
    k.profile.import.attribute =
        ## Import profile by default if no profile was set on
        ## the command line
        attribute import { xsd:boolean }
    k.profile.attlist =
        k.profile.name.attribute &
        k.profile.description.attribute &
        k.profile.import.attribute?
    k.profile =
        ## Creates Profiles
        [
        db:para [
            "Profiles creates a namespace on an image description and\x{a}"~
            "thus can be used to have one description with different\x{a}"~
            "profiles for example KDE and GNOME including different\x{a}"~
            "packages."
        ]
        ]
        element profile {
            k.profile.attlist,
            empty
        }
}

#==========================================
# common element <repopackage>
#
div {
    k.repopackage.name.attribute = k.name.attribute
    k.repopackage.arch.attribute = k.arch.attribute
    k.repopackage.forcerepo.attribute =
        ## Specifies the search priority
        attribute forcerepo { xsd:IDREF }
    k.repopackage.addarch.attribute =
        ## Specifies that this package should
        ## additionally add the same package from the given arch
        attribute addarch { text }
    k.repopackage.removearch.attribute =
        ## Specifies that the package with the
        ## given arch should be removed
        attribute removearch { text }
    k.repopackage.onlyarch.attribute =
        ## Specifies that the package with
        ## the given arch should be used in any case
        attribute onlyarch { text }
    k.repopackage.medium.attribute =
        ## Specifies that the package will be put
        ## to the specific medium number (CD1, DVD7, ...)
        attribute medium { xsd:nonNegativeInteger }
    k.repopackage.source.attribute = k.source.attribute
    k.repopackage.script.attribute = k.script.attribute
    k.repopackage.attlist =
        k.repopackage.name.attribute & 
        k.repopackage.arch.attribute? &
        k.repopackage.forcerepo.attribute? &
        k.repopackage.addarch.attribute? &
        k.repopackage.removearch.attribute? &
        k.repopackage.onlyarch.attribute? &
        k.repopackage.source.attribute? &
        k.repopackage.script.attribute? &
        k.repopackage.medium.attribute?
    k.repopackage =
        ## Name of an instsource Package
        element repopackage {
            k.repopackage.attlist,
            empty
        }
}

#==========================================
# common element <repository>
#
div {
    k.repository.profiles.attribute = k.profiles.attribute
    k.repository.type.attribute =
        ## Type of repository
        attribute type {
        "apt-deb" | "apt-rpm" | "deb-dir" | "mirrors" | "red-carpet" |
        "rpm-dir" | "rpm-md"  | "slack-site" | "up2date-mirrors" | "urpmi" |
        "yast2"
    }
    k.repository.status.attribute =
        ## Specifies the status of the repository. This can be
        ## replaceable or if not specified it's a must have repository
        attribute status {  "fixed" | "replaceable" }
    k.repository.alias.attribute =
        ## Alias name to be used for this repository. This is an
        ## optional free form text. If not set the source attribute
        ## value is used and builds the alias name by replacing
        ## each '/' with a '_'. An alias name should be set if the
        ## source argument doesn't really explain what this repository
        ## contains
        attribute alias { text }
    k.repository.components.attribute =
        ## Distribution components, used for deb repositories. If
        ## not set it defaults to main
        attribute components { text }
    k.repository.distribution.attribute =
        ## Distribution name information, used for deb repositories
        attribute distribution { text }
    k.repository.imageinclude.attribute =
        ## Specify whether or not this repository should be configured in the
        ## resulting image. Boolean value true or false, the default is false.
        attribute imageinclude { xsd:boolean }
    k.repository.prefer-license.attribute =
        ## Use the license found in this repository, if any, as the
        ## license installed in the image
        attribute prefer-license { xsd:boolean }
    k.repository.priority.attribute =
        ## Channel priority assigned to all packages available in
        ## this channel (0 if not set). If the exact same package
        ## is available in more than one channel, the highest
        ## priority is used
        attribute priority { xsd:integer }
    k.repository.password.attribute =
        ## Channel password if required. It depends on the url type
        ## whether and how this information is passed
        k.password.attribute
    k.repository.username.attribute =
        ## Channel username if required. It depends on the url type
        ## whether and how this information is passed
        k.username.attribute
    k.repository.attlist =
        k.repository.type.attribute? &
        k.repository.profiles.attribute? &
        k.repository.status.attribute? &
        k.repository.alias.attribute? &
        k.repository.components.attribute? &
        k.repository.distribution.attribute? &
        k.repository.imageinclude.attribute? &
        k.repository.prefer-license.attribute? &
        k.repository.priority.attribute? &
        k.repository.password.attribute? &
        k.repository.username.attribute?
    k.repository =
        ## The Name of the Repository
        element repository {
            k.repository.attlist,
            k.source
        }
}

#==========================================
# common element <rpm-check-signatures>
#
div {
    k.rpm-check-signatures.content = xsd:boolean
    k.rpm-check-signatures.attlist = empty
    k.rpm-check-signatures =
        ## Setup a Package Signature
        [
        db:para [
            "Setup if the package manager should check the package\x{a}"~
            "signature or not. This option could be ignored according\x{a}"~
            "to the used package manager."
        ]
        ]
        element rpm-check-signatures {
            k.rpm-check-signatures.attlist,
            k.rpm-check-signatures.content
        }
}

#==========================================
# common element <rpm-excludedocs>
#
div {
    k.rpm-excludedocs.content = xsd:boolean
    k.rpm-excludedocs.attlist = empty
    k.rpm-excludedocs =
        ## Do not install files marked as documentation in the package
        [
        db:para [
            "Setup if the package manager should exclude docs files\x{a}"~
            "during package installation. This option could be ignored\x{a}"~
            "according to the used package manager."
        ]
        ]
        element rpm-excludedocs {
            k.rpm-excludedocs.attlist,
            k.rpm-excludedocs.content
        }
}

#==========================================
# common element <rpm-force>
#
div {
    k.rpm-force.content = xsd:boolean
    k.rpm-force.attlist = empty
    k.rpm-force =
        ## Force the Installation of a Package
        [
        db:para [
        "Setup if the package manager should force the install\x{a}"~
        "of the package or not. This option could be ignored\x{a}"~
        "according to the used package manager."
        ]
        ]
        element rpm-force {
            k.rpm-force.attlist,
            k.rpm-force.content
        }
}

#==========================================
# common element <showlicense>
#
div {
    k.showlicense.attlist = empty
    k.showlicense =
        ## Setup showlicense
        [
        db:para [
            "Image license setup. The specfied license name\x{a}"~
            "will be displayed in a dialog window on boot."
        ]
        ]
        element showlicense {
            k.showlicense.attlist,
            text
        }
}

#==========================================
# common element <size>
#
div {
    k.size.unit.attribute =
        ## The unit of the image
        attribute unit { "M" | "G" }
    k.size.additive.attribute =
        attribute additive { xsd:boolean }
    k.size.attlist =
        k.size.unit.attribute? &
        k.size.additive.attribute?
    k.size =
        ## Specifies the Size of an Image in (M)egabyte or (G)igabyte
        ## If the attribute additive is set the value will be added
        ## to the required size of the image
        element size {
            k.size.attlist,
            xsd:nonNegativeInteger
        }
}

#==========================================
# common element <source>
#
div {
    k.source.path.attribute = k.path.attribute
    k.source.attlist = k.source.path.attribute
    k.source =
        ## A Pointer to a Repository/Package Source
        element source {
            k.source.attlist,
            empty
        }
}

#==========================================
# common element <specification>
#
div {
    k.specification.attlist = empty
    k.specification =
        ## A Detailed Description
        [
        db:para [
            "A detailed description of this image and what it can be\x{a}"~
            "used for."
        ]
        ]
        element specification {
            k.specification.attlist,
            text
        }
}

#==========================================
# common element <systemdisk>
#
div {
    k.systemdisk.name.attribute =
        ## Specify Volume group name, default is kiwiVG. This
        ## information is only used if the LVM volume management
        ## is used
        attribute name { text }
    k.systemdisk.preferlvm.attribute =
        ## Prefer LVM even if the used filesystem has its own
        ## volume management system
        attribute preferlvm { xsd:boolean }
    k.systemdisk.attlist =
        k.systemdisk.name.attribute? &
        k.systemdisk.preferlvm.attribute?
    k.systemdisk =
        ## Specify volumes and size attributes
        [
        db:para [
            "Specify volumes and size attributes"
        ]
        ]
        element systemdisk {
            k.systemdisk.attlist &
            k.volume*
        }
}

#==========================================
# common element <timeout>
#
div {
    k.timeout.attlist = empty
    k.timeout = 
        ## Specifies an ATFTP Download Timeout
        [
        db:para [
            "As part of the network deploy configuration this section\x{a}"~
            "specifies an ATFTP download timeout"
        ]
        ]
        element timeout {
            k.timeout.attlist,
            text
        }
}

#==========================================
# common element <timezone>
#
div {
    k.timezone.attlist = empty
    k.timezone =  
        ## Setup Image Timezone setup
        [
        db:para [
            "Image timezone setup. The value will be used to search\x{a}"~
            "the correct timezone and copy it to /etc/localtime."
        ]
        ]
        element timezone {
            k.timezone.attlist,
            text
        }
}

#==========================================
# common element <type>
#
div {
    k.type.boot.attribute =
        ## Specifies the path of the boot image (initrd), relative
        ## to /usr/share/kiwi/image
        attribute boot { text }
    k.type.bootkernel.attribute =
        ## Specifies the kernel boot profile defined in the boot
        ## image description. When kiwi builds the boot image the
        ## information is passed as add-profile option
        attribute bootkernel { text }
    k.type.bootloader.attribute =
        ## Specifies the bootloader used for booting the image.
        ## At the moment grub, zipl and sys|extlinux are supported
        attribute bootloader {
            "grub2" | "zipl" | "grub2_s390x_emu"
        }
    k.type.bootloader_console.attribute =
        ## Specifies the bootloader console.
        ## The value only has an effect for the grub bootloader.
        ## By default a graphics console setup is used
        attribute bootloader_console {
            "console" | "gfxterm" | "serial"
        }
    k.type.btrfs_root_is_snapshot =
        ## Tell kiwi to install the system into a btrfs snapshot
        ## The snapshot layout is compatible with the snapper management
        ## toolkit. By default no snapshots are used
        attribute btrfs_root_is_snapshot { xsd:boolean }
    k.type.btrfs_root_is_readonly_snapshot =
        ## Tell kiwi to set the btrfs root filesystem snapshot read-only
        ## Once all data has been placed to the root filesystem snapshot
        ## it will be turned into read-only mode if this option is set to
        ## true. The option is only effective if btrfs_root_is_snapshot
        ## is also set to true. By default the root filesystem snapshot
        ## is writable
        attribute btrfs_root_is_readonly_snapshot { xsd:boolean }
    k.type.target_blocksize =
        ## Specifies the image blocksize in bytes which has to match
        ## the logical (SSZ) blocksize of the target storage device.
        ## By default 512 byte is used which works on many disks
        ## However 4096 byte disks are coming. You can check the
        ## desired target by calling: blockdev --report device
        attribute target_blocksize { xsd:nonNegativeInteger }
    k.type.zipl_targettype.attribute =
       ## The device type of the disk zipl should boot. On zFCP
       ## devices use SCSI, on DASD devices use CDL or LDL on
       ## emulated DASD devices use FBA
       attribute zipl_targettype {
           "CDL" | "LDL" | "FBA" | "SCSI"
       }
    k.type.bootpartsize.attribute =
        ## For images with a separate boot partition this attribute
        ## specifies the size in MB. If not set the min bootpart
        ## size is set to 200 MB
        attribute bootpartsize { xsd:nonNegativeInteger }
    k.type.vbootsize.attribute =
        ## For images with a an extra virtual boot space
        ## specifies the size in MB. If not set the min vboot
        ## size is set to 10 MB
        attribute vbootsize { xsd:nonNegativeInteger }
    k.type.bootprofile.attribute =
        ## Specifies the boot profile defined in the boot image
        ## description. When kiwi builds the boot image the
        ## information is passed as add-profile option
        attribute bootprofile { text }
    k.type.boottimeout.attribute =
        ## Specifies the boot timeout in seconds prior to launching
        ## the default boot option. the unit for the timeout value
        ## is seconds if GRUB is used as the boot loader and 1/10
        ## seconds if syslinux is used
        attribute boottimeout { xsd:nonNegativeInteger }
    k.type.checkprebuilt.attribute =
        ## Activates whether KIWI should search for a prebuild boot
        ## image or not
        attribute checkprebuilt { xsd:boolean }
    k.type.compressed.attribute =
        ## Specifies whether the image output file should be
        ## compressed or not. This makes only sense for filesystem
        ## only images respectively for the pxe or cpio type
        attribute compressed { xsd:boolean }
    k.type.container.attribute =
        ## Specifies a name for the container
        attribute container { text }
    k.type.devicepersistency.attribute =
        ## Specifies which method to use in order to get persistent
        ## storage device names. By default by-uuid is used.
        attribute devicepersistency { "by-uuid" | "by-label" | "by-path" }
    k.type.editbootconfig.attribute =
        ## Specifies the path to a script which is called right
        ## before the bootloader is installed. The script runs
        ## relative to the directory which contains the image
        ## structure
        attribute editbootconfig { text }
    k.type.editbootinstall.attribute =
        ## Specifies the path to a script which is called right
        ## after the bootloader is installed. The script runs
        ## relative to the directory which contains the image
        ## structure
        attribute editbootinstall { text }
    k.type.filesystem.attribute = 
        ## Specifies the root filesystem type
        attribute filesystem {
            "btrfs" | "ext2" | "ext3" | "ext4" | "squashfs" | "xfs"
        }
    k.type.overlayroot.attribute =
        ## Specifies to use an overlay root system consisting
        ## out of a squashfs compressed read-only root system
        ## overlayed using the overlayfs filesystem into an
        ## extra read-write partition. Available for the disk
        ## image types, vmx and oem
        attribute overlayroot { xsd:boolean }
    k.type.firmware.attribute =
        ## Specifies the boot firmware of the system. Most systems
        ## uses a standard BIOS but there are also other firmware
        ## systems like efi, coreboot, etc.. This attribute is
        ## used to differentiate the image according to the firmware
        ## which boots up the system. It mostly has an impact on
        ## the disk layout and the partition table type. By default
        ## the standard x86 bios firmware setup is used
        attribute firmware {
            "bios" | "ec2" | "ec2hvm" | "efi" |
            "uefi" | "vboot" | "ofw" | "opal"
        }
    k.type.bootpartition.attribute =
        ## specify if an extra boot partition should be used or not.
        ## This will overwrite kiwi's default layout
        attribute bootpartition { xsd:boolean }
    k.type.bootfilesystem.attribute =
        ## if an extra boot partition is required this attribute
        ## specify which filesystem should be used for it. The
        ## type of the bootloader might overwrite this setting
        ## e.g for the syslinux loader fat is required
        attribute bootfilesystem {
            "ext2" | "ext3" | "ext4" | "fat32" | "fat16"
        }
    k.type.flags.attribute =
        ## Specifies flags for the image type. This could be compressed
        ## or clic and applies to the iso type only
        attribute flags {
            "clic" | "compressed" | "clic_udf" | "overlay" | "seed"
        }
    k.type.format.attribute =
        ## Specifies the format of the virtual disk.
        ## The ec2 value is deprecated and no longer supported
        ## It remains in the schema to allow us to print a better
        ## Error message than we receive from the parser.
        ## To be remove from here by the end of 2014
        attribute format {
            "ec2" | "gce" | "ovf" | "ova" | "qcow2" | "vagrant" | "vmdk" |
            "vdi" | "vhd" | "vhd-fixed"
        }
    k.type.formatoptions.attribute =
        ## Specifies additional format options passed on to qemu-img
        ## formatoptions is a comma separated list of format specific
        ## options in a name=value format like qemu-img expects it.
        ## kiwi will take the information and pass it as parameter to
        ## the -o option in the qemu-img call
        attribute formatoptions { text }
    k.type.fsnocheck.attribute =
        ## Turn off periodic filesystem checks on ext2/3/4.
        attribute fsnocheck { xsd:boolean }
    k.type.fsmountoptions.attribute =
        ## Specifies the filesystem mount options which also ends up in fstab
        ## The string given here is passed as value to the -o option of mount
        attribute fsmountoptions { text }
    k.type.hybrid.attribute =
        ## for the iso type only:
        ## Specifies that the iso file should be turned into
        ## a hybrid iso file. It's required to use the vmxboot
        ## boot image to boot that iso though
        attribute hybrid { xsd:boolean }
    k.type.hybridpersistent.attribute =
        ## for the iso type only:
        ## will trigger the creation of a partition for a COW file
        ## to keep data persistent over a reboot
        attribute hybridpersistent { xsd:boolean }
    k.type.hybridpersistent_filesystem.attribute =
        ## for the iso type only:
        ## Set the filesystem to use for persistent writing if a
        ## hybrid ISO is used as disk on e.g a USB Stick. By default
        ## the btrfs filesystem is used
        attribute hybridpersistent_filesystem {
            "btrfs" | "fat" | "exfat" | "ext4" | "xfs"
        }
    k.type.gpt_hybrid_mbr =
        ## for gpt disk types only:
        ## create a hybrid GPT/MBR partition table
        attribute gpt_hybrid_mbr { xsd:boolean }
    k.type.initrd_system.attribute =
        ## specify which initrd builder to use, default is kiwi's
        ## builtin architecture. Be aware that the dracut initrd
        ## system does not support all features of the kiwi initrd
        attribute initrd_system {
            "kiwi" | "dracut"
        }
    k.type.image.attribute =
        ## Specifies the image type
        attribute image {
            "btrfs" | "clicfs" | "cpio" | "docker" | "ext2" | "ext3" |
            "ext4" | "iso" | "oem" | "pxe" | "squashfs" | "tbz" |
            "vmx" | "xfs"
        }
    k.type.installboot.attribute =
        ## Specifies the bootloader default boot entry for the"
        ## initial boot of a kiwi install image. This value is"
        ## only evaluated for grub and ext|syslinux"
        attribute installboot {
            "failsafe-install" | "harddisk" | "install"
        }
    k.type.installprovidefailsafe.attribute =
        ## Specifies if the bootloader menu should provide an"
        ## failsafe entry with special kernel parameters or not"
        attribute installprovidefailsafe { xsd:boolean }
    k.type.installiso.attribute =
        ## Specifies if a install iso should be created (oem only)
        attribute installiso { xsd:boolean }
    k.type.installstick.attribute =
        ## Specifies if a install stick should be created (oem only)
        attribute installstick { xsd:boolean }
    k.type.installpxe.attribute =
        ## Specifies if all data for a pxe network installation should
        ## be created (oem only)
        attribute installpxe { xsd:boolean }
    k.type.kernelcmdline.attribute =
        # The kernelcmdline element specifies additional
        # kernel command line options
        attribute kernelcmdline { text }
    k.type.luks.attribute =
        ## Setup cryptographic volume along with the given filesystem
        ## using the LUKS extension. The value of this attribute
        ## represents the password string used to be able to
        ## mount that filesystem while booting
        attribute luks { text }
    k.type.luksOS.attribute =
        ## With the luksOS value a predefined set of ciper, keysize
        ## and hash format options is passed to the cryptsetup call
        ## in order to create a format compatible to the specified
        ## distribution
        attribute luksOS {
            "sle11"
        }
    k.type.mdraid.attribute =
        ## Setup software raid in degraded mode with one disk
        ## Thus only mirroring and striping is possible
        attribute mdraid {
            "mirroring" | "striping"
        }
    k.type.primary.attribute =
        ## Specifies the primary type (choose KIWI option type)
        attribute primary { xsd:boolean }
    k.type.ramonly.attribute =
        ## for use with overlay filesystems only:
        ## will force any COW action to happen in RAM
        attribute ramonly { xsd:boolean }
    k.type.rootfs_label.attribute =
        ## label to set for the root filesystem. By default ROOT is used
        attribute rootfs_label { text }
    k.type.vga.attribute =
        ## Specifies the kernel framebuffer mode. More information
        ## about the possible values can be found by calling
        ## hwinfo --framebuffer or in /usr/src/linux/Documentation/fb/vesafb.txt
        attribute vga { text }
    k.type.gcelicense.attribute =
        ## Specifies the license tag in a GCE format
        attribute gcelicense { text }
    k.type.vhdfixedtag.attribute =
        ## Specifies the GUID in a fixed format VHD
        attribute vhdfixedtag { vhd-tag-type }
    k.type.volid.attribute =
        ## for the iso type only:
        ## Specifies the volume ID (volume name or label) to be written
        ## into the master block. There is space for 32 characters.
        attribute volid { text }
    k.type.wwid_wait_timeout.attribute =
        ## Specifies the wait period in seconds after launching
        ## the multipath daemon to wait until all presented devices
        ## are available on the host. Default timeout is 3 seconds
        attribute wwid_wait_timeout { xsd:nonNegativeInteger }
    k.type.attlist =
        k.type.boot.attribute? &
        k.type.bootfilesystem.attribute? &
        k.type.firmware.attribute? &
        k.type.bootkernel.attribute? &
        k.type.bootloader.attribute? &
        k.type.bootloader_console.attribute? &
        k.type.zipl_targettype.attribute? &
        k.type.bootpartition.attribute? &
        k.type.bootpartsize.attribute? &
        k.type.bootprofile.attribute? &
        k.type.boottimeout.attribute? &
        k.type.btrfs_root_is_snapshot? &
        k.type.btrfs_root_is_readonly_snapshot? &
        k.type.checkprebuilt.attribute? &
        k.type.compressed.attribute? &
        k.type.container.attribute? &
        k.type.devicepersistency.attribute? &
        k.type.editbootconfig.attribute? &
        k.type.editbootinstall.attribute? &
        k.type.filesystem.attribute? &
        k.type.flags.attribute? &
        k.type.format.attribute? &
        k.type.formatoptions.attribute? &
        k.type.fsnocheck.attribute? &
        k.type.fsmountoptions.attribute? &
        k.type.gcelicense.attribute? &
        k.type.hybrid.attribute? &
        k.type.hybridpersistent.attribute? &
        k.type.hybridpersistent_filesystem.attribute? &
        k.type.gpt_hybrid_mbr? &
        k.type.initrd_system.attribute? &
        k.type.image.attribute &
        k.type.installboot.attribute? &
        k.type.installprovidefailsafe.attribute? &
        k.type.installiso.attribute? &
        k.type.installstick.attribute? &
        k.type.installpxe.attribute? &
        k.type.kernelcmdline.attribute? &
        k.type.luks.attribute? &
        k.type.luksOS.attribute? &
        k.type.mdraid.attribute? &
        k.type.overlayroot.attribute? &
        k.type.primary.attribute? &
        k.type.ramonly.attribute? &
        k.type.rootfs_label.attribute? &
        k.type.target_blocksize? &
        k.type.vbootsize.attribute? &
        k.type.vga.attribute? &
        k.type.vhdfixedtag.attribute? &
        k.type.volid.attribute? &
        k.type.wwid_wait_timeout.attribute?
    k.type =
        ## The Image Type of the Logical Extend
        element type { 
            k.type.attlist &
            k.machine? &
            k.oemconfig? &
            k.pxedeploy? &
            k.size? &
            k.systemdisk? &
            k.vagrantconfig*
        }
}

#==========================================
# common element <union>
#
div {
    k.union.ro.attribute =
        ## Device only for read-only 
        attribute ro { text }
    k.union.rw.attribute =
        ## Device for Read-Write
        attribute rw { text }
    k.union.type.attribute = attribute type { "overlayfs" }
    k.union.attlist =
        k.union.ro.attribute &
        k.union.rw.attribute &
        k.union.type.attribute
    
    k.union =  
        ## Specifies the Overlay Filesystem
        [
        db:para [
            "As part of the network deploy configuration this section\x{a}"~
            "specifies the overlay filesystem setup if required by the\x{a}"~
            "filesystem type of the system image.An overlay setup is\x{a}"~
            "only required if the system image uses a squashfs\x{a}"~
            "compressed filesystem."
        ]
        ]
        element union {
            k.union.attlist,
            empty
        }
}

#==========================================
# common element <user>
#
div {
    k.user.name.attribute = k.name.attribute
    k.user.id.attribute = 
        ## The user ID for this user
        attribute id { xsd:nonNegativeInteger }
    k.user.groups.attribute =
        ## The list of groups that he user belongs to. The
        ## frist item in the list is used as the login group.
        ## If 'groups' is not present a default group is assigned
        ## to the user according to he specifing toolchain behaviour.
        attribute groups { groups-list }
    k.user.realname.attribute =
        ## The name of an user
        attribute realname { text }
    k.user.password.attribute = k.password.attribute
    k.user.pwdformat =
        ## Format of the given password, encrypted is the default
        attribute pwdformat { "encrypted" | "plain" }
    k.user.home.attribute =
        ## The home directory for this user
        attribute home { text }
    k.user.shell.attribute =
        ## The shell for this user
        attribute shell { text }
    k.user.attlist =
        k.user.groups.attribute? &
        k.user.home.attribute &
        k.user.id.attribute? &
        k.user.name.attribute &
        k.user.password.attribute? &
        k.user.pwdformat? &
        k.user.realname.attribute? &
        k.user.shell.attribute?
    k.user =
        ## A User with Name, Password, Path to Its Home And Shell
        element user {
            k.user.attlist &
            empty
        }
}

#==========================================
# common element <version>
#
div {
    k.version.attlist = empty
    k.version =
        ## A Version Number for the Image, Consists of Major.Minor.Release 
        element version {
            k.version.attlist &
            text
        }
}

#==========================================
# common element <vmconfig-entry>
#
div {
    k.vmconfig-entry.attlist = empty
    k.vmconfig-entry =
        ## An entry for the VM configuration file
        element vmconfig-entry {
            k.vmconfig-entry.attlist &
            text
        }
}

#==========================================
# common element <vmdisk>
#
div {
    k.vmdisk.disktype.attribute =
        ## The type of the disk as it is internally handled
        ## by the VM (ovf only)
        attribute disktype { text }
    k.vmdisk.controller.attribute =
        ## The disk controller used for the VM guest (vmdk only)
        attribute controller {
            "ide"        |
            "buslogic"   |
            "lsilogic"   |
            "lsisas1068" |
            "legacyESX"  |
            "pvscsi"
        }
    k.vmdisk.id.attribute =
        ## The disk ID / device for the VM disk (vmdk only)
        attribute id { xsd:nonNegativeInteger }
    k.vmdisk.device.attribute =
        ## The disk device to appear in the guest (xen only)
        attribute device { text }
    k.vmdisk.diskmode.attribute = 
        ## The disk mode (vmdk only)
        attribute diskmode {
            "monolithicSparse"     |
            "monolithicFlat"       |
            "twoGbMaxExtentSparse" |
            "twoGbMaxExtentFlat"   |
            "streamOptimized"
        }
    k.vmdisk.attlist =
        k.vmdisk.disktype.attribute? &
        k.vmdisk.controller.attribute? &
        k.vmdisk.id.attribute? &
        k.vmdisk.device.attribute? &
        k.vmdisk.diskmode.attribute?
    k.vmdisk =
        ## The VM disk definition.
        element vmdisk {
            k.vmdisk.attlist &
            empty
        }
}

#==========================================
# common element <vmdvd>
#
div {
    k.vmdvd.controller.attribute =
        ## The CD/DVD controller used for the VM guest
        attribute controller { "ide" | "scsi" }
    k.vmdvd.id.attribute =
        ## The CD/DVD ID for the VM CD rom drive
        attribute id { xsd:nonNegativeInteger }
    k.vmdvd.attlist =
        k.vmdvd.controller.attribute &
        k.vmdvd.id.attribute
    k.vmdvd =
        ## The VM CD/DVD drive definition. You can setup either a
        ## scsi CD or an ide CD drive
        element vmdvd {
            k.vmdvd.attlist &
            empty
        }
}

#==========================================
# common element <vmnic>
#
div {
    k.vmnic.driver.attribute =
        ## The driver used for the VM network interface
        attribute driver { text }
    k.vmnic.interface.attribute =
        ## The interface ID for the VM network interface
        attribute interface { text }
    k.vmnic.mode.attribute =
        ## The VM network mode
        attribute mode { text }
    k.vmnic.mac.attribute =
        ## The VM mac address
        attribute mac { mac-address-type }
    k.vmnic.attlist =
        k.vmnic.driver.attribute? &
        k.vmnic.interface.attribute &
        k.vmnic.mode.attribute? &
        k.vmnic.mac.attribute?
    k.vmnic =
        ## The VM network interface definition
        element vmnic {
            k.vmnic.attlist &
            empty
        }
}

#==========================================
# common element <volume>
#
div {
    k.volume.freespace.attribute =
        ## free space to be added to this volume. The value is
        ## used as MB by default but you can add "M" and/or "G" as
        ## postfix
        attribute freespace { volume-size-type }
    k.volume.name.attribute =
        ## volume name. The name of the volume. if mountpoint is
        ## not specified the name specifies a path which has to
        ## exist inside the root directory.
        attribute name { text }
    k.volume.mountpoint.attribute =
        ## volume path. The mountpoint specifies a path which has to
        ## exist inside the root directory.
        attribute mountpoint { text }
    k.volume.size.attribute =
        ## absolute size of the volume. If the size value
        ## is too small to store all data kiwi will exit.
        ## The value is used as MB by default but you can
        ## add "M" and/or "G" as postfix
        attribute size { volume-size-type }
    k.volume.attlist =
        k.volume.freespace.attribute? &
        k.volume.mountpoint.attribute? &
        k.volume.name.attribute &
        k.volume.size.attribute?
    k.volume =
        ## Specify which parts of the filesystem should be
        ## on an extra volume.
        [
        db:para [
            "Specify which parts of the filesystem should be on\x{a}"
            "an extra volume."
        ]
        ]
        element volume {
            k.volume.attlist,
            empty
        }
}

#==========================================
# main block: <pxedeploy>
#
div {
    k.pxedeploy.server.attribute =
        ## Name or IP Address of server for downloading the data
        attribute server { text }
    k.pxedeploy.blocksize.attribute = 
        ## Blocksize value used for atftp downloads
        attribute blocksize { xsd:nonNegativeInteger }
    k.pxedeploy.attlist =
        k.pxedeploy.server.attribute? &
        k.pxedeploy.blocksize.attribute?
    k.pxedeploy =
        ## Controls the Image Deploy Process
        [
        db:para [
            "The deploy section is used to allow kiwi to create the\x{a}"~
            "config.<MAC> file required by PXE based network images.\x{a}"~
            "the contents of this file controls the image deploy process."
        ]
        ]
        element pxedeploy {
            k.pxedeploy.attlist &
            k.timeout? &
            k.kernel? &
            k.initrd? &
            k.partitions? &
            k.union? &
            k.configuration*
        }
}

#==========================================
# main block: <description>
#
div {
    k.description.type.attribute = 
        ## Kiwi distinguishes between two basic image description types
        ## which uses the same format but one is created and provided by
        ## the kiwi developers and the other is created by the users of
        ## kiwi. The type=boot specifies a boot image (initrd) which should
        ## be provided by the kiwi developers wheras type=system specifies
        ## a standard image description created by a kiwi user.
        attribute type { "boot" | "system" }
    k.description.attlist = k.description.type.attribute
    k.description =  
        ## A Short Description
        element description {
            k.description.attlist &
            k.author &
            k.contact+ &
            k.specification
        }
}

#==========================================
# main block: <drivers>
#
div {
    k.drivers.profiles.attribute = k.profiles.attribute
    k.drivers.attlist = 
        k.drivers.profiles.attribute?
        
    k.drivers =
        ## A Collection of Driver Files 
        element drivers {
            k.drivers.attlist &
            k.file+
        }
}

#==========================================
# main block: <strip>
#
div {
    k.strip.type.attribute = attribute type {
        "delete" | "tools" | "libs"
    }
    k.strip.profiles.attribute = k.profiles.attribute
    k.strip.attlist =
        k.strip.type.attribute &
        k.strip.profiles.attribute?
    k.strip =
        ## A Collection of files to strip
        element strip {
            k.strip.attlist &
            k.file+
        }
}

#==========================================
# main block: <instsource>
#
div {
    k.instsource.attlist = empty
    k.instsource =
        ## Describe Packages and Metadata
        [
        db:para [
            "The instsource element is used to describe the packages\x{a}"~
            "and the metadata which is required to build an installation\x{a}"~
            "source suitable for SUSE Linux installation media.\x{a}"~
            "From such a source it should be possible to create the\x{a}"~
            "standard SUSE CDs and DVDs as well as use this source as\x{a}"~
            "repository for image building."
        ]
        ]
        element instsource {
            k.instsource.attlist &
            k.architectures &
            k.productoptions &
            k.instrepo+ &
            k.metadata &
            k.repopackages* &
            k.driverupdate?
        }
}

#==========================================
# main block: <architectures>
#
div {
    k.architectures.attlist = empty
    k.architectures =
        ## Describe Packages and Metadata
        [
        db:para [
            "The architectures element contains a list of architectures\x{a}"~
            "for which the installation source is designed. At least one\x{a}"~
            "architecture must be defined. Fallback mecahnisms apply.\x{a}"~
            "Each arch element has an optional attribute <fallback>\x{a}"~
            "which is the next in the chain. An omitted value results in\x{a}"~
            "undefined value thus terminating the chain."
        ]
        ]
        element architectures {
            k.architectures.attlist &
            k.arch+ &
            k.requiredarch+
        }
}

#==========================================
# main block: <productoptions>
#
div {
    k.productoptions.attlist = empty
    k.productoptions =
        ## Describe Packages and Metadata
        [
        db:para [
            "The productoptions element contains a list of options\x{a}"~
            "that influence the instsource creation process in a\x{a}"~
            "general manner. For instance an option could specify\x{a}"~
            "a default medium number for source packages and the like."
        ]
        ]
        element productoptions {
            k.productoptions.attlist &
            k.productoption* &
            k.productinfo* &
            k.productvar*
        }
}

#==========================================
# main block: <productoption>
#
div {
    k.productoption.attlist = k.name.attribute

    k.productoption =
        ## Describe Packages and Metadata
        [
        db:para [
            "The productoption element carries the information for a\x{a}"~
            "product option its name and its fallback (productoptional)."
        ]
        ]
        element productoption {
            k.productoption.attlist &
            text
            #k.productinfo.text.content 
            #xsd:normalizedString { maxLength = "2048" }
        }
}

#==========================================
# main block: <arch>
#
div {
    k.arch.name.attribute = k.name.attribute
        k.arch.id.attribute = k.id.attribute
        k.arch.fallback.attribute = attribute fallback { xsd:IDREF }

    k.arch.attlist = k.arch.id.attribute &
             k.arch.name.attribute &
             k.arch.fallback.attribute?

    k.arch =
        ## Describe Packages and Metadata
        [
        db:para [
            "The arch element providdes the information for an arch,\x{a}"~
            "its name and its fallback (optional)."
        ]
        ]
        element arch {
            k.arch.attlist &
            empty
        }
}

#==========================================
# main block: <requiredarch>
#
div {
        k.requiredarch.ref.attribute = attribute ref { xsd:IDREF }

    k.requiredarch.attlist = k.requiredarch.ref.attribute

    k.requiredarch =
        ## Describe Packages and Metadata
        [
        db:para [
            "The requiredarch element defines which  architectures\x{a}"~
            "are the basic required ones for the media."
        ]
        ]
        element requiredarch {
            k.requiredarch.attlist &
            empty
        }
}

#==========================================
# main block: <productinfo>
#
div {
    k.productinfo.attlist = k.name.attribute 
    k.productinfo =
        ## Describe Packages and Metadata
        [
        db:para [
            "The productinfo element contains one particular environment\x{a}"~
            "variable and its value. Shell rules for the names apply.\x{a}"~
            "The value must not exceed a certain length for sanity.\x{a}"~
            "reasons Any funny characters like tabs, line break,\x{a}"~
            "carriage return or combinations are converted to spaces\x{a}"~
            "(one each) which may lead to unexpected contents."
        ]
        ]
        element productinfo {
            k.productinfo.attlist &
            # text: workaround for the above mentioned problem
            text
            #k.productinfo.text.content 
            #xsd:normalizedString { maxLength = "2048" }
        }
}

#==========================================
# main block: <productvar>
#
div {
    k.productvar.attlist =
        k.name.attribute 
    k.productvar =
        ## Describe Packages and Metadata
        [
        db:para [
            "The productinfo element contains one particular environment\x{a}"~
            "variable and its value. Shell rules for the names apply.\x{a}"~
            "The value is used to create the content file."
        ]
        ]
        element productvar {
            k.productvar.attlist &
            # text: workaround for the above mentioned problem
            text
            #k.productvar 
            #xsd:normalizedString { maxLength = "2048" }
        }
}

#==========================================
# main block: <chroot>
#
div {
    k.chroot.attlist = attribute requires { text } 

    k.chroot =
        ## Describe Packages and Metadata
        [
        db:para [
            "The chroot element contains one particular environment\x{a}"~
            "variable and its value. Shell rules for the names apply.\x{a}"~
            "The value must not exceed a certain length for sanity.\x{a}"~
            "reasons Any funny characters like tabs, line break,\x{a}"~
            "carriage return or combinations are converted to spaces\x{a}"~
            "(one each) which may lead to unexpected contents."
        ]
        ]
        element chroot {
            k.chroot.attlist &
            text
        }
}

#==========================================
# main block: <repopackages>
#
div {
    k.repopackages.attlist = empty
    k.repopackages =  
        ## Specifies Packages for Installation Source
        [
        db:para [
            "The repopackages elements specifies a set of packages which\x{a}"~
            "are used for creating a SUSE installation source."
        ]
        ]
        element repopackages {
            k.repopackages.attlist &
            k.repopackage*
        }
}

#==========================================
# main block: <driverupdate>
#
div {
    k.driverupdate.attlist = empty
    k.driverupdate =
        ## Describe Packages and Metadata
        [
        db:para [
            "Creating a driverupdate disk for using updated hardware\x{a}"~
            "drivers on system installation with YaST."
        ]
        ]
        element driverupdate {
            k.driverupdate.attlist &
            k.target+ &
            k.install? &
            k.modules? &
            k.instsys?
        }
}

#==========================================
# main block: <target>
#
div {
    k.target.arch.attribute = k.arch.attribute
    k.target.attlist = k.target.arch.attribute
    k.target =
        ## Describe Packages and Metadata
        [
        db:para [
            "List of update targets: <dist>-<arch>\x{a}"
        ]
        ]
        element target {
            k.target.attlist &
            text
        }
}

#==========================================
# main block: <install>
#
div {
    k.install.attlist = empty
    k.install =
        ## Describe Packages and Metadata
        [
        db:para [
            "List of packages to be copied into the 'install' directory"
        ]
        ]
        element install {
            k.install.attlist &
            k.repopackage*
        }
}

#==========================================
# main block: <modules>
#
div {
    k.modules.attlist = empty
    k.modules =
        ## Describe Packages and Metadata
        [
        db:para [
            "List of packages to be copied into the 'modules' directory"
        ]
        ]
        element modules {
            k.modules.attlist &
            k.repopackage*
        }
}

#==========================================
# main block: <instsys>
#
div {
    k.instsys.attlist = empty
    k.instsys =
        ## Describe Packages and Metadata
        [
        db:para [
            "List of packages to be copied into the 'instsys' directory"
        ]
        ]
        element instsys {
            k.instsys.attlist &
            k.repopackage*
        }
}

#==========================================
# main block: <oemconfig>
#
div {
    k.oemconfig.attlist = empty
    k.oemconfig =
        ## Specifies the OEM configuration section
        [
        db:para [
            "The oemconfig element specifies the OEM image\x{a}"~
            "configuration options which are used to repartition\x{a}"~
            "and setup the system disk"
        ]
        ]
        element oemconfig {
            k.oemconfig.attlist &
            k.oem-ataraid-scan? &
            k.oem-boot-title? &
            k.oem-bootwait? &
            k.oem-device-filter? &
            k.oem-inplace-recovery? &
            k.oem-kiwi-initrd? &
            k.oem-multipath-scan? &
            k.oem-vmcp-parmfile? &
            k.oem-partition-install? &
            k.oem-reboot? &
            k.oem-reboot-interactive? &
            k.oem-recovery? &
            k.oem-recoveryID? &
            k.oem-recovery-part-size? &
            k.oem-shutdown? &
            k.oem-shutdown-interactive? &
            k.oem-silent-boot? &
            k.oem-silent-install? &
            k.oem-silent-verify? &
            k.oem-skip-verify? &
            k.oem-swap? &
            k.oem-swapsize? &
            k.oem-systemsize? &
            k.oem-unattended? &
            k.oem-unattended-id?
        }
}

#==========================================
# main block: <vagrantconfig>
#
div {
    k.vagrantconfig.provider.attribute =
        ## The vagrant provider for this box
        attribute provider { "libvirt" | "virtualbox" }
    k.vagrantconfig.virtualsize.attribute =
        ## The vagrant virtual image size in GB
        [
        db:para [
            "virtualsize provides the value of the virtual_size key"
            "which is embedded in the metadata.json hash inside the"
            ".box file, as described here:"
            ""
            "http://docs.vagrantup.com/v2/boxes/format.html"
            ""
            "This tells the Vagrant provider how big to make the"
            "virtual disk when it creates the VM."
        ]
        ]
        attribute virtualsize { xsd:nonNegativeInteger }
    k.vagrantconfig.boxname.attribute =
        ## The boxname as it's written into the json file
        ## If not specified the image name is used
        [
        db:para [
            "The boxname as it's written into the json file."
            "If not specified the image name is used."
        ]
        ]
        attribute boxname { text }
    k.vagrantconfig.attlist =
        k.vagrantconfig.provider.attribute &
        k.vagrantconfig.virtualsize.attribute &
        k.vagrantconfig.boxname.attribute?
    k.vagrantconfig =
        ## Specifies the Vagrant configuration section
        [
        db:para [
            "The vagrantconfig element specifies the Vagrant meta"
            "configuration options which are used inside a vagrant box"
        ]
        ]
        element vagrantconfig {
            k.vagrantconfig.attlist
        }
}

#==========================================
# main block: <machine>
#
div {
    k.machine.ovftype.attribute =
        ## The OVF configuration type
        attribute ovftype { "zvm" | "powervm" | "xen" | "vmware" }
    k.machine.HWversion.attribute =
        ## The virtual HW version number for the VM configuration
        ## (vmdk and ovf)
        attribute HWversion { xsd:integer }
    k.machine.arch.attribute =
        ## the VM architecture type (vmdk only)
        attribute arch { "ix86" | "x86_64" }
    k.machine.domain.attribute =
        ## The domain setup for the VM (xen only)
        attribute domain { "dom0" | "domU" }
    k.machine.guestOS.attribute =
        ## The virtual guestOS identification string for the VM
        ## (vmdk and ovf, note the name designation is different for the two
        ## formats)
        attribute guestOS { text }
    k.machine.min_memory.attribute =
        ## The virtual machine min memory in MB (ovf only)
        attribute min_memory { xsd:nonNegativeInteger }
    k.machine.max_memory.attribute =
        ## The virtual machine max memory in MB (ovf only)
        attribute max_memory { xsd:nonNegativeInteger }
    k.machine.min_cpu.attribute =
        ## The virtual machine min CPU count (ovf only)
        attribute min_cpu { xsd:nonNegativeInteger }
    k.machine.max_cpu.attribute =
        ## The virtual machine max CPU count (ovf only)
        attribute max_cpu { xsd:nonNegativeInteger }
    k.machine.memory.attribute =
        ## The memory, in MB, setup for the guest VM (all formats)
        attribute memory { xsd:nonNegativeInteger }
    k.machine.ncpus.attribute =
        ## The number of virtual cpus for the guest VM (all formats)
        attribute ncpus { xsd:nonNegativeInteger }
    k.machine.attlist =
        k.machine.min_memory.attribute? &
        k.machine.max_memory.attribute? &
        k.machine.min_cpu.attribute? &
        k.machine.max_cpu.attribute? &
        k.machine.ovftype.attribute? &
        k.machine.HWversion.attribute? &
        k.machine.arch.attribute? &
        k.machine.domain.attribute? &
        k.machine.guestOS.attribute? &
        k.machine.memory.attribute? &
        k.machine.ncpus.attribute?
    k.machine =
        ## specifies the VM configuration sections
        [
        db:para [
            "The machine element specifies the VM guest\x{a}"~
            "configuration options which are used by the\x{a}"~
            "virtual machine when running the image."
        ]
        ]
        element machine {
            k.machine.attlist &
            k.vmconfig-entry * &
            k.vmdisk &
            k.vmdvd ? &
            k.vmnic *
        }
}

#==========================================
# main block: <packages>
#
div {
    k.packages.type.attribute = attribute type {
        "bootstrap" | "delete" | "docker" | "image" |
        "iso" | "oem" | "pxe" | "vmx"
    }
    k.packages.profiles.attribute = k.profiles.attribute
    k.packages.patternType.attribute =
        ## Selection type for patterns. Could be onlyRequired
        ## or plusRecommended
        attribute patternType {
            "onlyRequired" | "plusRecommended"
        }
    k.packages.attlist =
        k.packages.type.attribute &
        k.packages.profiles.attribute? &
        k.packages.patternType.attribute?
    k.packages =
        ## Specifies Packages/Patterns Used in Different Stages
        [
        db:para [
            "The packages elements specifies a set of packages\x{a}"~
            "and/or patterns which are used in different stages of the\x{a}"~
            "image building process\x{a}"~
            "and also depends of the selected image output type."
        ]
        ]
        element packages {
            k.packages.attlist &
            k.archive* &
            k.ignore* &
            k.namedCollection* &
            k.product* &
            k.package*
        }
}

#==========================================
# main block: <preferences>
#
div {
    k.preferences.profiles.attribute = k.profiles.attribute
    k.preferences.attlist =
        k.preferences.profiles.attribute?
    k.preferences =  
        ## Configuration Information Needed for Logical Extend
                # All elements are optional since the combination of appropriate
                # preference sections based on profiles combine to create on vaild
                # definition
        element preferences {
            k.preferences.attlist &
            k.bootsplash-theme? &
            k.bootloader-theme? &
            k.defaultdestination? &
            k.defaultprebuilt? &
            k.defaultroot? &
            k.hwclock? &
            k.keytable? &
            k.locale? &
            k.packagemanager? &
            k.partitioner? &
            k.rpm-check-signatures? &
            k.rpm-excludedocs? &
            k.rpm-force? &
            k.showlicense* &
            k.timezone? &
            k.type* &
            k.version?
        }
}

#==========================================
# main block: <profiles>
#
div {
    k.profiles.attlist = empty
    k.profiles =  
        ## Creates Namespace Section for Drivers
        [
        db:para [
            "Namespace section which creates a namespace and the\x{a}"~
            "drivers can bind itself to one of the listed namespaces."
        ]
        ]
        element profiles {
            k.profiles.attlist &
            k.profile+
        }
}

#==========================================
# main block: <users>
#
div {
    k.users.profiles.attribute = k.profiles.attribute
    k.users.attlist =
        k.users.profiles.attribute?
    k.users = 
        ## A List of Users
        element users {
            k.users.attlist &
            k.user+
        }
}


# vim: set noexpandtab:
