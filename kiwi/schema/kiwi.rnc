#================
# FILE          : kiwi.rnc
#****************
# PROJECT       : KIWI - Appliance Builder
# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH, Germany
#               :
# AUTHOR        : Thomas Schraitle <toms@suse.de>
# AUTHOR        : Marcus Schaefer <ms@suse.de>
#               :
# BELONGS TO    : Operating System images
#               :
# DESCRIPTION   : This is the RELAX NG Schema for KIWI
#               : configuration files. The schema is maintained
#               : in the relax compact syntax. Any changes should
#               : made in !! *** kiwi.rnc *** !!
#               : 
#               :
# STATUS        : Development
#****************
namespace rng = "http://relaxng.org/ns/structure/1.0"
namespace xsi = "http://www.w3.org/2001/XMLSchema-instance"
datatypes xsd = "http://www.w3.org/2001/XMLSchema-datatypes"
namespace db  = "http://docbook.org/ns/docbook"
namespace sch = "http://purl.oclc.org/dsdl/schematron"
namespace nul = ""

db:info [
    db:releaseinfo [
        "$Id: $"
    ]
    db:releaseinfo [ "RNC Schema Version 6.4" ]
    db:pubdate [ "START" ]
    db:pubdate [ "2016-03-18" ]
]

image-name = xsd:token {pattern = "[a-zA-Z0-9_\-\.]+"}
locale-name = xsd:token {pattern = "[a-z]{2}_[A-Z]{2}(,[a-z]{2}_[A-Z]{2})*"}
mac-address-type = xsd:token {pattern = "([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}"}
size-type = xsd:token {pattern = "\d*|image"}
volume-size-type = xsd:token {pattern = "\d+|\d+M|\d+G|all"}
partition-size-type = xsd:token {pattern = "\d+|\d+M|\d+G"}
vhd-tag-type = xsd:token {pattern = "[0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12}"}
groups-list = xsd:token {pattern = "[a-zA-Z0-9_\-\.]+(,[a-zA-Z0-9_\-\.]+)*"}
arch-name = xsd:token {pattern = "(x86_64|i586|i686|ix86|aarch64|arm64|armv5el|armv5tel|armv6hl|armv6l|armv7hl|armv7l|ppc|ppc64|ppc64le|s390|s390x)(,(x86_64|i586|i686|ix86|aarch64|arm64|armv5el|armv5tel|armv6hl|armv6l|armv7hl|armv7l|ppc|ppc64|ppc64le|s390|s390x))*"}

#==========================================
# start with image description
#
start =
    ## The start pattern of an image
    k.image

#==========================================
# main block: <image>
#
div {
    k.image.name.attribute = k.imagename.attribute 
    k.image.displayname.attribute = k.displayname.attribute
    k.image.noNamespaceSchemaLocation.attribute =
        ## The location of the XSD Schema (not relevant for RELAX NG or DTD)
        attribute xsi:noNamespaceSchemaLocation { xsd:anyURI }
    k.image.schemaLocation.attribute =
        ## A pair of URI references: First is a namespace name,
        ## second the location of the XSD Schema
        ## (not relevant for RELAX NG or DTD)
        attribute xsi:schemaLocation { xsd:anyURI }
    k.image.schemaversion.attribute =
        ## The allowed Schema version (fixed value)
        attribute schemaversion { "6.5" }
    k.image.kiwirevision.attribute =
        ## A kiwi git revision number which is known to build
        ## a working image from this description. If the kiwi git
        ## revision doesn't match the installed kiwi revision the
        ## process will exit.
        attribute kiwirevision { text }
    k.image.id =
        ## An identification number which is represented in a file
        ## named /etc/ImageID
        attribute id { xsd:string {length="10"} }
    k.image.attlist = k.image.name.attribute 
        & k.image.displayname.attribute?
        & k.image.kiwirevision.attribute?
        & k.image.id?
        & k.image.schemaversion.attribute
        & ( k.image.noNamespaceSchemaLocation.attribute?
            | k.image.schemaLocation.attribute? )?

    k.image =
        ## The root element of the configuration file   
        [
        db:para [
            "Each KIWI configuration file consists of a root element\x{a}" ~
            "image."
        ]
        ]
        element image {
            k.image.attlist &
            k.description &
            k.preferences+ &
            k.profiles? &
            k.users* &
            k.drivers* &
            k.strip* &
            k.repository* &
            k.packages* &
            k.extension?
        }
}

#==========================================
# common attributes
#
k.id.attribute          =
    ## An ID
    attribute id { xsd:ID }
k.name.attribute        =
    ## A name
    attribute name { text }
k.replaces.attribute    =
    ## Replace package with some other package
    attribute replaces { text }
k.bootinclude.attribute =
    ## Indicates that this package should be part of
    ## the boot image (initrd) too. This attribute
    ## can be used to include for example branding packages
    ## specified in the system image description to become
    ## part of the boot image also
    attribute bootinclude { xsd:boolean }
k.bootdelete.attribute =
    ## Indicates that this package should be removed from
    ## the boot image (initrd). the attribute is only
    ## evaluated if the bootinclude attribute is specified
    ## along with it too
    attribute bootdelete { xsd:boolean }
k.displayname.attribute =
    ## A friendly display name. Used in the boot menu
    ## for isolinux and grub
    attribute displayname { text }
k.arch.attribute        =
    ## A system architecture name, matching the 'uname -m' information
    ## Multiple architectures can be combined as comma separated list
    ## e.g arch="x86_64,ix86"
    attribute arch { arch-name }
k.description.attribute =
    ## A short description
    attribute description { text }
k.path.attribute        =
    ## A path
    attribute path { text }
k.profiles.attribute    =
    ## A profile name which binds the section to this name
    attribute profiles { text }
k.password.attribute    =
    ## The password
    attribute password { text }
k.script.attribute      =
    ## A script hook for meta files to be called after the
    ## file was fetched
    attribute script { text }
k.source.attribute      =
    ## A source location where a package or configuration file can be found
    attribute source { text }
k.size.attribute        =
    ## A partition size or optional image size
    attribute size { size-type }
k.dest.attribute        =
    ## Destination of a resource
    attribute dest { text }
k.username.attribute    =
    ## A name of a user
    attribute username { text }
k.imagename.attribute   =
    ## An image name without / and spaces
    attribute name { image-name }

div {
    k._any.attribute =
        ## Any attribute including in any attribute in any namespace.
        attribute * { text }

    k._any =
        ## Any element from almost any namespace except empty ones
        element * - (nul:*) {
            (k._any.attribute | text | k._any)*
        }
}

#==========================================
# common element <extension>
#
div {
    k.extension.attlist = empty
    k.extension =
        ## Define custom XML extensions
        element extension {
            k.extension.attlist,
            k._any+
        }
}

#==========================================
# common element <archive>
#
div {
    k.archive.name.attribute = k.name.attribute
    k.archive.bootinclude.attribute = k.bootinclude.attribute
    k.archive.attlist =
        k.archive.name.attribute &
        k.archive.bootinclude.attribute?
    k.archive =
        ## Name of an image archive file (tarball)
        element archive {
            k.archive.attlist,
            empty
        }
}

#==========================================
# common element <author>
#
div {
    k.author.attlist = empty
    k.author =
        ## Author of the image
        element author { k.author.attlist, text }
}

#==========================================
# common element <bootloader-theme>
#
div {
    k.bootloader-theme.attlist = empty
    k.bootloader-theme =
        ## Image bootloader theme setup.
        [
        db:para [
            "The value will be used in KIWIConfig.sh::suseGFXBoot"
        ]
        ]
        element bootloader-theme {
            k.bootloader-theme.attlist,
            text
        }
}

#==========================================
# common element <bootsplash-theme>
#
div {
    k.bootsplash-theme.attlist = empty
    k.bootsplash-theme =
        ## Image bootsplash theme setup.
        [
        db:para [
            "The value will be used in KIWIConfig.sh::suseGFXBoot"
        ]
        ]
        element bootsplash-theme {
            k.bootsplash-theme.attlist,
            text
        }
}

#==========================================
# common element <configuration>
#
div {
    k.configuration.source.attribute = k.source.attribute
    k.configuration.dest.attribute = k.dest.attribute
    k.configuration.arch.attribute = k.arch.attribute
    k.configuration.attlist = 
        k.configuration.source.attribute &
        k.configuration.dest.attribute &
        k.configuration.arch.attribute?

    k.configuration =
        ## Specifies Configuration files
        [
        db:para [
            "As part of the network deploy configuration this section\x{a}" ~
            "specifies the configuration files which should be included\x{a}"~
            "into the image after deployment."
        ]
        ]
        element configuration {
            k.configuration.attlist,
            empty
        }
}

#==========================================
# common element <contact>
#
div {
    k.contact.attlist = empty
    k.contact = 
        ## Contact Information from the Author, like Email etc.
        element contact {
            k.contact.attlist,
            text
        }
}

#==========================================
# common element <defaultdestination>
#
div {
    k.defaultdestination.attlist = empty
    k.defaultdestination =
        ## Default Path if destdir Otion is Not Specified
        element defaultdestination {
            k.defaultdestination.attlist,
            text
        }
}

#==========================================
# common element <defaultprebuilt>
#
div {
    k.defaultprebuilt.attlist = empty
    k.defaultprebuilt =
        ## Default directory name for pre-built boot images, used if
        ## the directory is not specified on the command line
        element defaultprebuilt {
            k.defaultroot.attlist,
            text
        }
}

#==========================================
# common element <defaultroot>
#
div {
    k.defaultroot.attlist = empty
    k.defaultroot =
        ## Default Root Directory Name if root Option is Not Specified
        element defaultroot {
            k.defaultroot.attlist,
            text
        }
}

#==========================================
# common element <file>
#
div {
    k.file.name.attribute = k.name.attribute
    k.file.arch.attribute = k.arch.attribute
    k.file.attlist =
        k.file.name.attribute &
        k.file.arch.attribute?
    k.file =
        ## A Pointer to a File
        element file {
            k.file.attlist,
            empty
        }
}

#==========================================
# common element <hwclock>
#
div {
    k.hwclock.content = "utc" | "localtime"
    k.hwclock.attlist = empty
    k.hwclock =
        ## Setup Image harware clock setup, either utc or localtime
        [
        db:para [
            "Image hardware clock setup. The value can be either\x{a}"~
            "set to utc or localtime."
        ]
        ]
        element hwclock {
            k.hwclock.attlist,
            k.hwclock.content
        }
}

#==========================================
# common element <ignore>
#
div {
    k.ignore.name.attribute = k.name.attribute
    k.ignore.arch.attribute = k.arch.attribute
    k.ignore.attlist =
        k.ignore.name.attribute &
        k.ignore.arch.attribute?
    k.ignore = 
        ## Ignores a Package
        element ignore {
            k.ignore.attlist,
            empty
        }
}

#==========================================
# common element <initrd>
#
div {
    k.initrd.attlist = empty
    k.initrd =
        ## Specifies where the Boot Image can be Found
        [
        db:para [
            "As part of the network deploy configuration this element\x{a}"~
            "specifies where the boot image (initrd) can be found."
        ]
        ]
        element initrd {
            k.initrd.attlist,
            text
        }
}

#==========================================
# common element <kernel>
#
div {
    k.kernel.attlist = empty
    k.kernel =
        ## Specifies Where to Find the Boot Kernel
        [
        db:para [
            "As part of the network deploy configuration this section\x{a}" ~
            "specifies the where to find the boot kernel."
        ]
        ]
        element kernel {
            k.kernel.attlist,
            text
        }
}

#==========================================
# common element <keytable>
#
div {
    k.keytable.attlist = empty
    k.keytable =
        ## Image keytable setup.
        [
        db:para [
            "The value will be part of /etc/sysconfig/keyboard"
        ]
        ]
        element keytable {
            k.keytable.attlist,
            text
        }
}

#==========================================
# common element <locale>
#
div { # locale
    k.locale.attlist = empty
    k.locale =
        ## Image locale setup.
        [
        db:para [
            "The value will be part of /etc/sysconfig/keyboard"
        ]
        ]
        element locale {
            k.locale.attlist,
            locale-name
        }
}

#==========================================
# common element <namedCollection>
#
div {
    k.namedCollection.name.attribute = k.name.attribute
    k.namedCollection.arch.attribute = k.arch.attribute
    k.namedCollection.attlist =
        k.namedCollection.name.attribute &
        k.namedCollection.arch.attribute?
    k.namedCollection =
        ## Name of a Pattern for SUSE or a Group for RH
        element namedCollection {
            k.namedCollection.attlist,
            empty
        }
}

#==========================================
# common element <oem-boot-title>
#
div {
    k.oem-boot-title.attlist = empty
    k.oem-boot-title =
        ## For oemboot driven images: setup of the boot menu text
        ## displayed within the square brackets after first reboot
        ## of the OEM image
        [
        db:para [
            "For oemboot driven images: setup of the boot menu text\x{a}"~
            "displayed within the square brackets after first reboot\x{a}"~
            "of the OEM image."
        ]
        ]
        element oem-boot-title {
            k.oem-boot-title.attlist,
            text
        }
}

#==========================================
# common element <oem-bootwait>
#
div {
    k.oem-bootwait.content = xsd:boolean
    k.oem-bootwait.attlist = empty
    k.oem-bootwait =
        ## For oemboot driven images: halt system after image dump true/false
        [
        db:para [
            "For oemboot driven images: wait for user acknowledgement "~
            "after first deployment true/false. A message to be "~
            "acknowledged by the user is posted after the image has been "~
            "dumped (installed) on the target disk. After user interaction "~
            "the system reboots (softboot)."
        ]
        ]
        element oem-bootwait {
            k.oem-bootwait.attlist,
            k.oem-bootwait.content
        }
}

#==========================================
# common element <oem-device-filter>
#
div {
    k.oem-device-filter.content = text
    k.oem-device-filter.attlist = empty
    k.oem-device-filter =
        ## For oemboot driven images: filter install devices by given
        ## regular expression. The expression is handled by the bash regexp
        ## operator
        [
        db:para [
            "For oemboot driven images: filter install devices by given"~
            "regular expression. The expression is handled by the bash"~
            "regexp operator"
        ]
        ]
        element oem-device-filter {
            k.oem-device-filter.attlist,
            k.oem-device-filter.content
        }
}

#==========================================
# common element <oem-inplace-recovery>
#
div {
    k.oem-inplace-recovery.content = xsd:boolean
    k.oem-inplace-recovery.attlist = empty
    k.oem-inplace-recovery =
        ## For oemboot driven images: Specify whether the
        ## recovery archive should be stored as part of the image
        ## or not. If it's not stored it's created during install
        ## of the oem image
        [
        db:para [
            "For oemboot driven images: Specify whether the\x{a}"~
            "recovery archive should be stored as part of the image\x{a}"~
            "or not. If it's not stored it's created during install\x{a}"~
            "of the oem image"
        ]
        ]
        element oem-inplace-recovery {
            k.oem-inplace-recovery.attlist,
            k.oem-inplace-recovery.content
        }
}

#==========================================
# common element <oem-kiwi-initrd>
#
div {
    k.oem-kiwi-initrd.content = xsd:boolean
    k.oem-kiwi-initrd.attlist = empty
    k.oem-kiwi-initrd =
        ## For oemboot driven images: use kiwi initrd in any case
        ## and don't replace it with mkinitrd created initrd
        [
        db:para [
            "For oemboot driven images: use kiwi initrd in any case\x{a}"~
            "and don't replace it with mkinitrd created initrd"
        ]
        ]
        element oem-kiwi-initrd {
            k.oem-kiwi-initrd.attlist,
            k.oem-kiwi-initrd.content
        }
}

#==========================================
# common element <oem-partition-install>
#
div {
    k.oem-partition-install.content = xsd:boolean
    k.oem-partition-install.attlist = empty
    k.oem-partition-install =
        ## For oemboot driven images: install the system not as
        ## disk but into a free partition. If this option is set
        ## all other oem-* options concerning the partition table
        ## will not have any effect
        [
        db:para [
            "For oemboot driven images: install the system not as\x{a}"~
            "disk but into a free partition. If this option is set\x{a}"~
            "all other oem-* options concerning the partition table\x{a}"~
            "will not have any effect"
        ]
        ]
        element oem-partition-install {
            k.oem-partition-install.attlist,
            k.oem-partition-install.content
        }
}

#==========================================
# common element <oem-reboot>
#
div {
    k.oem-reboot.content = xsd:boolean
    k.oem-reboot.attlist = empty
    k.oem-reboot =
        ## For oemboot driven images: reboot after first deployment true/false
        [
        db:para [
            "For oemboot driven images: reboot after first deployment "~
            "true/false. The system is rebooted in similar fashion to "~
            "shutdown -r after the image has been dumped (installed) "~
            "and expanded on the target disk."
        ]
        ]
        element oem-reboot {
            k.oem-reboot.attlist,
            k.oem-reboot.content
        }
}

#==========================================
# common element <oem-reboot-interactive>
#
div {
    k.oem-reboot-interactive.content = xsd:boolean
    k.oem-reboot-interactive.attlist = empty
    k.oem-reboot-interactive =
        ## For oemboot driven images: reboot after first deployment true/false
        [
        db:para [
            "For oemboot driven images: reboot after first deployment "~
            "true/false. A message to be acknowledged by the user is "~
            "posted after the image has been dumped (installed) and "~
            "expanded on the target disk. After user interaction the "~
            "system is rebooted in similar fashion to shutdown -r."
        ]
        ]
        element oem-reboot-interactive {
            k.oem-reboot-interactive.attlist,
            k.oem-reboot-interactive.content
        }
}

#==========================================
# common element <oem-recovery>
#
div {
    k.oem-recovery.content = xsd:boolean
    k.oem-recovery.attlist = empty
    k.oem-recovery =
        ## For oemboot driven images: create a recovery archive yes/no
        [
        db:para [
            "For oemboot driven images: create a recovery archive yes/no"
        ]
        ]
        element oem-recovery {
            k.oem-recovery.attlist,
            k.oem-recovery.content
        }
}

#==========================================
# common element <oem-recoveryID>
#
div {
    k.oem-recoveryID.attlist = empty
    k.oem-recoveryID =
        ## For oemboot driven images: Set the partition ID of
        ## recovery partition. Default value is 83 (Linux)
        [
        db:para [
            "For oemboot driven images: Set the partition ID of\x{a}"~
            "recovery partition. Default value is 83 (Linux)"
        ]
        ]
        element oem-recoveryID {
            k.oem-recoveryID.attlist,
            xsd:nonNegativeInteger
        }
}

#==========================================
# common element <oem-recovery-part-size>
#
div {
    k.oem-recovery-part-size.attlist = empty
    k.oem-recovery-part-size =
        ## For oemboot driven images: Set the size of the
        ## recovery partition. Value is interpreted as MB
        [
        db:para [
            "For oemboot driven images: Set the size of\x{a}"~
            "the recovery partition in MBytes."
        ]
        ]
        element oem-recovery-part-size {
            k.oem-recovery-part-size.attlist,
            xsd:nonNegativeInteger
        }
}

#==========================================
# common element <oem-shutdown>
#
div {
    k.oem-shutdown.content = xsd:boolean
    k.oem-shutdown.attlist = empty
    k.oem-shutdown =
        ## For oemboot driven images: shutdown after first deployment 
        ## true/false
        [
        db:para [
            "For oemboot driven images: shutdown after first deployment "~
            "true/false. The system is powered down after the image has "~
            "been dumped (installed) and expanded on the target disk. "
        ]
        ]
        element oem-shutdown {
            k.oem-shutdown.attlist,
            k.oem-shutdown.content
        }
}

#==========================================
# common element <oem-shutdown-interactive>
#
div {
    k.oem-shutdown-interactive.content = xsd:boolean
    k.oem-shutdown-interactive.attlist = empty
    k.oem-shutdown-interactive =
        ## For oemboot driven images: shutdown after first deployment 
        ## true/false
        [
        db:para [
            "For oemboot driven images: shutdown after first deployment "~
            "true/false. A message to be acknowledged by the user is posted "~
            "after the image has been dumped (installed) and expanded on "~
            "the target disk. After user interaction the system is shutdown."
        ]
        ]
        element oem-shutdown-interactive {
            k.oem-shutdown-interactive.attlist,
            k.oem-shutdown-interactive.content
        }
}

#==========================================
# common element <oem-silent-boot>
#
div {
    k.oem-silent-boot.content = xsd:boolean
    k.oem-silent-boot.attlist = empty
    k.oem-silent-boot =
        ## For oemboot driven images: boot silently during the initial boot
        ## true/false
        [
        db:para [
            "For oemboot driven images: complete the initial boot of the "~
            "system in silent mode, true/false. "
        ]
        ]
        element oem-silent-boot {
            k.oem-silent-boot.attlist,
            k.oem-silent-boot.content
        }
}

#==========================================
# common element <oem-silent-install>
#
div {
    k.oem-silent-install.content = xsd:boolean
    k.oem-silent-install.attlist = empty
    k.oem-silent-install =
        ## For oemboot driven images: do not show progress of the image
                ## dump process, true/false
        [
        db:para [
            "For oemboot driven images: do not show progress of the image "~
                        "dump process, true/false (default is false.) "
        ]
        ]
        element oem-silent-install {
                        k.oem-silent-install.attlist,
            k.oem-silent-install.content
        }
}

#==========================================
# common element <oem-skip-verify>
#
div {
    k.oem-skip-verify.content = xsd:boolean
    k.oem-skip-verify.attlist = empty
    k.oem-skip-verify =
        ## For oemboot driven images: do not perform the md5
        ## verification process, true/false
        [
        db:para [
            "For oemboot driven images: do not perform the md5 "~
            "verification process, true/false (default is false.) "
        ]
        ]
        element oem-skip-verify {
            k.oem-skip-verify.attlist,
            k.oem-skip-verify.content
        }
}

#==========================================
# common element <oem-ataraid-scan>
#
div {
    k.oem-ataraid-scan.content = xsd:boolean
    k.oem-ataraid-scan.attlist = empty
    k.oem-ataraid-scan =
        ## For oemboot driven images: turn on or off the search
        ## for ata raid devices (aka fake raid controllers)
        ## true/false (default is true)
        [
        db:para [
            "For oemboot driven images: turn on or off the search "~
            "for ata raid devices (aka fake raid controllers) "
            "true/false (default is true) "
        ]
        ]
        element oem-ataraid-scan {
            k.oem-ataraid-scan.attlist,
            k.oem-ataraid-scan.content
        }
}

#==========================================
# common element <oem-vmcp-parmfile>
#
div {
    k.oem-vmcp-parmfile.content = text
    k.oem-vmcp-parmfile.attlist = empty
    k.oem-vmcp-parmfile =
        ## For oemboot driven images: provide the name of a parmfile
        ## which is loaded via cmsfscat on s390 systems. Default value
        ## is set to: PARM-S11
        [
        db:para [
            "For oemboot driven images: provide the name of a parmfile "~
            "which is loaded via cmsfscat on s390 systems. Default value "~
            "is set to: PARM-S11"
        ]
        ]
        element oem-vmcp-parmfile {
            k.oem-vmcp-parmfile.attlist,
            k.oem-vmcp-parmfile.content
        }
}

#==========================================
# common element <oem-multipath-scan>
#
div {
    k.oem-multipath-scan.content = xsd:boolean
    k.oem-multipath-scan.attlist = empty
    k.oem-multipath-scan =
        ## For oemboot driven images: turn on or off the search
        ## for multipath devices: true/false (default is true)
        [
        db:para [
            "For oemboot driven images: turn on or off the search "~
            "for multipath devices: true/false (default is true) "
        ]
        ]
        element oem-multipath-scan {
            k.oem-multipath-scan.attlist,
            k.oem-multipath-scan.content
        }
}

#==========================================
# common element <oem-silent-verify>
#
div {
    k.oem-silent-verify.content = xsd:boolean
    k.oem-silent-verify.attlist = empty
    k.oem-silent-verify =
        ## For oemboot driven images: do not show progress of the image
                ## verification process, true/false
        [
        db:para [
            "For oemboot driven images: do not show progress of the image "~
                        "verification process, true/false (default is false.) "
        ]
        ]
        element oem-silent-verify {
                        k.oem-silent-verify.attlist,
            k.oem-silent-verify.content
        }
}

#==========================================
# common element <oem-swap>
#
div {
    k.oem-swap.content = xsd:boolean
    k.oem-swap.attlist = empty
    k.oem-swap =
        ## For oemboot driven images: use a swap partition yes/no
        [
        db:para [
            "For oemboot driven images: use a swap partition yes/no."
        ]
        ]
        element oem-swap {
            k.oem-swap.attlist,
            k.oem-swap.content
        }
}

#==========================================
# common element <oem-swapsize>
#
div {
    k.oem-swapsize.attlist = empty
    k.oem-swapsize =
        ## For oemboot driven images: Set the size of the swap
        ## partition in MB
        [
        db:para [
            "For oemboot driven images: Set the size of the swap\x{a}"~
            "partition in MB. No swapspace with oem-swap set to false."
        ]
        ]
        element oem-swapsize {
            k.oem-swapsize.attlist,
            xsd:nonNegativeInteger
        }
}

#==========================================
# common element <oem-systemsize>
#
div {
    k.oem-systemsize.attlist = empty
    k.oem-systemsize =
        ## For oemboot driven images: Set the size of the system
        ## (root) partition in MB
        [
        db:para [
            "For oemboot driven images: Set the size of the system\x{a}"~
            "(root) partition in MB."
        ]
        ]
        element oem-systemsize {
            k.oem-systemsize.attlist,
            xsd:nonNegativeInteger
        }
}

#==========================================
# common element <oem-unattended>
#
div {
    k.oem-unattended.content = xsd:boolean
    k.oem-unattended.attlist = empty
    k.oem-unattended =
        ## For oemboot driven images: don't ask questions if possible
        ## true/false
        [
        db:para [
            "For oemboot driven images: don't ask questions if"~
            "possible true/false"
        ]
        ]
        element oem-unattended {
            k.oem-unattended.attlist,
            k.oem-unattended.content
        }
}

#==========================================
# common element <oem-unattended-id>
#
div {
    k.oem-unattended-id.attlist = empty
    k.oem-unattended-id =
        ## For oemboot driven images: use the specified disk id
        ## the device is looked up in /dev/disk/by-* and /dev/mapper/*
        [
        db:para [
            "For oemboot driven images: use the specified disk id"
            "the device is looked up in /dev/disk/by-* and /dev/mapper/*"
        ]
        ]
        element oem-unattended-id {
            k.oem-unattended-id.attlist,
            text
        }
}

#==========================================
# common element <product>
#
div {
    k.product.name.attribute = k.name.attribute
    k.product.arch.attribute = k.arch.attribute
    k.product.attlist =
        k.product.name.attribute &
        k.product.arch.attribute?
    k.product =
        ## Name of a Product From openSUSE
        element product {
            k.product.attlist,
            empty
        }
}

#==========================================
# common element <package>
#
div {
    k.package.name.attribute = k.name.attribute
    k.package.arch.attribute = k.arch.attribute
    k.package.replaces.attribute = k.replaces.attribute
    k.package.bootinclude.attribute = k.bootinclude.attribute
    k.package.bootdelete.attribute = k.bootdelete.attribute
    k.package.attlist =
        k.package.name.attribute &
        k.package.arch.attribute? &
        k.replaces.attribute? &
        k.bootdelete.attribute? &
        k.bootinclude.attribute?
    k.package =
        ## Name of an image Package
        element package {
            k.package.attlist,
            empty
        }
}

#==========================================
# common element <packagemanager>
#
div {
    k.packagemanager.content = 
        "apt-get" | "zypper" | "yum"
    k.packagemanager.attlist = empty
    k.packagemanager =
        ## Name of the Package Manager
        [
        db:para [
            "The package manager used for package installation\x{a}"~
            "could be either zypper or smart"
        ]
        ]
        element packagemanager {
            k.packagemanager.attlist,
            k.packagemanager.content
        }
}

#==========================================
# common element <partitioner>
#
div {
    k.partitioner.content = "parted" | "fdasd"
    k.partitioner.attlist = empty
    k.partitioner =
        ## Name of the Partitioner used for any disk partition tasks
        [
        db:para [
            "The partitioner used for creating disk partitions\x{a}"~
            "could be either parted or fdasd"
        ]
        ]
        element partitioner {
            k.partitioner.attlist,
            k.partitioner.content
        }
}

#==========================================
# common element <partition>
#
div {
    k.partition.type.attribute =
        ## Partition Type identifier, see parted for details
        attribute type { text }
    k.partition.number.attribute =
        ## Partition ID
        attribute number { text }
    k.partition.size.attribute = k.size.attribute
    k.partition.mountpoint.attribute = 
        ## Mount path for this partition
        attribute mountpoint { text }
    k.partition.target.attribute =
        ## Is a real target or not which means is part of
        ## the /etc/fstab file or not
        attribute target { xsd:boolean }
    k.partition.attlist =
        k.partition.type.attribute &
        k.partition.number.attribute & 
        k.partition.size.attribute? &
        k.partition.mountpoint.attribute? &
        k.partition.target.attribute?
    k.partition =
        ## A Partition
        element partition {
            k.partition.attlist,
            empty
        }
}

#==========================================
# common element <partitions>
#
div {
    k.partitions.device.attribute =
        ## As part of the network deploy configuration this section
        ## specifies the disk device name
        attribute device { text }
    k.partitions.attlist = k.partitions.device.attribute?
    k.partitions =
        ## A List of Partitions
        element partitions { 
            k.partitions.attlist, 
            k.partition+
        }
}

#==========================================
# common element <profile>
#
div {
    k.profile.name.attribute = k.name.attribute
    k.profile.description.attribute =
        ## Description of how this profiles influences the image
        attribute description { text }
    k.profile.import.attribute =
        ## Import profile by default if no profile was set on
        ## the command line
        attribute import { xsd:boolean }
    k.profile.attlist =
        k.profile.name.attribute &
        k.profile.description.attribute &
        k.profile.import.attribute?
    k.profile =
        ## Creates Profiles
        [
        db:para [
            "Profiles creates a namespace on an image description and\x{a}"~
            "thus can be used to have one description with different\x{a}"~
            "profiles for example KDE and GNOME including different\x{a}"~
            "packages."
        ]
        ]
        element profile {
            k.profile.attlist,
            empty
        }
}

#==========================================
# common element <repository>
#
div {
    k.repository.profiles.attribute = k.profiles.attribute
    k.repository.type.attribute =
        ## Type of repository
        attribute type {
        "apt-deb" | "apt-rpm" | "deb-dir" | "mirrors" | "red-carpet" |
        "rpm-dir" | "rpm-md"  | "slack-site" | "up2date-mirrors" | "urpmi" |
        "yast2"
    }
    k.repository.status.attribute =
        ## Specifies the status of the repository. This can be
        ## replaceable or if not specified it's a must have repository
        attribute status {  "fixed" | "replaceable" }
    k.repository.alias.attribute =
        ## Alias name to be used for this repository. This is an
        ## optional free form text. If not set the source attribute
        ## value is used and builds the alias name by replacing
        ## each '/' with a '_'. An alias name should be set if the
        ## source argument doesn't really explain what this repository
        ## contains
        attribute alias { text }
    k.repository.components.attribute =
        ## Distribution components, used for deb repositories. If
        ## not set it defaults to main
        attribute components { text }
    k.repository.distribution.attribute =
        ## Distribution name information, used for deb repositories
        attribute distribution { text }
    k.repository.imageinclude.attribute =
        ## Specify whether or not this repository should be configured in the
        ## resulting image. Boolean value true or false, the default is false.
        attribute imageinclude { xsd:boolean }
    k.repository.prefer-license.attribute =
        ## Use the license found in this repository, if any, as the
        ## license installed in the image
        attribute prefer-license { xsd:boolean }
    k.repository.priority.attribute =
        ## Channel priority assigned to all packages available in
        ## this channel (0 if not set). If the exact same package
        ## is available in more than one channel, the highest
        ## priority is used
        attribute priority { xsd:integer }
    k.repository.password.attribute =
        ## Channel password if required. It depends on the url type
        ## whether and how this information is passed
        k.password.attribute
    k.repository.username.attribute =
        ## Channel username if required. It depends on the url type
        ## whether and how this information is passed
        k.username.attribute
    k.repository.attlist =
        k.repository.type.attribute? &
        k.repository.profiles.attribute? &
        k.repository.status.attribute? &
        k.repository.alias.attribute? &
        k.repository.components.attribute? &
        k.repository.distribution.attribute? &
        k.repository.imageinclude.attribute? &
        k.repository.prefer-license.attribute? &
        k.repository.priority.attribute? &
        k.repository.password.attribute? &
        k.repository.username.attribute?
    k.repository =
        ## The Name of the Repository
        element repository {
            k.repository.attlist,
            k.source
        }
}

#==========================================
# common element <source>
#
div {
    k.source.path.attribute = k.path.attribute
    k.source.attlist = k.source.path.attribute
    k.source =
        ## A Pointer to a data source. This can be a remote location
        ## as well as a path specification
        element source {
            k.source.attlist,
            empty
        }
}

#==========================================
# common element <rpm-check-signatures>
#
div {
    k.rpm-check-signatures.content = xsd:boolean
    k.rpm-check-signatures.attlist = empty
    k.rpm-check-signatures =
        ## Setup a Package Signature
        [
        db:para [
            "Setup if the package manager should check the package\x{a}"~
            "signature or not. This option could be ignored according\x{a}"~
            "to the used package manager."
        ]
        ]
        element rpm-check-signatures {
            k.rpm-check-signatures.attlist,
            k.rpm-check-signatures.content
        }
}

#==========================================
# common element <rpm-excludedocs>
#
div {
    k.rpm-excludedocs.content = xsd:boolean
    k.rpm-excludedocs.attlist = empty
    k.rpm-excludedocs =
        ## Do not install files marked as documentation in the package
        [
        db:para [
            "Setup if the package manager should exclude docs files\x{a}"~
            "during package installation. This option could be ignored\x{a}"~
            "according to the used package manager."
        ]
        ]
        element rpm-excludedocs {
            k.rpm-excludedocs.attlist,
            k.rpm-excludedocs.content
        }
}

#==========================================
# common element <rpm-force>
#
div {
    k.rpm-force.content = xsd:boolean
    k.rpm-force.attlist = empty
    k.rpm-force =
        ## Force the Installation of a Package
        [
        db:para [
        "Setup if the package manager should force the install\x{a}"~
        "of the package or not. This option could be ignored\x{a}"~
        "according to the used package manager."
        ]
        ]
        element rpm-force {
            k.rpm-force.attlist,
            k.rpm-force.content
        }
}

#==========================================
# common element <showlicense>
#
div {
    k.showlicense.attlist = empty
    k.showlicense =
        ## Setup showlicense
        [
        db:para [
            "Image license setup. The specfied license name\x{a}"~
            "will be displayed in a dialog window on boot."
        ]
        ]
        element showlicense {
            k.showlicense.attlist,
            text
        }
}

#==========================================
# common element <size>
#
div {
    k.size.unit.attribute =
        ## The unit of the image
        attribute unit { "M" | "G" }
    k.size.additive.attribute =
        attribute additive { xsd:boolean }
    k.size.attlist =
        k.size.unit.attribute? &
        k.size.additive.attribute?
    k.size =
        ## Specifies the Size of an Image in (M)egabyte or (G)igabyte
        ## If the attribute additive is set the value will be added
        ## to the required size of the image
        element size {
            k.size.attlist,
            xsd:nonNegativeInteger
        }
}

#==========================================
# common element <specification>
#
div {
    k.specification.attlist = empty
    k.specification =
        ## A Detailed Description
        [
        db:para [
            "A detailed description of this image and what it can be\x{a}"~
            "used for."
        ]
        ]
        element specification {
            k.specification.attlist,
            text
        }
}

#==========================================
# common element <systemdisk>
#
div {
    k.systemdisk.name.attribute =
        ## Specify Volume group name, default is kiwiVG. This
        ## information is only used if the LVM volume management
        ## is used
        attribute name { text }
    k.systemdisk.preferlvm.attribute =
        ## Prefer LVM even if the used filesystem has its own
        ## volume management system
        attribute preferlvm { xsd:boolean }
    k.systemdisk.attlist =
        k.systemdisk.name.attribute? &
        k.systemdisk.preferlvm.attribute?
    k.systemdisk =
        ## Specify volumes and size attributes
        [
        db:para [
            "Specify volumes and size attributes"
        ]
        ]
        element systemdisk {
            k.systemdisk.attlist &
            k.volume*
        }
}

#==========================================
# common element <timeout>
#
div {
    k.timeout.attlist = empty
    k.timeout = 
        ## Specifies an ATFTP Download Timeout
        [
        db:para [
            "As part of the network deploy configuration this section\x{a}"~
            "specifies an ATFTP download timeout"
        ]
        ]
        element timeout {
            k.timeout.attlist,
            text
        }
}

#==========================================
# common element <timezone>
#
div {
    k.timezone.attlist = empty
    k.timezone =  
        ## Setup Image Timezone setup
        [
        db:para [
            "Image timezone setup. The value will be used to search\x{a}"~
            "the correct timezone and copy it to /etc/localtime."
        ]
        ]
        element timezone {
            k.timezone.attlist,
            text
        }
}

#==========================================
# common element <type>
#
div {
    sch:pattern [
        abstract = "true"
        id = "image_type"
        sch:rule [
            context = "type[@$attr]"
            sch:assert [
                test = "contains('$types', @image)"
                "$attr attribute is only available for the following "~
                "image types: $types"
            ]
        ]
    ]
    k.type.boot.attribute =
        ## Specifies the path of the boot image (initrd), relative
        ## to /usr/share/kiwi/image
        attribute boot { text }
        >> sch:pattern [ id = "boot" is-a = "image_type"
            sch:param [ name = "attr" value = "boot" ]
            sch:param [ name = "types" value = "oem iso pxe vmx" ]
        ]
    k.type.bootkernel.attribute =
        ## Specifies the kernel boot profile defined in the boot
        ## image description. When kiwi builds the boot image the
        ## information is passed as add-profile option
        attribute bootkernel { text }
    k.type.bootloader.attribute =
        ## Specifies the bootloader used for booting the image.
        ## At the moment grub2, zipl and the combination of zipl plus
        ## userspace grub2 are supported. The special custom entry
        ## allows to skip the bootloader configuration and installation
        ## and leaves this up to the user which can be done by using
        ## the editbootinstall and editbootconfig custom scripts
        attribute bootloader {
            "grub2" | "zipl" | "grub2_s390x_emu" | "custom"
        }
        >> sch:pattern [ id = "bootloader" is-a = "image_type"
            sch:param [ name = "attr" value = "bootloader" ]
            sch:param [ name = "types" value = "oem vmx" ]
        ]
    k.type.bootloader_console.attribute =
        ## Specifies the bootloader console.
        ## The value only has an effect for the grub bootloader.
        ## By default a graphics console setup is used
        attribute bootloader_console {
            "console" | "gfxterm" | "serial"
        }
        >> sch:pattern [ id = "bootloader_console" is-a = "image_type"
            sch:param [ name = "attr" value = "bootloader_console" ]
            sch:param [ name = "types" value = "oem vmx iso" ]
        ]
    k.type.btrfs_root_is_snapshot =
        ## Tell kiwi to install the system into a btrfs snapshot
        ## The snapshot layout is compatible with the snapper management
        ## toolkit. By default no snapshots are used
        attribute btrfs_root_is_snapshot { xsd:boolean }
        >> sch:pattern [ id = "btrfs_root_is_snapshot" is-a = "image_type"
            sch:param [ name = "attr" value = "btrfs_root_is_snapshot" ]
            sch:param [ name = "types" value = "oem vmx docker" ]
        ]
    k.type.btrfs_root_is_readonly_snapshot =
        ## Tell kiwi to set the btrfs root filesystem snapshot read-only
        ## Once all data has been placed to the root filesystem snapshot
        ## it will be turned into read-only mode if this option is set to
        ## true. The option is only effective if btrfs_root_is_snapshot
        ## is also set to true. By default the root filesystem snapshot
        ## is writable
        attribute btrfs_root_is_readonly_snapshot { xsd:boolean }
        >> sch:pattern [ id = "btrfs_root_is_readonly_snapshot" is-a = "image_type"
            sch:param [ name = "attr" value = "btrfs_root_is_readonly_snapshot" ]
            sch:param [ name = "types" value = "oem vmx docker" ]
        ]
    k.type.target_blocksize =
        ## Specifies the image blocksize in bytes which has to match
        ## the logical (SSZ) blocksize of the target storage device.
        ## By default 512 byte is used which works on many disks
        ## However 4096 byte disks are coming. You can check the
        ## desired target by calling: blockdev --report device
        attribute target_blocksize { xsd:nonNegativeInteger }
        >> sch:pattern [ id = "target_blocksize" is-a = "image_type"
            sch:param [ name = "attr" value = "target_blocksize" ]
            sch:param [ name = "types" value = "oem vmx" ]
        ]
    k.type.target_removable =
        ## Indicate if the target disk for oem images is deployed
        ## to a removable device e.g a USB stick or not. This only
        ## affects the EFI setup if requested and in the end avoids
        ## the creation of a custom boot menu entry in the firmware
        ## of the target machine. By default the target disk is
        ## expected to be non-removable
        attribute target_removable { xsd:boolean }
        >> sch:pattern [ id = "target_removable" is-a = "image_type"
            sch:param [ name = "attr" value = "target_removable" ]
            sch:param [ name = "types" value = "oem vmx" ]
        ]
    k.type.spare_part =
        ## Request a spare partition right before the root partition
        ## of the requested size. The attribute takes a size value
        ## and allows a unit in MB or GB, e.g 200M. If no unit is given
        ## the value is considered to be mbytes. A spare partition
        ## can only be configured for the disk image types oem and vmx
        attribute spare_part { partition-size-type }
        >> sch:pattern [ id = "spare_part" is-a = "image_type"
            sch:param [ name = "attr" value = "spare_part" ]
            sch:param [ name = "types" value = "oem vmx" ]
        ]
    k.type.zipl_targettype.attribute =
        ## The device type of the disk zipl should boot. On zFCP
        ## devices use SCSI, on DASD devices use CDL or LDL on
        ## emulated DASD devices use FBA
        attribute zipl_targettype {
            "CDL" | "LDL" | "FBA" | "SCSI"
        }
        >> sch:pattern [ id = "zipl_targettype" is-a = "image_type"
            sch:param [ name = "attr" value = "zipl_targettype" ]
            sch:param [ name = "types" value = "oem vmx" ]
        ]
    k.type.bootpartsize.attribute =
        ## For images with a separate boot partition this attribute
        ## specifies the size in MB. If not set the min bootpart
        ## size is set to 200 MB
        attribute bootpartsize { xsd:nonNegativeInteger }
        >> sch:pattern [ id = "bootpartsize" is-a = "image_type"
            sch:param [ name = "attr" value = "bootpartsize" ]
            sch:param [ name = "types" value = "oem vmx" ]
        ]
    k.type.efipartsize.attribute =
        ## For images with an EFI fat partition this attribute
        ## specifies the size in MB. If not set the min efipart
        ## size is set to 20 MB
        attribute efipartsize { xsd:nonNegativeInteger }
        >> sch:pattern [ id = "efipartsize" is-a = "image_type"
            sch:param [ name = "attr" value = "efipartsize" ]
            sch:param [ name = "types" value = "oem vmx" ]
        ]
    k.type.bootprofile.attribute =
        ## Specifies the boot profile defined in the boot image
        ## description. When kiwi builds the boot image the
        ## information is passed as add-profile option
        attribute bootprofile { text }
        >> sch:pattern [ id = "bootprofile" is-a = "image_type"
            sch:param [ name = "attr" value = "bootprofile" ]
            sch:param [ name = "types" value = "oem vmx iso pxe cpio" ]
        ]
    k.type.boottimeout.attribute =
        ## Specifies the boot timeout in seconds prior to launching
        ## the default boot option. the unit for the timeout value
        ## is seconds if GRUB is used as the boot loader and 1/10
        ## seconds if syslinux is used
        attribute boottimeout { xsd:nonNegativeInteger }
        >> sch:pattern [ id = "boottimeout" is-a = "image_type"
            sch:param [ name = "attr" value = "boottimeout" ]
            sch:param [ name = "types" value = "oem vmx iso pxe" ]
        ]
    k.type.checkprebuilt.attribute =
        ## Activates whether KIWI should search for a prebuild boot
        ## image or not. Obsolete attribute since KIWI v8
        attribute checkprebuilt { xsd:boolean }
    k.type.compressed.attribute =
        ## Specifies whether the image output file should be
        ## compressed or not. This makes only sense for filesystem
        ## only images respectively for the pxe or cpio type
        attribute compressed { xsd:boolean }
        >> sch:pattern [ id = "compressed" is-a = "image_type"
            sch:param [ name = "attr" value = "compressed" ]
            sch:param [ name = "types" value = "pxe" ]
        ]
    k.type.devicepersistency.attribute =
        ## Specifies which method to use in order to get persistent
        ## storage device names. By default by-uuid is used.
        attribute devicepersistency { "by-uuid" | "by-label" | "by-path" }
    k.type.editbootconfig.attribute =
        ## Specifies the path to a script which is called right
        ## before the bootloader is installed. The script runs
        ## relative to the directory which contains the image
        ## structure
        attribute editbootconfig { text }
        >> sch:pattern [ id = "editbootconfig" is-a = "image_type"
            sch:param [ name = "attr" value = "editbootconfig" ]
            sch:param [ name = "types" value = "vmx oem" ]
        ]
    k.type.editbootinstall.attribute =
        ## Specifies the path to a script which is called right
        ## after the bootloader is installed. The script runs
        ## relative to the directory which contains the image
        ## structure
        attribute editbootinstall { text }
        >> sch:pattern [ id = "editbootinstall" is-a = "image_type"
            sch:param [ name = "attr" value = "editbootinstall" ]
            sch:param [ name = "types" value = "vmx oem" ]
        ]
    k.type.filesystem.attribute = 
        ## Specifies the root filesystem type
        attribute filesystem {
            "btrfs" | "ext2" | "ext3" | "ext4" | "squashfs" | "xfs"
        }
        >> sch:pattern [ id = "filesystem" is-a = "image_type"
            sch:param [ name = "attr" value = "filesystem" ]
            sch:param [ name = "types" value = "vmx oem pxe" ]
        ]
    k.type.overlayroot.attribute =
        ## Specifies to use an overlay root system consisting
        ## out of a squashfs compressed read-only root system
        ## overlayed using the overlayfs filesystem into an
        ## extra read-write partition. Available for the disk
        ## image types, vmx and oem
        attribute overlayroot { xsd:boolean }
        >> sch:pattern [ id = "overlayroot" is-a = "image_type"
            sch:param [ name = "attr" value = "overlayroot" ]
            sch:param [ name = "types" value = "vmx oem" ]
        ]
    k.type.firmware.attribute =
        ## Specifies the boot firmware of the system. Most systems
        ## uses a standard BIOS but there are also other firmware
        ## systems like efi, coreboot, etc.. This attribute is
        ## used to differentiate the image according to the firmware
        ## which boots up the system. It mostly has an impact on
        ## the disk layout and the partition table type. By default
        ## the standard x86 bios firmware setup is used
        attribute firmware {
            "bios" | "ec2" | "ec2hvm" | "efi" |
            "uefi" | "ofw" | "opal"
        }
        >> sch:pattern [ id = "firmware" is-a = "image_type"
            sch:param [ name = "attr" value = "firmware" ]
            sch:param [ name = "types" value = "vmx oem pxe iso" ]
        ]
    k.type.bootpartition.attribute =
        ## specify if an extra boot partition should be used or not.
        ## This will overwrite kiwi's default layout
        attribute bootpartition { xsd:boolean }
        >> sch:pattern [ id = "bootpartition" is-a = "image_type"
            sch:param [ name = "attr" value = "bootpartition" ]
            sch:param [ name = "types" value = "vmx oem" ]
        ]
    k.type.bootfilesystem.attribute =
        ## if an extra boot partition is required this attribute
        ## specify which filesystem should be used for it. The
        ## type of the bootloader might overwrite this setting
        ## e.g for the syslinux loader fat is required
        attribute bootfilesystem {
            "ext2" | "ext3" | "ext4" | "fat32" | "fat16"
        }
        >> sch:pattern [ id = "bootfilesystem" is-a = "image_type"
            sch:param [ name = "attr" value = "bootfilesystem" ]
            sch:param [ name = "types" value = "vmx oem" ]
        ]
    k.type.flags.attribute =
        ## Specifies flags for the image type. This could be compressed
        ## or clic and applies to the iso type only
        attribute flags {
            "clic" | "compressed" | "clic_udf" | "overlay" | "seed"
        }
        >> sch:pattern [ id = "flags" is-a = "image_type"
            sch:param [ name = "attr" value = "flags" ]
            sch:param [ name = "types" value = "iso" ]
        ]
    k.type.format.attribute =
        ## Specifies the format of the virtual disk.
        ## The ec2 value is deprecated and no longer supported
        ## It remains in the schema to allow us to print a better
        ## Error message than we receive from the parser.
        ## To be remove from here by the end of 2014
        attribute format {
            "ec2" | "gce" | "ovf" | "ova" | "qcow2" | "vagrant" | "vmdk" |
            "vdi" | "vhd" | "vhd-fixed"
        }
        >> sch:pattern [ id = "format" is-a = "image_type"
            sch:param [ name = "attr" value = "format" ]
            sch:param [ name = "types" value = "vmx oem" ]
        ]
    k.type.formatoptions.attribute =
        ## Specifies additional format options passed on to qemu-img
        ## formatoptions is a comma separated list of format specific
        ## options in a name=value format like qemu-img expects it.
        ## kiwi will take the information and pass it as parameter to
        ## the -o option in the qemu-img call
        attribute formatoptions { text }
        >> sch:pattern [ id = "formatoptions" is-a = "image_type"
            sch:param [ name = "attr" value = "formatoptions" ]
            sch:param [ name = "types" value = "vmx oem" ]
        ]
    k.type.fsnocheck.attribute =
        ## Turn off periodic filesystem checks on ext2/3/4. Obsolete attribute
        ## since KIWI v8
        attribute fsnocheck { xsd:boolean }
    k.type.fsmountoptions.attribute =
        ## Specifies the filesystem mount options which also ends up in fstab
        ## The string given here is passed as value to the -o option of mount
        attribute fsmountoptions { text }
    k.type.hybrid.attribute =
        ## Specifies that the image file should be turned into
        ## a hybrid image file. It's required to use the vmxboot
        ## boot image to boot that image though
        attribute hybrid { xsd:boolean }
        >> sch:pattern [ id = "hybrid" is-a = "image_type"
            sch:param [ name = "attr" value = "hybrid" ]
            sch:param [ name = "types" value = "iso pxe" ]
        ]
    k.type.hybridpersistent.attribute =
        ## Will trigger the creation of a partition for a COW file
        ## to keep data persistent over a reboot
        attribute hybridpersistent { xsd:boolean }
        >> sch:pattern [ id = "hybridpersistent" is-a = "image_type"
            sch:param [ name = "attr" value = "hybridpersistent" ]
            sch:param [ name = "types" value = "iso pxe" ]
        ]
    k.type.hybridpersistent_filesystem.attribute =
        ## Set the filesystem to use for persistent writing if a
        ## hybrid image is used as disk on e.g a USB Stick. By default
        ## the btrfs filesystem is used
        attribute hybridpersistent_filesystem {
            "btrfs" | "fat" | "exfat" | "ext4" | "xfs"
        }
        >> sch:pattern [ id = "hybridpersistent_filesystem" is-a = "image_type"
            sch:param [ name = "attr" value = "hybridpersistent_filesystem" ]
            sch:param [ name = "types" value = "iso pxe" ]
        ]
    k.type.gpt_hybrid_mbr =
        ## for gpt disk types only:
        ## create a hybrid GPT/MBR partition table
        attribute gpt_hybrid_mbr { xsd:boolean }
        >> sch:pattern [ id = "gpt_hybrid_mbr" is-a = "image_type"
            sch:param [ name = "attr" value = "gpt_hybrid_mbr" ]
            sch:param [ name = "types" value = "vmx oem" ]
        ]
    k.type.initrd_system.attribute =
        ## specify which initrd builder to use, default is kiwi's
        ## builtin architecture. Be aware that the dracut initrd
        ## system does not support all features of the kiwi initrd
        attribute initrd_system {
            "kiwi" | "dracut"
        }
        >> sch:pattern [ id = "initrd_system" is-a = "image_type"
            sch:param [ name = "attr" value = "initrd_system" ]
            sch:param [ name = "types" value = "vmx oem" ]
        ]
    k.type.image.attribute =
        ## Specifies the image type
        attribute image {
            "btrfs" | "clicfs" | "cpio" | "docker" | "ext2" | "ext3" |
            "ext4" | "iso" | "oem" | "pxe" | "squashfs" | "tbz" |
            "vmx" | "xfs"
        }
    k.type.installboot.attribute =
        ## Specifies the bootloader default boot entry for the"
        ## initial boot of a kiwi install image. This value is"
        ## only evaluated for grub and ext|syslinux"
        attribute installboot {
            "failsafe-install" | "harddisk" | "install"
        }
        >> sch:pattern [ id = "installboot" is-a = "image_type"
            sch:param [ name = "attr" value = "installboot" ]
            sch:param [ name = "types" value = "oem" ]
        ]
    k.type.installprovidefailsafe.attribute =
        ## Specifies if the bootloader menu should provide an"
        ## failsafe entry with special kernel parameters or not"
        attribute installprovidefailsafe { xsd:boolean }
        >> sch:pattern [ id = "installprovidefailsafe" is-a = "image_type"
            sch:param [ name = "attr" value = "installprovidefailsafe" ]
            sch:param [ name = "types" value = "oem" ]
        ]
    k.type.installiso.attribute =
        ## Specifies if a install iso should be created (oem only)
        attribute installiso { xsd:boolean }
        >> sch:pattern [ id = "installiso" is-a = "image_type"
            sch:param [ name = "attr" value = "installiso" ]
            sch:param [ name = "types" value = "oem" ]
        ]
    k.type.installstick.attribute =
        ## Specifies if a install stick should be created (oem only)
        attribute installstick { xsd:boolean }
        >> sch:pattern [ id = "installstick" is-a = "image_type"
            sch:param [ name = "attr" value = "installstick" ]
            sch:param [ name = "types" value = "oem" ]
        ]
    k.type.installpxe.attribute =
        ## Specifies if all data for a pxe network installation should
        ## be created (oem only)
        attribute installpxe { xsd:boolean }
        >> sch:pattern [ id = "installpxe" is-a = "image_type"
            sch:param [ name = "attr" value = "installpxe" ]
            sch:param [ name = "types" value = "oem" ]
        ]
    k.type.kernelcmdline.attribute =
        # The kernelcmdline element specifies additional
        # kernel command line options
        attribute kernelcmdline { text }
        >> sch:pattern [ id = "kernelcmdline" is-a = "image_type"
            sch:param [ name = "attr" value = "kernelcmdline" ]
            sch:param [ name = "types" value = "oem vmx iso pxe" ]
        ]
    k.type.luks.attribute =
        ## Setup cryptographic volume along with the given filesystem
        ## using the LUKS extension. The value of this attribute
        ## represents the password string used to be able to
        ## mount that filesystem while booting
        attribute luks { text }
        >> sch:pattern [ id = "luks" is-a = "image_type"
            sch:param [ name = "attr" value = "luks" ]
            sch:param [ name = "types" value = "oem vmx iso pxe" ]
        ]
    k.type.luksOS.attribute =
        ## With the luksOS value a predefined set of ciper, keysize
        ## and hash format options is passed to the cryptsetup call
        ## in order to create a format compatible to the specified
        ## distribution
        attribute luksOS {
            "sle11"
        }
        >> sch:pattern [ id = "luksOS" is-a = "image_type"
            sch:param [ name = "attr" value = "luksOS" ]
            sch:param [ name = "types" value = "oem vmx iso pxe" ]
        ]
    k.type.mdraid.attribute =
        ## Setup software raid in degraded mode with one disk
        ## Thus only mirroring and striping is possible
        attribute mdraid {
            "mirroring" | "striping"
        }
        >> sch:pattern [ id = "mdraid" is-a = "image_type"
            sch:param [ name = "attr" value = "mdraid" ]
            sch:param [ name = "types" value = "oem vmx" ]
        ]
    k.type.primary.attribute =
        ## Specifies the primary type (choose KIWI option type)
        attribute primary { xsd:boolean }
    k.type.ramonly.attribute =
        ## for use with overlay filesystems only:
        ## will force any COW action to happen in RAM
        attribute ramonly { xsd:boolean }
        >> sch:pattern [ id = "ramonly" is-a = "image_type"
            sch:param [ name = "attr" value = "ramonly" ]
            sch:param [ name = "types" value = "oem vmx" ]
        ]
    k.type.rootfs_label.attribute =
        ## label to set for the root filesystem. By default ROOT is used
        attribute rootfs_label { text }
        >> sch:pattern [ id = "rootfs_label" is-a = "image_type"
            sch:param [ name = "attr" value = "rootfs_label" ]
            sch:param [ name = "types" value = "oem vmx pxe docker" ]
        ] 
    k.type.vga.attribute =
        ## Specifies the kernel framebuffer mode. More information
        ## about the possible values can be found by calling
        ## hwinfo --framebuffer or in /usr/src/linux/Documentation/fb/vesafb.txt
        attribute vga { text }
        >> sch:pattern [ id = "vga" is-a = "image_type"
            sch:param [ name = "attr" value = "vga" ]
            sch:param [ name = "types" value = "oem vmx pxe iso" ]
        ]
    k.type.gcelicense.attribute =
        ## Specifies the license tag in a GCE format
        attribute gcelicense { text }
        >> sch:pattern [ id = "gcelicense" is-a = "image_type"
            sch:param [ name = "attr" value = "gcelicense" ]
            sch:param [ name = "types" value = "oem vmx" ]
        ]
    k.type.vhdfixedtag.attribute =
        ## Specifies the GUID in a fixed format VHD
        attribute vhdfixedtag { vhd-tag-type }
        >> sch:pattern [ id = "vhdfixedtag" is-a = "image_type"
            sch:param [ name = "attr" value = "vhdfixedtag" ]
            sch:param [ name = "types" value = "oem vmx" ]
        ]
    k.type.volid.attribute =
        ## for the iso type only:
        ## Specifies the volume ID (volume name or label) to be written
        ## into the master block. There is space for 32 characters.
        attribute volid { text }
        >> sch:pattern [ id = "volid" is-a = "image_type"
            sch:param [ name = "attr" value = "volid" ]
            sch:param [ name = "types" value = "iso" ]
        ]
    k.type.wwid_wait_timeout.attribute =
        ## Specifies the wait period in seconds after launching
        ## the multipath daemon to wait until all presented devices
        ## are available on the host. Default timeout is 3 seconds
        attribute wwid_wait_timeout { xsd:nonNegativeInteger }
        >> sch:pattern [ id = "wwid_wait_timeout" is-a = "image_type"
            sch:param [ name = "attr" value = "wwid_wait_timeout" ]
            sch:param [ name = "types" value = "oem" ]
        ]
    k.type.attlist =
        k.type.boot.attribute? &
        k.type.bootfilesystem.attribute? &
        k.type.firmware.attribute? &
        k.type.bootkernel.attribute? &
        k.type.bootloader.attribute? &
        k.type.bootloader_console.attribute? &
        k.type.zipl_targettype.attribute? &
        k.type.bootpartition.attribute? &
        k.type.bootpartsize.attribute? &
        k.type.efipartsize.attribute? &
        k.type.bootprofile.attribute? &
        k.type.boottimeout.attribute? &
        k.type.btrfs_root_is_snapshot? &
        k.type.btrfs_root_is_readonly_snapshot? &
        k.type.checkprebuilt.attribute? &
        k.type.compressed.attribute? &
        k.type.devicepersistency.attribute? &
        k.type.editbootconfig.attribute? &
        k.type.editbootinstall.attribute? &
        k.type.filesystem.attribute? &
        k.type.flags.attribute? &
        k.type.format.attribute? &
        k.type.formatoptions.attribute? &
        k.type.fsnocheck.attribute? &
        k.type.fsmountoptions.attribute? &
        k.type.gcelicense.attribute? &
        k.type.hybrid.attribute? &
        k.type.hybridpersistent.attribute? &
        k.type.hybridpersistent_filesystem.attribute? &
        k.type.gpt_hybrid_mbr? &
        k.type.initrd_system.attribute? &
        k.type.image.attribute &
        k.type.installboot.attribute? &
        k.type.installprovidefailsafe.attribute? &
        k.type.installiso.attribute? &
        k.type.installstick.attribute? &
        k.type.installpxe.attribute? &
        k.type.kernelcmdline.attribute? &
        k.type.luks.attribute? &
        k.type.luksOS.attribute? &
        k.type.mdraid.attribute? &
        k.type.overlayroot.attribute? &
        k.type.primary.attribute? &
        k.type.ramonly.attribute? &
        k.type.rootfs_label.attribute? &
        k.type.spare_part? &
        k.type.target_blocksize? &
        k.type.target_removable? &
        k.type.vga.attribute? &
        k.type.vhdfixedtag.attribute? &
        k.type.volid.attribute? &
        k.type.wwid_wait_timeout.attribute?
    k.type =
        ## The Image Type of the Logical Extend
        element type { 
            k.type.attlist &
            k.containerconfig? &
            k.machine? &
            k.oemconfig? &
            k.pxedeploy? &
            k.size? &
            k.systemdisk? &
            k.vagrantconfig*
        }
}

#==========================================
# common element <union>
#
div {
    k.union.ro.attribute =
        ## Device only for read-only 
        attribute ro { text }
    k.union.rw.attribute =
        ## Device for Read-Write
        attribute rw { text }
    k.union.type.attribute = attribute type { "overlayfs" }
    k.union.attlist =
        k.union.ro.attribute &
        k.union.rw.attribute &
        k.union.type.attribute
    
    k.union =  
        ## Specifies the Overlay Filesystem
        [
        db:para [
            "As part of the network deploy configuration this section\x{a}"~
            "specifies the overlay filesystem setup if required by the\x{a}"~
            "filesystem type of the system image.An overlay setup is\x{a}"~
            "only required if the system image uses a squashfs\x{a}"~
            "compressed filesystem."
        ]
        ]
        element union {
            k.union.attlist,
            empty
        }
}

#==========================================
# common element <user>
#
div {
    k.user.name.attribute = k.name.attribute
    k.user.id.attribute = 
        ## The user ID for this user
        attribute id { xsd:nonNegativeInteger }
    k.user.groups.attribute =
        ## The list of groups that he user belongs to. The
        ## frist item in the list is used as the login group.
        ## If 'groups' is not present a default group is assigned
        ## to the user according to he specifing toolchain behaviour.
        attribute groups { groups-list }
    k.user.realname.attribute =
        ## The name of an user
        attribute realname { text }
    k.user.password.attribute = k.password.attribute
    k.user.pwdformat =
        ## Format of the given password, encrypted is the default
        attribute pwdformat { "encrypted" | "plain" }
    k.user.home.attribute =
        ## The home directory for this user
        attribute home { text }
    k.user.shell.attribute =
        ## The shell for this user
        attribute shell { text }
    k.user.attlist =
        k.user.groups.attribute? &
        k.user.home.attribute &
        k.user.id.attribute? &
        k.user.name.attribute &
        k.user.password.attribute? &
        k.user.pwdformat? &
        k.user.realname.attribute? &
        k.user.shell.attribute?
    k.user =
        ## A User with Name, Password, Path to Its Home And Shell
        element user {
            k.user.attlist &
            empty
        }
}

#==========================================
# common element <version>
#
div {
    k.version.attlist = empty
    k.version =
        ## A Version Number for the Image, Consists of Major.Minor.Release 
        element version {
            k.version.attlist &
            text
        }
}

#==========================================
# common element <vmconfig-entry>
#
div {
    k.vmconfig-entry.attlist = empty
    k.vmconfig-entry =
        ## An entry for the VM configuration file
        element vmconfig-entry {
            k.vmconfig-entry.attlist &
            text
        }
}

#==========================================
# common element <vmdisk>
#
div {
    k.vmdisk.disktype.attribute =
        ## The type of the disk as it is internally handled
        ## by the VM (ovf only)
        attribute disktype { text }
    k.vmdisk.controller.attribute =
        ## The disk controller used for the VM guest (vmdk only)
        attribute controller {
            "ide"        |
            "buslogic"   |
            "lsilogic"   |
            "lsisas1068" |
            "legacyESX"  |
            "pvscsi"
        }
    k.vmdisk.id.attribute =
        ## The disk ID / device for the VM disk (vmdk only)
        attribute id { xsd:nonNegativeInteger }
    k.vmdisk.device.attribute =
        ## The disk device to appear in the guest (xen only)
        attribute device { text }
    k.vmdisk.diskmode.attribute = 
        ## The disk mode (vmdk only)
        attribute diskmode {
            "monolithicSparse"     |
            "monolithicFlat"       |
            "twoGbMaxExtentSparse" |
            "twoGbMaxExtentFlat"   |
            "streamOptimized"
        }
    k.vmdisk.attlist =
        k.vmdisk.disktype.attribute? &
        k.vmdisk.controller.attribute? &
        k.vmdisk.id.attribute? &
        k.vmdisk.device.attribute? &
        k.vmdisk.diskmode.attribute?
    k.vmdisk =
        ## The VM disk definition.
        element vmdisk {
            k.vmdisk.attlist &
            empty
        }
}

#==========================================
# common element <vmdvd>
#
div {
    k.vmdvd.controller.attribute =
        ## The CD/DVD controller used for the VM guest
        attribute controller { "ide" | "scsi" }
    k.vmdvd.id.attribute =
        ## The CD/DVD ID for the VM CD rom drive
        attribute id { xsd:nonNegativeInteger }
    k.vmdvd.attlist =
        k.vmdvd.controller.attribute &
        k.vmdvd.id.attribute
    k.vmdvd =
        ## The VM CD/DVD drive definition. You can setup either a
        ## scsi CD or an ide CD drive
        element vmdvd {
            k.vmdvd.attlist &
            empty
        }
}

#==========================================
# common element <vmnic>
#
div {
    k.vmnic.driver.attribute =
        ## The driver used for the VM network interface
        attribute driver { text }
    k.vmnic.interface.attribute =
        ## The interface ID for the VM network interface
        attribute interface { text }
    k.vmnic.mode.attribute =
        ## The VM network mode
        attribute mode { text }
    k.vmnic.mac.attribute =
        ## The VM mac address
        attribute mac { mac-address-type }
    k.vmnic.attlist =
        k.vmnic.driver.attribute? &
        k.vmnic.interface.attribute &
        k.vmnic.mode.attribute? &
        k.vmnic.mac.attribute?
    k.vmnic =
        ## The VM network interface definition
        element vmnic {
            k.vmnic.attlist &
            empty
        }
}

#==========================================
# common element <volume>
#
div {
    k.volume.freespace.attribute =
        ## free space to be added to this volume. The value is
        ## used as MB by default but you can add "M" and/or "G" as
        ## postfix
        attribute freespace { volume-size-type }
    k.volume.name.attribute =
        ## volume name. The name of the volume. if mountpoint is
        ## not specified the name specifies a path which has to
        ## exist inside the root directory.
        attribute name { text }
    k.volume.mountpoint.attribute =
        ## volume path. The mountpoint specifies a path which has to
        ## exist inside the root directory.
        attribute mountpoint { text }
    k.volume.size.attribute =
        ## absolute size of the volume. If the size value
        ## is too small to store all data kiwi will exit.
        ## The value is used as MB by default but you can
        ## add "M" and/or "G" as postfix
        attribute size { volume-size-type }
    k.volume.copy_on_write.attribute =
        ## Apply the filesystem copy-on-write attribute for this volume
        attribute copy_on_write { xsd:boolean }
    k.volume.attlist =
        k.volume.copy_on_write.attribute? &
        k.volume.freespace.attribute? &
        k.volume.mountpoint.attribute? &
        k.volume.name.attribute &
        k.volume.size.attribute?
    k.volume =
        ## Specify which parts of the filesystem should be
        ## on an extra volume.
        [
        db:para [
            "Specify which parts of the filesystem should be on\x{a}"
            "an extra volume."
        ]
        ]
        element volume {
            k.volume.attlist,
            empty
        }
}

#==========================================
# main block: <pxedeploy>
#
div {
    k.pxedeploy.server.attribute =
        ## Name or IP Address of server for downloading the data
        attribute server { text }
    k.pxedeploy.blocksize.attribute = 
        ## Blocksize value used for atftp downloads
        attribute blocksize { xsd:nonNegativeInteger }
    k.pxedeploy.attlist =
        k.pxedeploy.server.attribute? &
        k.pxedeploy.blocksize.attribute?
    k.pxedeploy =
        ## Controls the Image Deploy Process
        [
        db:para [
            "The deploy section is used to allow kiwi to create the\x{a}"~
            "config.<MAC> file required by PXE based network images.\x{a}"~
            "the contents of this file controls the image deploy process."
        ]
        ]
        element pxedeploy {
            k.pxedeploy.attlist &
            k.timeout? &
            k.kernel? &
            k.initrd? &
            k.partitions? &
            k.union? &
            k.configuration*
        }
}

#==========================================
# main block: <description>
#
div {
    k.description.type.attribute = 
        ## Kiwi distinguishes between two basic image description types
        ## which uses the same format but one is created and provided by
        ## the kiwi developers and the other is created by the users of
        ## kiwi. The type=boot specifies a boot image (initrd) which should
        ## be provided by the kiwi developers wheras type=system specifies
        ## a standard image description created by a kiwi user.
        attribute type { "boot" | "system" }
    k.description.attlist = k.description.type.attribute
    k.description =  
        ## A Short Description
        element description {
            k.description.attlist &
            k.author &
            k.contact+ &
            k.specification
        }
}

#==========================================
# main block: <drivers>
#
div {
    k.drivers.profiles.attribute = k.profiles.attribute
    k.drivers.attlist = 
        k.drivers.profiles.attribute?
        
    k.drivers =
        ## A Collection of Driver Files 
        element drivers {
            k.drivers.attlist &
            k.file+
        }
}

#==========================================
# main block: <strip>
#
div {
    k.strip.type.attribute = attribute type {
        "delete" | "tools" | "libs"
    }
    k.strip.profiles.attribute = k.profiles.attribute
    k.strip.attlist =
        k.strip.type.attribute &
        k.strip.profiles.attribute?
    k.strip =
        ## A Collection of files to strip
        element strip {
            k.strip.attlist &
            k.file+
        }
}

#==========================================
# main block: <containerconfig>
#
div {
    sch:pattern [
        abstract = "true"
        id = "container_type"
        sch:rule [
            context = "containerconfig"
            sch:assert [
                test = "contains('$types', ../@image)"
                "containerconfig($attr) is only available for the following "~
                "image types: $types"
            ]
        ]
    ]
    k.containerconfig.name.attribute =
        ## Specifies a name for the container. This is usually the
        ## the tag name of the container as read if the container
        ## image is imported via the docker load command
        attribute name { text }
        >> sch:pattern [ id = "name" is-a = "container_type"
            sch:param [ name = "attr" value = "name" ]
            sch:param [ name = "types" value = "docker" ]
        ]
    k.containerconfig.entry_command.attribute =
        ## Specifies the default command to run if the container is
        ## called via the docker run command.
        attribute entry_command { text }
        >> sch:pattern [ id = "entry_command" is-a = "container_type"
            sch:param [ name = "attr" value = "entry_command" ]
            sch:param [ name = "types" value = "docker" ]
        ]
    k.containerconfig.attlist =
        k.containerconfig.name.attribute &
        k.containerconfig.entry_command.attribute?

    k.containerconfig =
        ## Provides metadata information for containers
        [
        db:para [
            "The containerconfig element provides metadata information"
            "to setup a container in order to be prepared for use with"
            "the container engine tool chain. container specific data"
            "should be provided in an additional subsection whereas this"
            "section provides globally useful container information"
        ]
        ]
        element containerconfig {
            k.containerconfig.attlist
        }
}

#==========================================
# main block: <oemconfig>
#
div {
    k.oemconfig.attlist = empty
    k.oemconfig =
        ## Specifies the OEM configuration section
        [
        db:para [
            "The oemconfig element specifies the OEM image\x{a}"~
            "configuration options which are used to repartition\x{a}"~
            "and setup the system disk"
        ]
        ]
        element oemconfig {
            k.oemconfig.attlist &
            k.oem-ataraid-scan? &
            k.oem-boot-title? &
            k.oem-bootwait? &
            k.oem-device-filter? &
            k.oem-inplace-recovery? &
            k.oem-kiwi-initrd? &
            k.oem-multipath-scan? &
            k.oem-vmcp-parmfile? &
            k.oem-partition-install? &
            k.oem-reboot? &
            k.oem-reboot-interactive? &
            k.oem-recovery? &
            k.oem-recoveryID? &
            k.oem-recovery-part-size? &
            k.oem-shutdown? &
            k.oem-shutdown-interactive? &
            k.oem-silent-boot? &
            k.oem-silent-install? &
            k.oem-silent-verify? &
            k.oem-skip-verify? &
            k.oem-swap? &
            k.oem-swapsize? &
            k.oem-systemsize? &
            k.oem-unattended? &
            k.oem-unattended-id?
        }
}

#==========================================
# main block: <vagrantconfig>
#
div {
    k.vagrantconfig.provider.attribute =
        ## The vagrant provider for this box
        attribute provider { "libvirt" }
    k.vagrantconfig.virtualsize.attribute =
        ## The vagrant virtual image size in GB
        [
        db:para [
            "virtualsize provides the value of the virtual_size key"
            "which is embedded in the metadata.json hash inside the"
            ".box file, as described here:"
            ""
            "http://docs.vagrantup.com/v2/boxes/format.html"
            ""
            "This tells the Vagrant provider how big to make the"
            "virtual disk when it creates the VM."
        ]
        ]
        attribute virtualsize { xsd:nonNegativeInteger }
    k.vagrantconfig.boxname.attribute =
        ## The boxname as it's written into the json file
        ## If not specified the image name is used
        [
        db:para [
            "The boxname as it's written into the json file."
            "If not specified the image name is used."
        ]
        ]
        attribute boxname { text }
    k.vagrantconfig.attlist =
        k.vagrantconfig.provider.attribute &
        k.vagrantconfig.virtualsize.attribute &
        k.vagrantconfig.boxname.attribute?
    k.vagrantconfig =
        ## Specifies the Vagrant configuration section
        [
        db:para [
            "The vagrantconfig element specifies the Vagrant meta"
            "configuration options which are used inside a vagrant box"
        ]
        ]
        element vagrantconfig {
            k.vagrantconfig.attlist
        }
}

#==========================================
# main block: <machine>
#
div {
    k.machine.ovftype.attribute =
        ## The OVF configuration type
        attribute ovftype { "zvm" | "powervm" | "xen" | "vmware" }
    k.machine.HWversion.attribute =
        ## The virtual HW version number for the VM configuration
        ## (vmdk and ovf)
        attribute HWversion { xsd:integer }
    k.machine.arch.attribute =
        ## the VM architecture type (vmdk only)
        attribute arch { "ix86" | "x86_64" }
    k.machine.domain.attribute =
        ## The domain setup for the VM (xen only)
        attribute domain { "dom0" | "domU" }
    k.machine.guestOS.attribute =
        ## The virtual guestOS identification string for the VM
        ## (vmdk and ovf, note the name designation is different for the two
        ## formats)
        attribute guestOS { text }
    k.machine.min_memory.attribute =
        ## The virtual machine min memory in MB (ovf only)
        attribute min_memory { xsd:nonNegativeInteger }
    k.machine.max_memory.attribute =
        ## The virtual machine max memory in MB (ovf only)
        attribute max_memory { xsd:nonNegativeInteger }
    k.machine.min_cpu.attribute =
        ## The virtual machine min CPU count (ovf only)
        attribute min_cpu { xsd:nonNegativeInteger }
    k.machine.max_cpu.attribute =
        ## The virtual machine max CPU count (ovf only)
        attribute max_cpu { xsd:nonNegativeInteger }
    k.machine.memory.attribute =
        ## The memory, in MB, setup for the guest VM (all formats)
        attribute memory { xsd:nonNegativeInteger }
    k.machine.ncpus.attribute =
        ## The number of virtual cpus for the guest VM (all formats)
        attribute ncpus { xsd:nonNegativeInteger }
    k.machine.attlist =
        k.machine.min_memory.attribute? &
        k.machine.max_memory.attribute? &
        k.machine.min_cpu.attribute? &
        k.machine.max_cpu.attribute? &
        k.machine.ovftype.attribute? &
        k.machine.HWversion.attribute? &
        k.machine.arch.attribute? &
        k.machine.domain.attribute? &
        k.machine.guestOS.attribute? &
        k.machine.memory.attribute? &
        k.machine.ncpus.attribute?
    k.machine =
        ## specifies the VM configuration sections
        [
        db:para [
            "The machine element specifies the VM guest\x{a}"~
            "configuration options which are used by the\x{a}"~
            "virtual machine when running the image."
        ]
        ]
        element machine {
            k.machine.attlist &
            k.vmconfig-entry * &
            k.vmdisk &
            k.vmdvd ? &
            k.vmnic *
        }
}

#==========================================
# main block: <packages>
#
div {
    k.packages.type.attribute = attribute type {
        "bootstrap" | "delete" | "docker" | "image" |
        "iso" | "oem" | "pxe" | "vmx"
    }
    k.packages.profiles.attribute = k.profiles.attribute
    k.packages.patternType.attribute =
        ## Selection type for patterns. Could be onlyRequired
        ## or plusRecommended
        attribute patternType {
            "onlyRequired" | "plusRecommended"
        }
    k.packages.attlist =
        k.packages.type.attribute &
        k.packages.profiles.attribute? &
        k.packages.patternType.attribute?
    k.packages =
        ## Specifies Packages/Patterns Used in Different Stages
        [
        db:para [
            "The packages elements specifies a set of packages\x{a}"~
            "and/or patterns which are used in different stages of the\x{a}"~
            "image building process\x{a}"~
            "and also depends of the selected image output type."
        ]
        ]
        element packages {
            k.packages.attlist &
            k.archive* &
            k.ignore* &
            k.namedCollection* &
            k.product* &
            k.package*
        }
}

#==========================================
# main block: <preferences>
#
div {
    k.preferences.profiles.attribute = k.profiles.attribute
    k.preferences.attlist =
        k.preferences.profiles.attribute?
    k.preferences =  
        ## Configuration Information Needed for Logical Extend
        ## All elements are optional since the combination of appropriate
        ## preference sections based on profiles combine to create on vaild
        ## definition
        element preferences {
            k.preferences.attlist &
            k.bootsplash-theme? &
            k.bootloader-theme? &
            k.defaultdestination? &
            k.defaultprebuilt? &
            k.defaultroot? &
            k.hwclock? &
            k.keytable? &
            k.locale? &
            k.packagemanager? &
            k.partitioner? &
            k.rpm-check-signatures? &
            k.rpm-excludedocs? &
            k.rpm-force? &
            k.showlicense* &
            k.timezone? &
            k.type* &
            k.version?
        }
}

#==========================================
# main block: <profiles>
#
div {
    k.profiles.attlist = empty
    k.profiles =  
        ## Creates Namespace Section for Drivers
        [
        db:para [
            "Namespace section which creates a namespace and the\x{a}"~
            "drivers can bind itself to one of the listed namespaces."
        ]
        ]
        element profiles {
            k.profiles.attlist &
            k.profile+
        }
}

#==========================================
# main block: <users>
#
div {
    k.users.profiles.attribute = k.profiles.attribute
    k.users.attlist =
        k.users.profiles.attribute?
    k.users = 
        ## A List of Users
        element users {
            k.users.attlist &
            k.user+
        }
}

# vim: set noexpandtab:
